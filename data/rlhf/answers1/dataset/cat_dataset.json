{"prompt": ["So I've a file called allTextFiles.txt in which it has paths of a all regular text file.eg:\n./test/file1.txt\n./test/file2.txt\n./test/file3.txtMy task is to formulate shell command such that command CAT will go through all of these paths and display content of each file.\nIs it possible ?", "So I've a file called allTextFiles.txt in which it has paths of a all regular text file.eg:\n./test/file1.txt\n./test/file2.txt\n./test/file3.txtMy task is to formulate shell command such that command CAT will go through all of these paths and display content of each file.\nIs it possible ?", "Requirement : Searching a file in linux containing a string and then printing all contents of that file.Approach I used: grep -ri \"<string_name>\" | cut -d : -f1\nUsing this command I was able to determine the filename. But I want to display all content of the file. What should we add in the above command so that entire file content is visible.", "Requirement : Searching a file in linux containing a string and then printing all contents of that file.Approach I used: grep -ri \"<string_name>\" | cut -d : -f1\nUsing this command I was able to determine the filename. But I want to display all content of the file. What should we add in the above command so that entire file content is visible.", "Requirement : Searching a file in linux containing a string and then printing all contents of that file.Approach I used: grep -ri \"<string_name>\" | cut -d : -f1\nUsing this command I was able to determine the filename. But I want to display all content of the file. What should we add in the above command so that entire file content is visible.", "I am working on a script to test new-to-me hard drives in the background (so I can close the terminal window) and log the outputs. My problem is in getting badblocks to print stdout to the log file so I can monitor its multi-day progress and create properly formatted update emails.I have been able to print stdout to a log file with the following: (flags are r/w, % monitor, verbose)\nsudo badblocks -b 4096 -wsv /dev/sdx 2>&1 | tee sdx.logNormally the output would look like:\nTesting with pattern 0xaa:   2.23% done, 7:00 elapsed. (0/0/0 errors)No new-line character is used, the ^H control command backs up the cursor, and then the new updated status overwrites the previous status.Unfortunately, the control character is not processed but saved as a character in the file, producing the above output followed by 43 copies of ^H, the new updated stats, 43 copies of ^H, etc.Since the output is updated at least once per second, this produces a much larger file than necessary, and makes it difficult to retrieve the current status.While working in terminal, the solution cat sdx.log && echo\"\" prints the expected/wanted results by parsing the control characters (and then inserting a carriage return so it is not immediately printed over by the next terminal line), but using cat sdx.log > some.file or cat sdx.log | mail both still include all of the extra characters (though in email they are interpreted as spaces). This solution (or ones like it which decode or remove the control character at the time of access still produce a huge, unnecessary output file.I have worked my way through the following similar questions, but none have produced (at least that I can figure out) a solution which works in real time with the output to update the file, instead requiring that the saved log file be processed separately after the task has finished writing, or that the log file not be written until the process is done, both of which defeat the stated goal of monitoring progress.Bash - process backspace control character when redirecting output to fileHow to \"apply\" backspace characters within a text file (ideally in vim)Thank you!", "I am working on a script to test new-to-me hard drives in the background (so I can close the terminal window) and log the outputs. My problem is in getting badblocks to print stdout to the log file so I can monitor its multi-day progress and create properly formatted update emails.I have been able to print stdout to a log file with the following: (flags are r/w, % monitor, verbose)\nsudo badblocks -b 4096 -wsv /dev/sdx 2>&1 | tee sdx.logNormally the output would look like:\nTesting with pattern 0xaa:   2.23% done, 7:00 elapsed. (0/0/0 errors)No new-line character is used, the ^H control command backs up the cursor, and then the new updated status overwrites the previous status.Unfortunately, the control character is not processed but saved as a character in the file, producing the above output followed by 43 copies of ^H, the new updated stats, 43 copies of ^H, etc.Since the output is updated at least once per second, this produces a much larger file than necessary, and makes it difficult to retrieve the current status.While working in terminal, the solution cat sdx.log && echo\"\" prints the expected/wanted results by parsing the control characters (and then inserting a carriage return so it is not immediately printed over by the next terminal line), but using cat sdx.log > some.file or cat sdx.log | mail both still include all of the extra characters (though in email they are interpreted as spaces). This solution (or ones like it which decode or remove the control character at the time of access still produce a huge, unnecessary output file.I have worked my way through the following similar questions, but none have produced (at least that I can figure out) a solution which works in real time with the output to update the file, instead requiring that the saved log file be processed separately after the task has finished writing, or that the log file not be written until the process is done, both of which defeat the stated goal of monitoring progress.Bash - process backspace control character when redirecting output to fileHow to \"apply\" backspace characters within a text file (ideally in vim)Thank you!", "Is something like this:cat \"Some text here.\" > myfile.txt\nPossible? Such that the contents of myfile.txt would now be overwritten to:Some text here.\nThis doesn't work for me, but also doesn't throw any errors.Specifically interested in a cat-based solution (not vim/vi/emacs, etc.). All examples online show cat used in conjunction with file inputs, not raw text...", "Is something like this:cat \"Some text here.\" > myfile.txt\nPossible? Such that the contents of myfile.txt would now be overwritten to:Some text here.\nThis doesn't work for me, but also doesn't throw any errors.Specifically interested in a cat-based solution (not vim/vi/emacs, etc.). All examples online show cat used in conjunction with file inputs, not raw text...", "Is something like this:cat \"Some text here.\" > myfile.txt\nPossible? Such that the contents of myfile.txt would now be overwritten to:Some text here.\nThis doesn't work for me, but also doesn't throw any errors.Specifically interested in a cat-based solution (not vim/vi/emacs, etc.). All examples online show cat used in conjunction with file inputs, not raw text...", "Is something like this:cat \"Some text here.\" > myfile.txt\nPossible? Such that the contents of myfile.txt would now be overwritten to:Some text here.\nThis doesn't work for me, but also doesn't throw any errors.Specifically interested in a cat-based solution (not vim/vi/emacs, etc.). All examples online show cat used in conjunction with file inputs, not raw text...", "Is something like this:cat \"Some text here.\" > myfile.txt\nPossible? Such that the contents of myfile.txt would now be overwritten to:Some text here.\nThis doesn't work for me, but also doesn't throw any errors.Specifically interested in a cat-based solution (not vim/vi/emacs, etc.). All examples online show cat used in conjunction with file inputs, not raw text...", "Is something like this:cat \"Some text here.\" > myfile.txt\nPossible? Such that the contents of myfile.txt would now be overwritten to:Some text here.\nThis doesn't work for me, but also doesn't throw any errors.Specifically interested in a cat-based solution (not vim/vi/emacs, etc.). All examples online show cat used in conjunction with file inputs, not raw text...", "Is something like this:cat \"Some text here.\" > myfile.txt\nPossible? Such that the contents of myfile.txt would now be overwritten to:Some text here.\nThis doesn't work for me, but also doesn't throw any errors.Specifically interested in a cat-based solution (not vim/vi/emacs, etc.). All examples online show cat used in conjunction with file inputs, not raw text...", "Is something like this:cat \"Some text here.\" > myfile.txt\nPossible? Such that the contents of myfile.txt would now be overwritten to:Some text here.\nThis doesn't work for me, but also doesn't throw any errors.Specifically interested in a cat-based solution (not vim/vi/emacs, etc.). All examples online show cat used in conjunction with file inputs, not raw text...", "Is something like this:cat \"Some text here.\" > myfile.txt\nPossible? Such that the contents of myfile.txt would now be overwritten to:Some text here.\nThis doesn't work for me, but also doesn't throw any errors.Specifically interested in a cat-based solution (not vim/vi/emacs, etc.). All examples online show cat used in conjunction with file inputs, not raw text...", "Is something like this:cat \"Some text here.\" > myfile.txt\nPossible? Such that the contents of myfile.txt would now be overwritten to:Some text here.\nThis doesn't work for me, but also doesn't throw any errors.Specifically interested in a cat-based solution (not vim/vi/emacs, etc.). All examples online show cat used in conjunction with file inputs, not raw text...", "Is something like this:cat \"Some text here.\" > myfile.txt\nPossible? Such that the contents of myfile.txt would now be overwritten to:Some text here.\nThis doesn't work for me, but also doesn't throw any errors.Specifically interested in a cat-based solution (not vim/vi/emacs, etc.). All examples online show cat used in conjunction with file inputs, not raw text...", "Is something like this:cat \"Some text here.\" > myfile.txt\nPossible? Such that the contents of myfile.txt would now be overwritten to:Some text here.\nThis doesn't work for me, but also doesn't throw any errors.Specifically interested in a cat-based solution (not vim/vi/emacs, etc.). All examples online show cat used in conjunction with file inputs, not raw text...", "Is something like this:cat \"Some text here.\" > myfile.txt\nPossible? Such that the contents of myfile.txt would now be overwritten to:Some text here.\nThis doesn't work for me, but also doesn't throw any errors.Specifically interested in a cat-based solution (not vim/vi/emacs, etc.). All examples online show cat used in conjunction with file inputs, not raw text...", "I have a command to grep a file with fullpath that contain a \"TypeId: 0\", here is the commandgrep -rnw /home/username/app/data/store/0/part/.mv -e \"TypeId:\u00a00\" | awk -F \":\" '{print $1}' and here is the result:\n/home/username/app/data/store/0/part/.mv/521/1673332792072/segmentconfig.yaml /home/username/app/data/store/0/part/.mv/521/1673333077920/segmentconfig.yaml /home/username/app/data/store/0/part/.mv/521/1673333077920/segmentconfig.yaml.old /home/username/app/data/store/0/part/.mv/515/1672993850766/segmentconfig.yaml /home/username/app/data/store/0/part/.mv/515/1672993850766/segmentconfig.yaml.old /home/username/app/data/store/0/part/.mv/703/1672987004847/segmentconfig.yaml /home/username/app/data/store/0/part/.mv/703/1672987004847/segmentconfig.yaml.oldNow I confuse how to grep \"numofvertice\" from each file from that list.\nAnyone have an idea to solve this?", "I have a file that look like this:#[1]CHROM       [2]POS  [3]REF  [4]ALT  [5]GTEX-1117F_GTEX-1117F        [6]GTEX-111CU_GTEX-111CU        [7]GTEX-111FC_GTEX-111FC        [8]GTEX-111VG_GTEX-111VG        [9]GTEX-111YS_GTEX-111YS  [10]GTEX-ZZPU_GTEX-ZZPU\n\n22      20012563        T       C       0.0     0.0     0.0     0.0     0.0     0.0     0.0     0.0     0.0     0.0     0.0     0.0     0.0     0.0     0.0\n         0.0     0.0     0.0     0.0  \nI want to convert it to look like this:#[1]CHROM       [2]POS  [3]REF  [4]ALT  [5]GTEX-1117F_GTEX-1117F        [6]GTEX-111CU_GTEX-111CU        [7]GTEX-111FC_GTEX-111FC        [8]GTEX-111VG_GTEX-111VG        [9]GTEX-111YS_GTEX-111YS  [10]GTEX-ZZPU_GTEX-ZZPU\n    \n22      20012563        T       C       0    0     0     0     0     0     0     0     0     0     0      \nI basically want to convert the 0.0 or 1.0 or 2.0 to 0,1,2\nI tried to use this command but it doesn't give me the correct output:cat dosage.txt | \"%d\\n\" \"$2\" 2>/dev/null\nDoes anyone know how to do this using awk or sed command.\nThank you.", "I have a file that look like this:#[1]CHROM       [2]POS  [3]REF  [4]ALT  [5]GTEX-1117F_GTEX-1117F        [6]GTEX-111CU_GTEX-111CU        [7]GTEX-111FC_GTEX-111FC        [8]GTEX-111VG_GTEX-111VG        [9]GTEX-111YS_GTEX-111YS  [10]GTEX-ZZPU_GTEX-ZZPU\n\n22      20012563        T       C       0.0     0.0     0.0     0.0     0.0     0.0     0.0     0.0     0.0     0.0     0.0     0.0     0.0     0.0     0.0\n         0.0     0.0     0.0     0.0  \nI want to convert it to look like this:#[1]CHROM       [2]POS  [3]REF  [4]ALT  [5]GTEX-1117F_GTEX-1117F        [6]GTEX-111CU_GTEX-111CU        [7]GTEX-111FC_GTEX-111FC        [8]GTEX-111VG_GTEX-111VG        [9]GTEX-111YS_GTEX-111YS  [10]GTEX-ZZPU_GTEX-ZZPU\n    \n22      20012563        T       C       0    0     0     0     0     0     0     0     0     0     0      \nI basically want to convert the 0.0 or 1.0 or 2.0 to 0,1,2\nI tried to use this command but it doesn't give me the correct output:cat dosage.txt | \"%d\\n\" \"$2\" 2>/dev/null\nDoes anyone know how to do this using awk or sed command.\nThank you.", "Is it possible to write a one-liner to cat a file only if it is a text file, and not if it is a binary?Something like:echo \"/root/mydir/foo\" | <if file is ASCII then cat \"/root/mydir/foo\"; else echo \"file is a binary\">\n", "Is it possible to write a one-liner to cat a file only if it is a text file, and not if it is a binary?Something like:echo \"/root/mydir/foo\" | <if file is ASCII then cat \"/root/mydir/foo\"; else echo \"file is a binary\">\n", "Is it possible to write a one-liner to cat a file only if it is a text file, and not if it is a binary?Something like:echo \"/root/mydir/foo\" | <if file is ASCII then cat \"/root/mydir/foo\"; else echo \"file is a binary\">\n", "I have a script which contains the code block:cat << EOF > new_script.sh\n...\necho \"$(pwd)\" >> log.txt\n...\nEOF\nThe script new_script.sh is set to run at a later time. Bash recognizes the $(pwd) within the script and evaluates it before it looks at the entire EOF block, so the pwd of the current directory is output instead of the pwd of new_script.sh when it is run. Why is this the case (what logic does bash use to know to evaluate $(command)) and what is the best solution to this?", "I have a file s.csva,b+ -.,c \naa,bb ().,c._c\nI want to remove all special characters from 2nd column (file separated by comma)cat s.csv | tr -dc '[:alnum:]\\n\\r' | tr '[:upper:]' '[:lower:]'\nThe above code also removes special characters from 3rd column as well.awk -F, '{print $2}' s.csv | tr -dc '[:alnum:]\\n\\r' | tr '[:upper:]' '[:lower:]'\nThis code only print 2nd column.Any idea how can I remove special char from 2nd column and price allRequired output should bea,b,c \naa,bb,c._c \n", "I have a file s.csva,b+ -.,c \naa,bb ().,c._c\nI want to remove all special characters from 2nd column (file separated by comma)cat s.csv | tr -dc '[:alnum:]\\n\\r' | tr '[:upper:]' '[:lower:]'\nThe above code also removes special characters from 3rd column as well.awk -F, '{print $2}' s.csv | tr -dc '[:alnum:]\\n\\r' | tr '[:upper:]' '[:lower:]'\nThis code only print 2nd column.Any idea how can I remove special char from 2nd column and price allRequired output should bea,b,c \naa,bb,c._c \n", "I have a file s.csva,b+ -.,c \naa,bb ().,c._c\nI want to remove all special characters from 2nd column (file separated by comma)cat s.csv | tr -dc '[:alnum:]\\n\\r' | tr '[:upper:]' '[:lower:]'\nThe above code also removes special characters from 3rd column as well.awk -F, '{print $2}' s.csv | tr -dc '[:alnum:]\\n\\r' | tr '[:upper:]' '[:lower:]'\nThis code only print 2nd column.Any idea how can I remove special char from 2nd column and price allRequired output should bea,b,c \naa,bb,c._c \n"], "chosen": ["\nYou can use a loop; something like\nwhile IFS= read -r file; do\n    cat \"$file\"\ndone < allTextFiles.txt\n\nSee Bash FAQ 001 for more discussion on reading a file a line at a time (Much of the content applies to all shells, not just bash).\nIf you are using bash:\nreadarray -t files < allTextFiles.txt\ncat \"${files[@]}\"\n\nis an alternative that avoids the explicit loop.\n", "\nUsing xargs with the allTextFiles.txt\nYou can use the command cat to list the content and xargs (Xargs command documentation) to process every line of the file. For example:\ncat allTextFiles.txt | xargs cat\nkk #./test/file1.txt\njj #./test/file2.txt\nyy #./test/file3.txt\n\nUsing find command without allTextFiles.txt\nYou can use the command find (find command documentation) to go trough the main folder and search recursively. Once you find a file, to use the cat command.\nYou achieve the purpose of showing all the content of txt files recursively with only one command.\nfind . -type f -name \"*.txt\" -exec cat {} \\;\nkk #./test/file1.txt\njj #./test/file2.txt\nyy #./test/file3.txt\n\nWhere the . means current directory. -type f only filters files. -name \"*.txt\" filters only files ending with .txt extension and the -exec part is where you process all the files found.\nDoes it cover your need?\n", "\nYou can get the file name directly from grep, without having to manipulate its output by using the --files-with-matches option, or its short hand -l.\nYour command would look like:\ngrep -l \"<string_name>\"\nWhich you can then use with other tools, ie:\ncat $(grep -l \"SEARCH_PATTERN\" [FILE...])\n", "\nYou were close, you can pipe the extracted filename to cat to display the file's contents:\ngrep \"string-to-search\" /path/to/directory/* | cut -d: -f1 | uniq | xargs cat\nThis command will search for the string \"string-to-search\" in all files in the /path/to/directory/ directory and print the contents of the files that contain the string.\nThe cut command is used to extract the filename from the output of grep, and the uniq command removes duplicate filenames. The xargs command is used to pass the list of filenames to the cat command, which prints the contents of each file.\n", "\nUsing any awk:\nawk 'NR==FNR && /regexp/{ ARGV[ARGC++]=FILENAME; nextfile } NR>FNR' file\n\nFor example:\n$ seq 5 > file\n\n$ awk 'NR==FNR && /3/{ ARGV[ARGC++]=FILENAME; nextfile } NR>FNR' file\n1\n2\n3\n4\n5\n\n$ awk 'NR==FNR && /7/{ ARGV[ARGC++]=FILENAME; nextfile } NR>FNR' file\n$\n\nIf your version of awk doesn't support nextfile (many do these days) it'll just run a little slower than if it does.\n", "\nThe main place I've run into this in real life is trying to process man pages.  In the past, I've always used a simple script that post processes by stripping out the backspace appropriately.  One could probably do this sort of thing in 80 character of perl, but here's an approach that handles backspace and cr/nl fairly well.  I've not tested extensively, but it produces good output for simple cases.  eg:\n$ printf 'xxx\\rabclx\\bo\\rhel\\nworld\\n' | ./a.out output\nhello\nworld\n$ cat output\nhello\nworld\n$ xxd output\n00000000: 6865 6c6c 6f0a 776f 726c 640a            hello.world.\n\nIf your output starts to have a lot of csi sequences, this approach just isn't worth the trouble.  cat will produce nice human consumable output for those cases.\n#include <assert.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nFILE * xfopen(const char *path, const char *mode);\noff_t xftello(FILE *stream, const char *name);\nvoid xfseeko(FILE *stream, off_t offset, int whence, const char *name);\n\nint\nmain(int argc, char **argv)\n{\n        const char *mode = \"w\";\n        char *name = strchr(argv[0], '/');\n        off_t last = 0, max = 0, curr = 0;\n        name = name ? name + 1 : argv[0];\n        if( argc > 1 && ! strcmp(argv[1], \"-a\")) {\n                argv += 1;\n                argc -= 1;\n                mode = \"a\";\n        }\n        if( argc > 1 && ! strcmp(argv[1], \"-h\")) {\n                printf(\"usage: %s [-a] [-h] file [ file ...]\\n\", name);\n                return EXIT_SUCCESS;\n        }\n        if( argc < 2 ) {\n                fprintf(stderr, \"Missing output file.  -h for usage\\n\");\n                return EXIT_FAILURE;\n        }\n        assert( argc > 1 );\n        argc -= 1;\n        argv += 1;\n\n        FILE *ofp[argc];\n        for( int i = 0; i < argc; i++ ) {\n                ofp[i] = xfopen(argv[i], mode);\n        }\n        int c;\n        while( ( c = fgetc(stdin) ) != EOF ) {\n                fputc(c, stdout);\n                for( int i = 0; i < argc; i++ ) {\n                        if( c == '\\b' ) {\n                                xfseeko(ofp[i], -1, SEEK_CUR, argv[i]);\n                        } else if( isprint(c) ) {\n                                fputc(c, ofp[i]);\n                        } else if( c == '\\n' ) {\n                                xfseeko(ofp[i], max, SEEK_SET, argv[i]);\n                                fputc(c, ofp[i]);\n                                last = curr + 1;\n                        } else if( c == '\\r' ) {\n                                xfseeko(ofp[i], last, SEEK_SET, argv[i]);\n                        }\n                }\n                curr = xftello(ofp[0], argv[0]);\n                if( curr > max ) {\n                        max = curr;\n                }\n        }\n        return 0;\n}\n\noff_t\nxftello(FILE *stream, const char *name)\n{\n        off_t r = ftello(stream);\n        if( r == -1 ) {\n                perror(name);\n                exit(EXIT_FAILURE);\n        }\n        return r;\n}\n\nvoid\nxfseeko(FILE *stream, off_t offset, int whence, const char *name)\n{\n        if( fseeko(stream, offset, whence) ) {\n                perror(name);\n                exit(EXIT_FAILURE);\n        }\n}\n\nFILE *\nxfopen(const char *path, const char *mode)\n{\n        FILE *fp = fopen(path, mode);\n        if( fp == NULL ) {\n                perror(path);\n                exit(EXIT_FAILURE);\n        }\n        return fp;\n}\n\n", "\nYou can delete the ^H\nsudo badblocks -b 4096 -wsv /dev/sdx 2>&1 | tr -d '\\b' | tee sdx.log\n\n", "\nSounds like you're looking for a Here document\ncat > outfile.txt <<EOF\n>some text\n>to save\n>EOF\n\n", "\nHere's another way -\ncat > outfile.txt\n>Enter text\n>to save press ctrl-d\n\n", "\nThat's what echo does:\necho \"Some text here.\" > myfile.txt\n\n", "\nFor text file:\ncat > output.txt <<EOF\nsome text\nsome lines\nEOF\n\nFor PHP file:\ncat > test.php <<PHP\n<?php\necho \"Test\";\necho \\$var;\n?>\nPHP\n\n", "\nI use the following code to write raw text to files, to update my CPU-settings. Hope this helps out!\nScript: \n#!/bin/sh\n\ncat > /sys/devices/system/cpu/cpu0/cpufreq/scaling_governor <<EOF\nperformance\nEOF\n\ncat > /sys/devices/system/cpu/cpu1/cpufreq/scaling_governor <<EOF\nperformance\nEOF\n\nThis writes the text \"performance\" to the two files mentioned in the script above. This example overwrite old data in files.\nThis code is saved as a file (cpu_update.sh) and to make it executable run: \nchmod +x cpu_update.sh\n\nAfter that, you can run the script with:\n./cpu_update.sh\n\nIF you do not want to overwrite the old data in the file, switch out\ncat > /sys/devices/system/cpu/cpu1/cpufreq/scaling_governor <<EOF\n\nwith\ncat >> /sys/devices/system/cpu/cpu1/cpufreq/scaling_governor <<EOF\n\nThis will append your text to the end of the file without removing what other data already is in the file.\n", "\ncat > filename.txt\n\nenter the text\nuntil EOF\nfor save the text use : ctrl+d\nif you want to read that .txt file use \ncat filename.txt\n\nand one thing .txt is not mandatory, its for your reference.\n", "\nYou can do it like this too:\nuser@host: $ cat<<EOF > file.txt\n$ > 1 line\n$ > other line\n$ > n line\n$ > EOF\nuser@host: $ _\n\nI believe there is a lot of ways to use it.\n", "\nWrite multi-line text with environment variables using echo:\necho -e \"\nHome Directory: $HOME \\n\nhello world 1 \\n\nhello world 2 \\n\nline n... \\n\n\" > file.txt \n\n", "\nAnother way to write text to file using cat would be something like this\ncat >file.txt <<< Write something here\n\n", "\nThe Solution to your problem is : \n\necho  \" Some Text Goes Here \" > filename.txt \n\nBut you can use cat command if you want to redirect the output of a file to some other file or if you want to append the output of a file to another file :\ncat filename > newfile  -- To redirect output of filename to newfile\ncat filename >> newfile -- To append the output of filename to newfile\n", "\nsimply pipeline echo with cat \nFor example\necho write something to file.txt | cat > file.txt\n\n", "\ncat can also be used following a | to write to a file, i.e. pipe feeds cat a stream of data \n", "\nFor my Jenkins on MacOS 11.4\n{\n   echo 'line 1' $var1\n   echo 'line 2'\n   echo 'result' $var5\n\n} > ${destination_file}\n\nI had tried many times by cat syntax, ex: cat > ${dest_file} <<EOF ... EOF, and got error syntax error: unexpected end of file. So, I use echo syntax to output multi-lines text to a file.\nReferences:\n\nHow to append multiple lines to a file\ngithub.com/koalaman/shellcheck/wiki/SC2129\n\n", "\nLike this (GNU grep):\n<STDIN> | grep -oP '\\b\\S+\\.yaml' | xargs cat\n\nOr with ack:\ncd /home/username/app/data/store/0/part/.mv\nack -wl  -e \"TypeId:\u00a00\" | xargs cat\n\nFrom ack --help:\n\n-l, --files-with-matches\nOnly print filenames containing matches\n\n", "\n\nhow to convert floating number to integer in linux(...)using awk\n\nYou might use int function of GNU AWK, consider following simple example, let file.csv content be\nname,x,y,z\nA,1.0,2.1,3.5\nB,4.7,5.9,7.0\n\nthen\nawk 'BEGIN{FS=OFS=\",\"}NR==1{print;next}{for(i=2;i<=NF;i+=1){$i=int($i)};print}' file.csv\n\ngives output\nname,x,y,z\nA,1,2,3\nB,4,5,7\n\nExplanation: I inform GNU AWK that , is both field separator (FS) and output field separator (OFS). I print first row as-is and instruct GNU AWK to go to next line, i.e. do nothing else for that line. For all but first line I use for loop to apply int to fields from 2nd to last, after that is done I print such altered line.\n(tested in GNU Awk 5.0.1)\n", "\nThis might work for you (GNU sed):\nsed -E ':a;s/((\\s|^)[0-9]+)\\.[0-9]+(\\s|$)/\\1\\3/g;ta' file\n\nPresuming you want to remove the period and trailing digits from all floating point numbers (where n.n represents a minimum example of such a number).\nMatch a space or start-of-line, followed by one or more digits, followed by a period, followed by one or more digits, followed by a space or end-of-line and remove the period and the digits following it. Do this for all such numbers through out the file (globally).\nN.B. The substitution must be performed twice (hence the loop) because the trailing space of one floating point number may overlap with the leading space of another. The ta command is enacted when the previous substitution is true and causes sed to branch to the a label at the start of the sed cycle.\n", "\nfilename=$(echo \"/root/mydir/foo\")\nif file \"$filename\" | grep -q \"ASCII text\"; then cat \"$filename\"; else echo \"file is a binary\"; fi\n\nBut why does it have to be on one line? It's much more readable if you spread it out:\nfilename=$(echo \"/root/mydir/foo\")\nif file \"$filename\" | grep -q \"ASCII text\"\nthen cat \"$filename\"\nelse echo \"file is a binary\"\nfi\n\n", "\nWith $filename being your file,\ngrep -P '[\\x80-\\xFF]' \"$filename\" && echo \"file is a binary\" || cat \"$filename\"\n\nwill be tantamount to cat if and only if $filename does not contain any non-ASCII character.\nNote that GNU grep is required, since the one-liner requires Perl-style pattern matching capabilities (-P).\n", "\nYou can use the output of the file command with the --mime and -b option.\n$ file -b --mime filename.bin \napplication/octet-stream; charset=binary\n\nThe -b option suppresses the filename from being printed in the output so you don't have to worry about false matching the filename and --mime will give you the character set.\nYou can use grep to test for the occurrence of charset=binary\n$ file -b --mime filename.bin | grep -q \"charset=binary\"\n\nYou can then use the exit status of grep and the &&, || operators to cat the file or echo a message.\n$ echo filename | xargs -I% bash -c 'file -b --mime % | grep -q \"charset=binary\" || cat % && echo \"binary file\"'\n\nFinally xargs is used to plug in the filename from the previous command echo filename and replace the symbol % in our binary testing command. \n", "\nUnless you put single quotes around the EOF marker, the contents of the here-doc are treated like a double-quoted string, so all variables and command substitutions are expanded immediately.\nTo leave them as literals, use\ncat << 'EOF' > new_script.sh\n...\necho \"$(pwd)\" >> log.txt\n...\nEOF\n\n", "\nYou can use the [:alpha:] character class using awk, here for second field and remove with gsub() function the characteres that aren't alpha:\nawk 'BEGIN{OFS=FS=\",\"} {gsub(/[^[:alpha:]]+/, \"\", $2)} 1' file\na,b,c\naa,bb,c._c\n\n\nif you need other set of characters, you can see this answer of Ed Morton:\nhttps://stackoverflow.com/questions/56481541/how-can-you-tell-which-characters-are-in-which-character-classes\nand see \"which characters are in which character classes\"\n\n", "\nRemove all (from second field)\n\ncharacters that are not upper case letters [^A-Z\nor lower case letters a-z\nor digits 0-9]\nfrom second field $2\nfields are with \",\" separated -F ','\nkeep the separator in output OFS=FS\n\n\n$ awk -F ',' 'BEGIN{OFS=FS}{gsub(/[^A-Za-z0-9]/,\"\",$2); print}' s.csv\n\n\n# test\n$ awk -F ',' 'BEGIN{OFS=FS}{gsub(/[^A-Za-z0-9]/,\"\",$2); print}' <<<'aa,bb ().,c._c'\naa,bb,c._c\n\nAs @L\u00e9a Gris mentioned below\n\nDon't forget to set the locale to C or [^A-Za-z0-9] is gonna be\ninterpreted unexpectedly in non-western European alphabets. Prepend\nawk invocation with\nLC_ALL=C\n\n", "\nUse this Perl one-liner:\nperl -F',' -lane '$F[1] =~ s{[\\W_]+}{}g; @F = map { lc } @F; print join \",\", @F; ' in_file > out_file\n\nThe Perl one-liner uses these command line flags:\n-e : Tells Perl to look for code in-line, instead of in a file.\n-n : Loop over the input one line at a time, assigning it to $_ by default.\n-l : Strip the input line separator (\"\\n\" on *NIX by default) before executing the code in-line, and append it when printing.\n-a : Split $_ into array @F on whitespace or on the regex specified in -F option.\n-F',' : Split into @F on comma, rather than on whitespace.\ns{[\\W_]+}{} : Replace 1 or more occurrences of \\W (non-word character) or underscore with nothing.\nThe regex uses these modifiers:\n/g : Match the pattern repeatedly.\nSEE ALSO:\nperldoc perlrun: how to execute the Perl interpreter: command line switches\nperldoc perlre: Perl regular expressions (regexes)\nperldoc perlre: Perl regular expressions (regexes): Quantifiers; Character Classes and other Special Escapes; Assertions; Capture groups\nperldoc perlrequick: Perl regular expressions quick start\n"], "rejected": ["\ntry this will work\ncat Folder/*.txt\n", "\ntry this will work\ncat Folder/*.txt\n", "\nUsing find to search for files matching REGEXP\nfind . -type f -exec grep -q REGEXP {} \\; -exec  cat {} \\;\n\n", "\nUsing find to search for files matching REGEXP\nfind . -type f -exec grep -q REGEXP {} \\; -exec  cat {} \\;\n\n", "\nUsing find to search for files matching REGEXP\nfind . -type f -exec grep -q REGEXP {} \\; -exec  cat {} \\;\n\n", "\nI have found col -b and colcrt usefull, but none worked perfect for me. These will apply control characters, not just drop them:\nsudo badblocks -b 4096 -wsv /dev/sdx 2>&1 | col -b | tee sdx.log\n\n", "\nI have found col -b and colcrt usefull, but none worked perfect for me. These will apply control characters, not just drop them:\nsudo badblocks -b 4096 -wsv /dev/sdx 2>&1 | col -b | tee sdx.log\n\n", "\nSince nobody else answered the original question.  Yes. cat can be used to write text to a file without a here doc.\ncat - >file.txt\nThis is the world's worst\nmultiline text editor.\n^d\n\n", "\nSince nobody else answered the original question.  Yes. cat can be used to write text to a file without a here doc.\ncat - >file.txt\nThis is the world's worst\nmultiline text editor.\n^d\n\n", "\nSince nobody else answered the original question.  Yes. cat can be used to write text to a file without a here doc.\ncat - >file.txt\nThis is the world's worst\nmultiline text editor.\n^d\n\n", "\nSince nobody else answered the original question.  Yes. cat can be used to write text to a file without a here doc.\ncat - >file.txt\nThis is the world's worst\nmultiline text editor.\n^d\n\n", "\nSince nobody else answered the original question.  Yes. cat can be used to write text to a file without a here doc.\ncat - >file.txt\nThis is the world's worst\nmultiline text editor.\n^d\n\n", "\nSince nobody else answered the original question.  Yes. cat can be used to write text to a file without a here doc.\ncat - >file.txt\nThis is the world's worst\nmultiline text editor.\n^d\n\n", "\nSince nobody else answered the original question.  Yes. cat can be used to write text to a file without a here doc.\ncat - >file.txt\nThis is the world's worst\nmultiline text editor.\n^d\n\n", "\nSince nobody else answered the original question.  Yes. cat can be used to write text to a file without a here doc.\ncat - >file.txt\nThis is the world's worst\nmultiline text editor.\n^d\n\n", "\nSince nobody else answered the original question.  Yes. cat can be used to write text to a file without a here doc.\ncat - >file.txt\nThis is the world's worst\nmultiline text editor.\n^d\n\n", "\nSince nobody else answered the original question.  Yes. cat can be used to write text to a file without a here doc.\ncat - >file.txt\nThis is the world's worst\nmultiline text editor.\n^d\n\n", "\nSince nobody else answered the original question.  Yes. cat can be used to write text to a file without a here doc.\ncat - >file.txt\nThis is the world's worst\nmultiline text editor.\n^d\n\n", "\nSince nobody else answered the original question.  Yes. cat can be used to write text to a file without a here doc.\ncat - >file.txt\nThis is the world's worst\nmultiline text editor.\n^d\n\n", "\nSince nobody else answered the original question.  Yes. cat can be used to write text to a file without a here doc.\ncat - >file.txt\nThis is the world's worst\nmultiline text editor.\n^d\n\n", "\nYou could try this:\ngrep -rnw /home/username/app/data/store/0/part/.mv -e \"TypeId: 0\" | awk -F \":\" '{print $1}'|xargs -I{} grep \"numofvertice\" {}\n\n", "\nMaybe this will help.  This regex saves the whole part in a variable, and removes the rest.  regex can often be fooled by unexpected input, so make sure that you test this against all forms of input data.  as I did (partially) for this example.\necho 1234.5  345 a.2 g43.3  546.0 234. hi | sed 's/\\b\\([0-9]\\+\\)\\.[0-9]\\+/\\1/g'\n\noutputs\n1234 345 a.2 g43.3 546 234. hi\n\nIt is important to note, that this was based on gnu sed (standard on linux), so it should not be assumed to work on systems that use an older sed (like on freebsd).\n", "\nMaybe this will help.  This regex saves the whole part in a variable, and removes the rest.  regex can often be fooled by unexpected input, so make sure that you test this against all forms of input data.  as I did (partially) for this example.\necho 1234.5  345 a.2 g43.3  546.0 234. hi | sed 's/\\b\\([0-9]\\+\\)\\.[0-9]\\+/\\1/g'\n\noutputs\n1234 345 a.2 g43.3 546 234. hi\n\nIt is important to note, that this was based on gnu sed (standard on linux), so it should not be assumed to work on systems that use an older sed (like on freebsd).\n", "\nNot exactly what the op is asking, but strings is dead simple:\n> strings --help\nUsage: strings [option(s)] [file(s)]\nDisplay printable strings in [file(s)] (stdin by default)\n\nstrings /root/mydir/foo\n\n", "\nNot exactly what the op is asking, but strings is dead simple:\n> strings --help\nUsage: strings [option(s)] [file(s)]\nDisplay printable strings in [file(s)] (stdin by default)\n\nstrings /root/mydir/foo\n\n", "\nNot exactly what the op is asking, but strings is dead simple:\n> strings --help\nUsage: strings [option(s)] [file(s)]\nDisplay printable strings in [file(s)] (stdin by default)\n\nstrings /root/mydir/foo\n\n", "\nBy adding an escape $, \\$ , you can solve this issue.\ncat << EOF > new_script.sh\n...\necho \"\\$(pwd)\" >> log.txt\n...\nEOF\n\n", "\nYou don't have to alter locale just to do it - by using octals instead of letters, the regex engine respects them as ASCII instead of being overly clever - i even intentionally set it to Belgian French to illustrate :\nCODE\necho 'a,b+ -.,c \naa,bb ().,c._c' | {m,g}awk '\n\ngsub(\"[^\\\\060-\\\\071\\\\101-\\\\132\\\\141-\\\\172]+\",\"\",$(!_+!_))^_' \\\n                                              OFS=',' FS=','\n\nOUTPUT\na,b,c \naa,bb,c._c\n\nSHOWCASE LOCALE=C isn't needed\n LANG=\"fr_BE.UTF8\" gawk -e '\n BEGIN { for(_=8*4;_<8^4;_++) { printf(\"%c\",_) } } ' | \n \n LANG=\"fr_BE.UTF8\" gawk -p- -e '\n gsub(\"[^\\\\060-\\\\071\\\\101-\\\\132\\\\141-\\\\172]+\",\"\",$-_)^_' OFS=',' FS=','\n\n\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\n0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\n\n# profile gawk, cr'e'e Sun May 29 05:58:26 2022\n\n# R`egle(s)\n\n 1  (gsub(\"[^\\\\060-\\\\071\\\\101-\\\\132\\\\141-\\\\172]+\", \"\", $-_)) ^ _ { # 1\n 1      print\n}\n\n", "\nYou don't have to alter locale just to do it - by using octals instead of letters, the regex engine respects them as ASCII instead of being overly clever - i even intentionally set it to Belgian French to illustrate :\nCODE\necho 'a,b+ -.,c \naa,bb ().,c._c' | {m,g}awk '\n\ngsub(\"[^\\\\060-\\\\071\\\\101-\\\\132\\\\141-\\\\172]+\",\"\",$(!_+!_))^_' \\\n                                              OFS=',' FS=','\n\nOUTPUT\na,b,c \naa,bb,c._c\n\nSHOWCASE LOCALE=C isn't needed\n LANG=\"fr_BE.UTF8\" gawk -e '\n BEGIN { for(_=8*4;_<8^4;_++) { printf(\"%c\",_) } } ' | \n \n LANG=\"fr_BE.UTF8\" gawk -p- -e '\n gsub(\"[^\\\\060-\\\\071\\\\101-\\\\132\\\\141-\\\\172]+\",\"\",$-_)^_' OFS=',' FS=','\n\n\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\n0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\n\n# profile gawk, cr'e'e Sun May 29 05:58:26 2022\n\n# R`egle(s)\n\n 1  (gsub(\"[^\\\\060-\\\\071\\\\101-\\\\132\\\\141-\\\\172]+\", \"\", $-_)) ^ _ { # 1\n 1      print\n}\n\n", "\nYou don't have to alter locale just to do it - by using octals instead of letters, the regex engine respects them as ASCII instead of being overly clever - i even intentionally set it to Belgian French to illustrate :\nCODE\necho 'a,b+ -.,c \naa,bb ().,c._c' | {m,g}awk '\n\ngsub(\"[^\\\\060-\\\\071\\\\101-\\\\132\\\\141-\\\\172]+\",\"\",$(!_+!_))^_' \\\n                                              OFS=',' FS=','\n\nOUTPUT\na,b,c \naa,bb,c._c\n\nSHOWCASE LOCALE=C isn't needed\n LANG=\"fr_BE.UTF8\" gawk -e '\n BEGIN { for(_=8*4;_<8^4;_++) { printf(\"%c\",_) } } ' | \n \n LANG=\"fr_BE.UTF8\" gawk -p- -e '\n gsub(\"[^\\\\060-\\\\071\\\\101-\\\\132\\\\141-\\\\172]+\",\"\",$-_)^_' OFS=',' FS=','\n\n\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\n0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\n\n# profile gawk, cr'e'e Sun May 29 05:58:26 2022\n\n# R`egle(s)\n\n 1  (gsub(\"[^\\\\060-\\\\071\\\\101-\\\\132\\\\141-\\\\172]+\", \"\", $-_)) ^ _ { # 1\n 1      print\n}\n\n"]}