{"prompt": ["Currently when I do history I get:  996  05/13/14 10:37 ls-l\n  997  05/13/14 10:37 ls -l\n  998  05/13/14 10:37 chmod 700 hosts.txt\n  999  05/13/14 10:37 tail -5 .bash_history\n 1000  05/13/14 10:37 tail -10 .bash_history\n 1001  05/13/14 10:38 hisotry\nIs it possible to change the mechanism to that when it becomes:  996  username1 05/13/14 10:37 ls-l\n  997  username1 05/13/14 10:37 ls -l\n  998  username2 05/13/14 10:37 chmod 700 hosts.txt\n  999  username3 05/13/14 10:37 tail -5 .bash_history\n 1000  username1 05/13/14 10:37 tail -10 .bash_history\n 1001  username4 05/13/14 10:38 hisotry\nI tried editing the PROMPT_COMMAND but was unable to get the result I want.The scenario that I am dealing with is several users sudo to another user and each user runs several commands. What I need is track which user ran which command.", "Currently when I do history I get:  996  05/13/14 10:37 ls-l\n  997  05/13/14 10:37 ls -l\n  998  05/13/14 10:37 chmod 700 hosts.txt\n  999  05/13/14 10:37 tail -5 .bash_history\n 1000  05/13/14 10:37 tail -10 .bash_history\n 1001  05/13/14 10:38 hisotry\nIs it possible to change the mechanism to that when it becomes:  996  username1 05/13/14 10:37 ls-l\n  997  username1 05/13/14 10:37 ls -l\n  998  username2 05/13/14 10:37 chmod 700 hosts.txt\n  999  username3 05/13/14 10:37 tail -5 .bash_history\n 1000  username1 05/13/14 10:37 tail -10 .bash_history\n 1001  username4 05/13/14 10:38 hisotry\nI tried editing the PROMPT_COMMAND but was unable to get the result I want.The scenario that I am dealing with is several users sudo to another user and each user runs several commands. What I need is track which user ran which command.", "Currently when I do history I get:  996  05/13/14 10:37 ls-l\n  997  05/13/14 10:37 ls -l\n  998  05/13/14 10:37 chmod 700 hosts.txt\n  999  05/13/14 10:37 tail -5 .bash_history\n 1000  05/13/14 10:37 tail -10 .bash_history\n 1001  05/13/14 10:38 hisotry\nIs it possible to change the mechanism to that when it becomes:  996  username1 05/13/14 10:37 ls-l\n  997  username1 05/13/14 10:37 ls -l\n  998  username2 05/13/14 10:37 chmod 700 hosts.txt\n  999  username3 05/13/14 10:37 tail -5 .bash_history\n 1000  username1 05/13/14 10:37 tail -10 .bash_history\n 1001  username4 05/13/14 10:38 hisotry\nI tried editing the PROMPT_COMMAND but was unable to get the result I want.The scenario that I am dealing with is several users sudo to another user and each user runs several commands. What I need is track which user ran which command.", "I have found some close answers, but nothing on the topic. In short, how do I redirect the output of Linux History command to a Python variable?  The normal history file does not have all the activity, and I do not have permission to access the file directly.  Here is what I have so far, it appears that the variable does not populate:import subprocess\na= subprocess.check_output(\"history | cut -c 8-\", shell=True)\n\nfor line in a:\n        print line\n", "I have to implement the hist command includng !k and !!The 2 functions:void addInHistory(char **history,char *command,int *list_size,int history_capacity)\n{\nint index=*(list_size);\n  if(command[0]!='\\n') \n  {\n     if(index==history_capacity-1)\n     {\n        printf(\"History is full.Deleting commands.\");\n     }\n     else \n     {\n         char current_command[COMMAND_SIZE];\n         strcpy(current_command,command);\n         history[index++]=current_command;       \n     }\n  }\n}\n void printHistory(char **history,int size) \n{\nint i;\n  for(int i=0;i<=size;i++)\n  {\n    printf(\"%d. %s\\n\",i+1,history[i]);\n  }\n}\nAny help would be appreciated.", "I have to implement the hist command includng !k and !!The 2 functions:void addInHistory(char **history,char *command,int *list_size,int history_capacity)\n{\nint index=*(list_size);\n  if(command[0]!='\\n') \n  {\n     if(index==history_capacity-1)\n     {\n        printf(\"History is full.Deleting commands.\");\n     }\n     else \n     {\n         char current_command[COMMAND_SIZE];\n         strcpy(current_command,command);\n         history[index++]=current_command;       \n     }\n  }\n}\n void printHistory(char **history,int size) \n{\nint i;\n  for(int i=0;i<=size;i++)\n  {\n    printf(\"%d. %s\\n\",i+1,history[i]);\n  }\n}\nAny help would be appreciated."], "chosen": ["\nHistory reports only commands executed by current logged in user.\nYou may use su -c history username to check history for other users on your system.\n", "\nYou can abuse the HISTTIMEFORMAT variable to accomplish this. Add the following to your .bashrc:\nHISTTIMEFORMAT=\"$USER %m/%d/%Y %H:%M \"\n\n", "\nyou can run:\nhistory | sed \"s/  / $UID /\"\n\nand if you want to make a command for that:\nalias histuid='history | sed \"s/  / $UID /\"'\n\nthough I'm not sure why you'd want such a thing, as the history command is a shell builtin that can only return the history of the current shell session for the current shell's user.\n", "\nIt seems at least a part of the problem is that using shell=True with subprocess in linux starts a new /bin/sh process with the command as an argument.\nAlso, the history command works when in interactive mode (when the shell is started with a -i flag).\nThe following command should work:\nimport subprocess\na= subprocess.check_output('echo \"history\" | /bin/bash -i', shell=True)\n\nfor line in a:\n        print line\n\n", "\nFor a C solution\n char current_command[COMMAND_SIZE];\n strcpy(current_command,command);\n history[index++]=current_command;       \n\nshould be\nhistory[index++]= strdup(command);       \n\nBe sure to free it when you are done with it.\n", "\nHere is a link to a good example of linked lists http://www.thegeekstuff.com/2012/08/c-linked-list-example/ \nyou would just replace int val with your char*.\nbut your method will work if you fix one line of code \nyour bug is right here\n     char current_command[COMMAND_SIZE];\n\ncurrent_command goes out of scope after the else statement is over and thus gets deleted. instead do this\n     char * current_command = new char[COMMAND_SIZE];\n\nthen your code should work\n"], "rejected": ["\nI found a simpler solution that worked for me. In your /etc/bash.bashrc on Ubuntu 18.04, add the following to the end or modify if it exists.\n[Solution]\nexport HISTTIMEFORMAT=\"`whoami` %m/%d/%Y %H:%M \"\n\n[Result]\n1987  {omitted} 07/13/2018 - 20:10:56 history | tail -19\n\nNote that previous entries will be updated. {omitted} shows the username. whoami in single quotes used in a bash command script.\n", "\nI found a simpler solution that worked for me. In your /etc/bash.bashrc on Ubuntu 18.04, add the following to the end or modify if it exists.\n[Solution]\nexport HISTTIMEFORMAT=\"`whoami` %m/%d/%Y %H:%M \"\n\n[Result]\n1987  {omitted} 07/13/2018 - 20:10:56 history | tail -19\n\nNote that previous entries will be updated. {omitted} shows the username. whoami in single quotes used in a bash command script.\n", "\nI found a simpler solution that worked for me. In your /etc/bash.bashrc on Ubuntu 18.04, add the following to the end or modify if it exists.\n[Solution]\nexport HISTTIMEFORMAT=\"`whoami` %m/%d/%Y %H:%M \"\n\n[Result]\n1987  {omitted} 07/13/2018 - 20:10:56 history | tail -19\n\nNote that previous entries will be updated. {omitted} shows the username. whoami in single quotes used in a bash command script.\n", "\nPlease check this out.\nimport subprocess\ntry:\n    cmd = 'bash -i -c \"history -r;history | cut -c 8-\"'\n    a= subprocess.check_output(cmd, shell=True,stderr= subprocess.STDOUT)\n\n    for line in a.splitlines():\n        print line\nexcept subprocess.CalledProcessError as e:\n    print \"Error while executing command\"\n\nOutput:\n[root@dsp-centos ~]# python a.py \nvi get_stat.py\npython test.py\nvi get_stat.py\npython test.py\nvi get_stat.py\n[root@dsp-centos ~]#\n\n", "\nYou might want to use (like bash does) the GNU readline library. You'll then use the readline function to read interactively a line from the terminal and add_history to add a line to the history list (and you could also customize the autocompletion)\n", "\nYou might want to use (like bash does) the GNU readline library. You'll then use the readline function to read interactively a line from the terminal and add_history to add a line to the history list (and you could also customize the autocompletion)\n"]}