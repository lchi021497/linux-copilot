{"prompt": ["I'm trying to implement the FUSE filesystem.  I am receiving this error:\ncannot access MountDir: Transport endpoint is not connected\nThis the relevant parts of the program. There are two directories, MirrorDir and MountDir, that exist withing the same directory as all of the code. I am calling the program like this:./myFS -o nonempty -o allow_other MirrorDir MountDir\nCan anyone see what I am doing wrong?static struct fuse_operations xmp_oper = {\n    .getattr    = xmp_getattr,\n    .readdir    = xmp_readdir,\n    .open       = xmp_open,\n    .read       = xmp_read,\n};\n\nint main(int argc, char *argv[]) {\n    int fuse_stat;\n    char* mirrorDir;\n\n    mirrorDir = malloc(sizeof(strlen(argv[argc-2]+1)));\n    if (mirrorDir == NULL) {\n        perror(\"main calloc\");\n        abort();\n    }\n\n    // Pull the rootdir out of the argument list and save it in my internal data\n    mirrorDir = realpath(argv[argc-2], NULL);\n\n    argv[argc-2] = argv[argc-1];\n    argv[argc-1] = NULL;\n    argc--;\n\n    // turn over control to fuse\n    fprintf(stderr, \"about to call fuse_main\\n\");   \n    fuse_stat = fuse_main(argc, argv, &xmp_oper, mirrorDir);\n    fprintf(stderr, \"fuse_main returned %d\\n\", fuse_stat);\n    return fuse_stat;\n}\n", "I'm trying to implement the FUSE filesystem.  I am receiving this error:\ncannot access MountDir: Transport endpoint is not connected\nThis the relevant parts of the program. There are two directories, MirrorDir and MountDir, that exist withing the same directory as all of the code. I am calling the program like this:./myFS -o nonempty -o allow_other MirrorDir MountDir\nCan anyone see what I am doing wrong?static struct fuse_operations xmp_oper = {\n    .getattr    = xmp_getattr,\n    .readdir    = xmp_readdir,\n    .open       = xmp_open,\n    .read       = xmp_read,\n};\n\nint main(int argc, char *argv[]) {\n    int fuse_stat;\n    char* mirrorDir;\n\n    mirrorDir = malloc(sizeof(strlen(argv[argc-2]+1)));\n    if (mirrorDir == NULL) {\n        perror(\"main calloc\");\n        abort();\n    }\n\n    // Pull the rootdir out of the argument list and save it in my internal data\n    mirrorDir = realpath(argv[argc-2], NULL);\n\n    argv[argc-2] = argv[argc-1];\n    argv[argc-1] = NULL;\n    argc--;\n\n    // turn over control to fuse\n    fprintf(stderr, \"about to call fuse_main\\n\");   \n    fuse_stat = fuse_main(argc, argv, &xmp_oper, mirrorDir);\n    fprintf(stderr, \"fuse_main returned %d\\n\", fuse_stat);\n    return fuse_stat;\n}\n", "I'm trying to implement the FUSE filesystem.  I am receiving this error:\ncannot access MountDir: Transport endpoint is not connected\nThis the relevant parts of the program. There are two directories, MirrorDir and MountDir, that exist withing the same directory as all of the code. I am calling the program like this:./myFS -o nonempty -o allow_other MirrorDir MountDir\nCan anyone see what I am doing wrong?static struct fuse_operations xmp_oper = {\n    .getattr    = xmp_getattr,\n    .readdir    = xmp_readdir,\n    .open       = xmp_open,\n    .read       = xmp_read,\n};\n\nint main(int argc, char *argv[]) {\n    int fuse_stat;\n    char* mirrorDir;\n\n    mirrorDir = malloc(sizeof(strlen(argv[argc-2]+1)));\n    if (mirrorDir == NULL) {\n        perror(\"main calloc\");\n        abort();\n    }\n\n    // Pull the rootdir out of the argument list and save it in my internal data\n    mirrorDir = realpath(argv[argc-2], NULL);\n\n    argv[argc-2] = argv[argc-1];\n    argv[argc-1] = NULL;\n    argc--;\n\n    // turn over control to fuse\n    fprintf(stderr, \"about to call fuse_main\\n\");   \n    fuse_stat = fuse_main(argc, argv, &xmp_oper, mirrorDir);\n    fprintf(stderr, \"fuse_main returned %d\\n\", fuse_stat);\n    return fuse_stat;\n}\n", "I'm trying to implement the FUSE filesystem.  I am receiving this error:\ncannot access MountDir: Transport endpoint is not connected\nThis the relevant parts of the program. There are two directories, MirrorDir and MountDir, that exist withing the same directory as all of the code. I am calling the program like this:./myFS -o nonempty -o allow_other MirrorDir MountDir\nCan anyone see what I am doing wrong?static struct fuse_operations xmp_oper = {\n    .getattr    = xmp_getattr,\n    .readdir    = xmp_readdir,\n    .open       = xmp_open,\n    .read       = xmp_read,\n};\n\nint main(int argc, char *argv[]) {\n    int fuse_stat;\n    char* mirrorDir;\n\n    mirrorDir = malloc(sizeof(strlen(argv[argc-2]+1)));\n    if (mirrorDir == NULL) {\n        perror(\"main calloc\");\n        abort();\n    }\n\n    // Pull the rootdir out of the argument list and save it in my internal data\n    mirrorDir = realpath(argv[argc-2], NULL);\n\n    argv[argc-2] = argv[argc-1];\n    argv[argc-1] = NULL;\n    argc--;\n\n    // turn over control to fuse\n    fprintf(stderr, \"about to call fuse_main\\n\");   \n    fuse_stat = fuse_main(argc, argv, &xmp_oper, mirrorDir);\n    fprintf(stderr, \"fuse_main returned %d\\n\", fuse_stat);\n    return fuse_stat;\n}\n", "I'm trying to implement the FUSE filesystem.  I am receiving this error:\ncannot access MountDir: Transport endpoint is not connected\nThis the relevant parts of the program. There are two directories, MirrorDir and MountDir, that exist withing the same directory as all of the code. I am calling the program like this:./myFS -o nonempty -o allow_other MirrorDir MountDir\nCan anyone see what I am doing wrong?static struct fuse_operations xmp_oper = {\n    .getattr    = xmp_getattr,\n    .readdir    = xmp_readdir,\n    .open       = xmp_open,\n    .read       = xmp_read,\n};\n\nint main(int argc, char *argv[]) {\n    int fuse_stat;\n    char* mirrorDir;\n\n    mirrorDir = malloc(sizeof(strlen(argv[argc-2]+1)));\n    if (mirrorDir == NULL) {\n        perror(\"main calloc\");\n        abort();\n    }\n\n    // Pull the rootdir out of the argument list and save it in my internal data\n    mirrorDir = realpath(argv[argc-2], NULL);\n\n    argv[argc-2] = argv[argc-1];\n    argv[argc-1] = NULL;\n    argc--;\n\n    // turn over control to fuse\n    fprintf(stderr, \"about to call fuse_main\\n\");   \n    fuse_stat = fuse_main(argc, argv, &xmp_oper, mirrorDir);\n    fprintf(stderr, \"fuse_main returned %d\\n\", fuse_stat);\n    return fuse_stat;\n}\n", "For a OS project, I am creating a ext2 file system image and mounting it. This means that I am writing out a 1 MB file with block information and then using it as the mount target.For example, assume there is a file called base.img:fsck.ext2 base.img # checking my file system \nmkdir mnt\nsudo mount -o loop base.img mnt\nAfter the mount is successful, what is happening internally? From my understanding, my base.img simply initializes the image correctly. Internally, these are my questions:\nIs there now a drive partition with this file system?\nHow are changes to the file system managed?\nFor the second, from my understanding, there exists a \"mount table\" and perhaps an ext2 module that Linux will use for further changes. Will these changes be reflected in base.img or is there a new disk partition for it now?My underlying question here is: how does this all work?", "The image file has a partition table, and it contains multiple partitions.loopback devices might be a possibility.Related threads:\nhttp://linux.derkeiler.com/Mailing-Lists/Kernel/2005-01/7183.html\nhttp://lists.gnu.org/archive/html/grub-devel/2005-01/msg00077.html\nftp://ftp.hq.nasa.gov/pub/ig/ccd/enhanced_loopback/\n", "The image file has a partition table, and it contains multiple partitions.loopback devices might be a possibility.Related threads:\nhttp://linux.derkeiler.com/Mailing-Lists/Kernel/2005-01/7183.html\nhttp://lists.gnu.org/archive/html/grub-devel/2005-01/msg00077.html\nftp://ftp.hq.nasa.gov/pub/ig/ccd/enhanced_loopback/\n", "The image file has a partition table, and it contains multiple partitions.loopback devices might be a possibility.Related threads:\nhttp://linux.derkeiler.com/Mailing-Lists/Kernel/2005-01/7183.html\nhttp://lists.gnu.org/archive/html/grub-devel/2005-01/msg00077.html\nftp://ftp.hq.nasa.gov/pub/ig/ccd/enhanced_loopback/\n", "The image file has a partition table, and it contains multiple partitions.loopback devices might be a possibility.Related threads:\nhttp://linux.derkeiler.com/Mailing-Lists/Kernel/2005-01/7183.html\nhttp://lists.gnu.org/archive/html/grub-devel/2005-01/msg00077.html\nftp://ftp.hq.nasa.gov/pub/ig/ccd/enhanced_loopback/\n", "The image file has a partition table, and it contains multiple partitions.loopback devices might be a possibility.Related threads:\nhttp://linux.derkeiler.com/Mailing-Lists/Kernel/2005-01/7183.html\nhttp://lists.gnu.org/archive/html/grub-devel/2005-01/msg00077.html\nftp://ftp.hq.nasa.gov/pub/ig/ccd/enhanced_loopback/\n", "The image file has a partition table, and it contains multiple partitions.loopback devices might be a possibility.Related threads:\nhttp://linux.derkeiler.com/Mailing-Lists/Kernel/2005-01/7183.html\nhttp://lists.gnu.org/archive/html/grub-devel/2005-01/msg00077.html\nftp://ftp.hq.nasa.gov/pub/ig/ccd/enhanced_loopback/\n", "How do I create a loop in the Linux filesystem?  I want to break the directed acyclic graph (DAG) property of the Linux filesystem.  Is this possible?  I have seen this condition once when I installed the scratchbox cross compiler on my Ubuntu.I don't know how to reproduce it now.", "How do I create a loop in the Linux filesystem?  I want to break the directed acyclic graph (DAG) property of the Linux filesystem.  Is this possible?  I have seen this condition once when I installed the scratchbox cross compiler on my Ubuntu.I don't know how to reproduce it now.", "How do I create a loop in the Linux filesystem?  I want to break the directed acyclic graph (DAG) property of the Linux filesystem.  Is this possible?  I have seen this condition once when I installed the scratchbox cross compiler on my Ubuntu.I don't know how to reproduce it now.", "How do I create a loop in the Linux filesystem?  I want to break the directed acyclic graph (DAG) property of the Linux filesystem.  Is this possible?  I have seen this condition once when I installed the scratchbox cross compiler on my Ubuntu.I don't know how to reproduce it now.", "I am usingmount -o bind /some/directory/here /foo/bar\nI want to check /foo/bar though with a bash script, and see if its been mounted? If not, then call the above mount command, else do something else. How can I do this?CentOS is the operating system.", "I am usingmount -o bind /some/directory/here /foo/bar\nI want to check /foo/bar though with a bash script, and see if its been mounted? If not, then call the above mount command, else do something else. How can I do this?CentOS is the operating system.", "I am usingmount -o bind /some/directory/here /foo/bar\nI want to check /foo/bar though with a bash script, and see if its been mounted? If not, then call the above mount command, else do something else. How can I do this?CentOS is the operating system.", "I am usingmount -o bind /some/directory/here /foo/bar\nI want to check /foo/bar though with a bash script, and see if its been mounted? If not, then call the above mount command, else do something else. How can I do this?CentOS is the operating system.", "I am usingmount -o bind /some/directory/here /foo/bar\nI want to check /foo/bar though with a bash script, and see if its been mounted? If not, then call the above mount command, else do something else. How can I do this?CentOS is the operating system.", "I am usingmount -o bind /some/directory/here /foo/bar\nI want to check /foo/bar though with a bash script, and see if its been mounted? If not, then call the above mount command, else do something else. How can I do this?CentOS is the operating system.", "I am usingmount -o bind /some/directory/here /foo/bar\nI want to check /foo/bar though with a bash script, and see if its been mounted? If not, then call the above mount command, else do something else. How can I do this?CentOS is the operating system.", "I'm using overlayFS to create a sort of simple experimental sandboxing.\nI think I understand how it works:\nlower layer should be always mounted R/O\nupper layer is where all changes happen\nwork layer is for transactional reasons\ntarget is where all merged lower + upper go\nAs example, I have a physical disk mounted on /disk2. Then I want to overlay to preserve the contents, so I can do something like:mount(\"overlay\", \"/disk2\", \"overlay\", MS_MGC_VAL, \"lowerdir=/disk2,upperdir=./upper,workdir=./work\");\nThis works just fine: when my new process tries to amend content under /disk2, then it will only amend in reality under upper: this is indeed working as intended. For example, I can also see the 0, 0 files to show that something is deleted in the upper but not in the lower.Unfortunately looks like I can't somehow overlay on root /: if I execute the following code:mount(\"overlay\", \"/\", \"overlay\", MS_MGC_VAL, \"lowerdir=/disk2,upperdir=./upper,workdir=./work\")\nI can still see the whole real / and when I write files, they get written in their real (i.e. lower) location, not in the upper one.What am I doing wrong here?I am on kernel 4.4.0-53."], "chosen": ["\nI mounted a ssh file system (sshfs command line) and left it mounted and I had same problem, fusermount -u YOUR_MNT_DIR solved my problem.\n", "\nThis typically is caused by the mount directory being left mounted due to a crash of your filesystem. Go to the parent directory of the mount point and enter fusermount -u YOUR_MNT_DIR.\nIf this doesn't do the trick, do sudo umount -l YOUR_MNT_DIR.\n", "\nIn Azure, I tried to mount my container using user managed identities. I kept getting Transport endpoint is not connected until the Storage Blob Data Contributor permission was added to the managed identity.\n", "\nYou may check your /etc/hosts to verify it the master node is with a fully qualified name. More details in https://community.cloudera.com/t5/CDH-Manual-Installation/Setting-the-NameNode-port-8020-to-listen-outside-of-localhost/td-p/2257 and in How to configure hosts file for Hadoop ecosystem\n", "\nA file with unreadable characters from a Windows box temporarily gave me this endpoint not connected error on an external USB drive each time I attempted to read it.  I could unmount and re-mount the drive to wake things up, but accessing that file (or even the directory containing it) re-broke things.\nI connected the drive to a different computer and renamed the file to resolve.\n\nDetails\nI spent a couple late-night hours lazily browsing Wikipedia and downloading the better pics to my Microsoft Surface (Win10); some had Asian and Cyrillic characters.\nNot my image, but more or less this:\n\nToday I used pscp -r -p to push the directory to my Linux Mint box--but pscp threw errors on several files.  I don't explicitly recall verbatim, but this is very close if not the same:\nhttps://superuser.com/questions/769385/pscp-and-utf-8-characters\n\"user@remote_host:/\u0421\u043f\u0440\u0430\u0432\u043e\u0447\u043d\u0438\u043a/file.txt\" \"E:\\\u0421\u043f\u0440\u0430\u0432\u043e\u0447\u043d\u0438\u043a\\file.txt\"\nscp: E:/??????????/file.txt: Cannot create file\n\nBack at my Linux box, trying to access the directory got me the Transport endpoint is not connected error.  Then the entire drive became unusable--both in thunar file manager and at the CLI, with errors like \"cannot get working directory\" and other problems we'd expect with a damaged filesystem.\nThe fusermount command got me nowhere, but sudo umount -l worked several times.\nEach time I un-and-re-mounted this drive (formatted exFAT), everything reverted to normal (read/write/delete worked as expected)--until I attempted to read/rename/remove the directory with the unreadable (UTF-8?) characters, at which point the entire drive again became inaccessible.\nI connected the drive to the WinBox and renamed the files--all better.\nI could probably add a character set support, but this was the first time in 20 years I've encountered this, so I doubt I'll bother.\nJonathan Brown's answer helped me diagnose this and conclude that the simple solution of carrying the drive upstairs could be the fix.\n", "\nLinux uses block devices to hold data (most of the time those are disks with a partition table at the beginning and multiple partitions, each with a filesystem that then are mounted individually), but any block device will do.\nThe loop option you are using created a block device (usually in /dev/loop0) and associated it with the file you are using as an image.\nFor more details see loop(4)\n", "\nIf you have util-linux v2.21 or higher, you can now do this with losetup. Use the -P (--partscan) option to read the partition table and create device nodes for each partition:\n# losetup --show -f -P test.img\n/dev/loop0\n\n# ls /dev/loop0*\n/dev/loop0\n/dev/loop0p1\n/dev/loop0p2\n\n# mount /dev/loop0p1 /mnt/tmp\n\n", "\nLet's say $IMAGE is set to the path to your image file.\nYou could write a small script by using\nfdisk -u sectors -l $IMAGE\n\nto get a list of partitions inside the image. And then use a sequence of\nmount -o ro,loop,offset=$OFFSET -t auto $IMAGE /media/$DEST\n\nWhere offset is calculated means the info from fdisk (start sector * size of a sector in bytes) and $DEST a unique name for each of the partitions.\nThat's not directly the solution but I hope a pretty good indication on how to realize it. If you make the job once, you've some small nice beginning for some forensic toolkit!\u200b\u200b\u200b\u200b\u200b\u200b\u200b\u200b\u200b\u200b\u200b\u200b\u200b\u200b\u200b\u200b\u200b\u200b\u200b\u200b\u200b\n", "\nYou might do it like this, without much hassle:\n# kpartx -v -a logging-test.img \nadd map loop0p1 (251:0): 0 497664 linear /dev/loop0 2048\nadd map loop0p2 (251:1): 0 66605058 linear /dev/loop0 501758\nadd map loop0p5 (251:2): 0 66605056 251:1 2\n# ls /dev/mapper/\ncontrol  loop0p1  loop0p2  loop0p5\n# mount /dev/mapper/loop0p1 /mnt/test\n# mount  | grep test\n/dev/mapper/loop0p1 on /mnt/test type ext2 (rw)\n#\n\nAnd to remove the loop device after you finished:\n# kpartx -v -d logging-test.img\ndel devmap : loop0p2\ndel devmap : loop0p1\nloop deleted : /dev/loop0\n#\n\n", "\nlosetup -P automation\nlosetup -P is the best method starting in Ubuntu 16.04 as mentioned at https://stackoverflow.com/a/15200862/895245 , here are functions to automate if further. Usage:\n$ los my.img\n/dev/loop0\n/mnt/loop0p1\n/mnt/loop0p2\n\n$ ls /mnt/loop0p1\n/whatever\n/files\n/youhave\n/there\n\n$ sudo losetup -l\nNAME       SIZELIMIT OFFSET AUTOCLEAR RO BACK-FILE                                                                                      DIO\n/dev/loop1         0      0         0  0 /full/path/to/my.img\n\n$ # Cleanup.\n$ losd 0\n$ ls /mnt/loop0p1\n$ ls /dev | grep loop0\nloop0\n\nSource:\nlos() (\n  img=\"$1\"\n  dev=\"$(sudo losetup --show -f -P \"$img\")\"\n  echo \"$dev\"\n  for part in \"$dev\"?*; do\n    if [ \"$part\" = \"${dev}p*\" ]; then\n      part=\"${dev}\"\n    fi\n    dst=\"/mnt/$(basename \"$part\")\"\n    echo \"$dst\"\n    sudo mkdir -p \"$dst\"\n    sudo mount \"$part\" \"$dst\"\n  done\n)\nlosd() (\n  dev=\"/dev/loop$1\"\n  for part in \"$dev\"?*; do\n    if [ \"$part\" = \"${dev}p*\" ]; then\n      part=\"${dev}\"\n    fi\n    dst=\"/mnt/$(basename \"$part\")\"\n    sudo umount \"$dst\"\n  done\n  sudo losetup -d \"$dev\"\n)\n\n", "\nOk, this question is aeons old, but just for the sako of completeness: This here seems a lot easier to me.\nQuote:\nrmmod loop\nmodprobe loop max_part=63\nlosetup -f /path/to/your/disk/image.raw\nmount /dev/loop0p1 /mnt/path\n\n", "\nSome more automation to the previous answers that were great.\nTo further simplify the task (which is needed if you do it often), you may use my script mountimg to do everything for you. Just get it from https://github.com/AlexanderAmelkin/mountimg\nand use like this:\nmountimg disk_image.img $PARTNO /mnt/mountpoint\n\nYou may as well specify filesystem type and any other additional mount options if you like:\nmountimg disk_image.img $PARTNO /mnt/mountpoint -t vfat -o codepage=866,iocharset=utf-8\n\nWhen you're done with the partition, simply umount it:\numount /mnt/mountpoint\n\n", "\nSome other responders have already answered how to set up a mount using the loopback device, but you specifically asked about bind mounts, which are a little bit different.  If you want to use a bind mount, you just specify --bind in the mount command.  For example:\nmount --bind /original/path /new/path\n\nThis will make the filesystem location accessible at /original/path also accessible through /new/path.  Note that this will not following mountpoints!  For example, suppose I have the following mountpoints:\n/something\n/something/underneath/that\n\nNow suppose I make a bind mount for /something:\nmount --bind /something /new_something\n\nI will be able to access files like /something/myfile via the path /new_something/myfile.  But I will not be able to access files like /something/underneath/that/otherfile via the path /new_something/underneath/that/otherfile.  You must set up a separate bind mount for each filesystem; or if you have a relatively new kernel, you can use rbind mounts, which do follow mountpoints:\nmount --rbind /something /new_something\n\nOne caveat about rbind mounts:  they do not handle the case where a filesystem is mounted after the rbind is setup.  That is, suppose I have a mount like this:\n/something\n\nThen I set up my rbind as above, and then I mount /something/underneath/that:  the rbind will not magically make the new mount visible through the rbind location.  Also be aware that apparently due to a bug in the kernel, you cannot unmount an rbind mount.\nAlso, just in case you meant \"How do I set up bind mounts using the mount(2) system call?\":  you must specify the MS_BIND flag (defined in mount.h) when you call mount(2) for a regular bind mount.  For an rbind mount, you must specify MS_BIND and the undocument MS_REC flag (defined in linux/fs.h).\nHope that helps,\nEric Melski\n", "\nIt looks like all the answers so far are about mounting on loopback devices, and not creating a loop using bind mounts.\nAs you've probably discovered,\n$ mkdir -p test/test\n$ mount --bind test test/test\n\nonly allows you to access test/test/test, and no further.  Not even\n$ mount --rbind test test/test\n\nworks, because the recursive bind-mount effectively goes through finding existing mounts on the source and binding them in the target.\nWhat you've asked for isn't possible, since bind mounts don't cross mount points.  If you really wish to simulate a filesystem loop, try use a pseudo-bind mount like localfs.  I haven't tried myself, it may lock up when trying to read a filesystem provided by itself.  Just now, I tried exporting a NFS tree with crossmnt and mounting it under itself, but fails for similar reasons.\n", "\nHere\u2019s an actual answer for what you wanted:\nIf you want to actually create a real directory hard link, you can\nuse debugfs\nto manually edit the file system, and add a directory link. Like so:\n# debugfs -w /dev/sda1 # For the first partition of the first SCSI disk.\ndebugfs 1.46.5 (30-Dec-2021)\ndebugfs: ln /tmp/crashMe / \n\nThis makes /tmp/crashMe point back to the root dir, and may crash your system, if you enter it at any time. So don\u2019t forget to undo it later.\n\nAlternatively, I found\na passthrough/mirror file system.\nto do the job nicely.\nThere are several FUSE implementations of this, as it is trivial. Searching for it, turned up at least five different ones on the first page, so I\u2019ll avoid picking one. :)\nUnlike with bind mounts AFAIK, the kernel does not seem to be able to prevent not such a file system from causing it trouble. In my tests, I could crash the kernel (a literal oops, requiring a reboot) with a mirror FUSE that I mounted as a normal user! Which is a major security problem, I think, but I may have forgotten that I allowed it in some kernel settings.\nThe point is: If you wanted to induce a crash or the like (esp. without messing a file system up or having the kernel stop you), I can testify that that this one gets you that. ;)\n\nIn general, the trouble with such loops is purely with the implementations of certain tools (and bits of the kernel, like permission checking I think, apparently), that traverse them. The file systems handle them just fine. IMHO it\u2019s just bad programmers that can\u2019t handle anything more complex than reference counting garbage collection. ;)\n", "\nmount /path/to/device /path/to/mount/location -o loop\n\nwhere /path/to/device is the path to either the partition you want to mount, or the path to a disk image, and /path/to/mount/location is the path to the folder you want to mount the device/image under\nyou may also need to include the type of the file system like so (which uses fat16/fat32):\nmount /path/to/device /path/to/mount/location -o loop -t vfat\n\n", "\nRunning the mount command without arguments will tell you the current mounts.  From a shell script, you can check for the mount point with grep and an if-statement:\nif mount | grep /mnt/md0 > /dev/null; then\n    echo \"yay\"\nelse\n    echo \"nay\"\nfi\n\nIn my example, the if-statement is checking the exit code of grep, which indicates if there was a match.  Since I don't want the output to be displayed when there is a match, I'm redirecting it to /dev/null.\n", "\nYou didn't bother to mention an O/S.\nUbuntu Linux 11.10 (and probably most up-to-date flavors of Linux) have the mountpoint command.\nHere's an example on one of my servers:\n$ mountpoint /oracle\n/oracle is a mountpoint\n$ mountpoint /bin\n/bin is not a mountpoint\n\nActually, in your case, you should be able to use the -q option, like this:\nmountpoint -q /foo/bar || mount -o bind /some/directory/here /foo/bar\n\n", "\nThe manual of mountpoint says that it:\n\nchecks whether the given directory or file is mentioned in the /proc/self/mountinfo file.\n\nThe manual of mount says that:\n\nThe listing mode is maintained for backward compatibility only. For\n  more robust and customizable output use findmnt(8), especially in your\n  scripts.\n\nSo the correct command to use is findmnt, which is itself part of the util-linux package and, according to the manual:\n\nis able to search in /etc/fstab, /etc/mtab or /proc/self/mountinfo\n\nSo it actually searches more things than mountpoint. It also provides the convenient option:\n\n-M, --mountpoint path\nExplicitly define the mountpoint file or directory. See also --target.\n\nIn summary, to check whether a directory is mounted with bash, you can use:\nif [[ $(findmnt -M \"$FOLDER\") ]]; then\n    echo \"Mounted\"\nelse\n    echo \"Not mounted\"\nfi\n\n\nExample:\nmkdir -p /tmp/foo/{a,b}\ncd /tmp/foo\n\nsudo mount -o bind a b\ntouch a/file\nls b/ # should show file\nrm -f b/file\nls a/ # should show nothing\n\n[[ $(findmnt -M b) ]] && echo \"Mounted\"\nsudo umount b\n[[ $(findmnt -M b) ]] || echo \"Unmounted\"\n\n", "\nI like the answers that use /proc/mounts, but I don't like doing a simple grep. That can give you false positives. What you really want to know is \"do any of the rows have this exact string for field number 2\". So, ask that question. (in this case I'm checking /opt)\nawk -v status=1 '$2 == \"/opt\" {status=0} END {exit status}' /proc/mounts\n\n# and you can use it in and if like so:\n\nif awk -v status=1 '$2 == \"/opt\" {status=0} END {exit status}' /proc/mounts; then\n  echo \"yes\"\nelse\n  echo \"no\"\nfi\n\n", "\nMy solution:\nis_mount() {\n    path=$(readlink -f $1)\n    grep -q \"$path\" /proc/mounts\n}\n\nExample:\nis_mount /path/to/var/run/mydir/ || mount --bind /var/run/mydir/ /path/to/var/run/mydir/\n\nFor Mark J. Bobak's answer, mountpoint not work if mount with bind option in different filesystem.\nFor Christopher Neylan's answer, it's not need to redirect grep's output to /dev/null, just use grep -q instead.\nThe most important, canonicalize the path by using readlink -f $mypath:\n\nIf you check path such as /path/to/dir/ end with backslash, the path in /proc/mounts or mount output is /path/to/dir\nIn most linux release, /var/run/ is the symlink of /run/, so if you mount bind for /var/run/mypath and check if it mounted, it will display as /run/mypath in /proc/mounts.\n\n", "\nThe answers here are too complicated just check if the mount exists using:\ncat /proc/mounts | tail -n 1\nThis only outputs the last mounted folder, if you want to see all of them just remove the tail command.\n", "\nAnother clean solution is like that:\n$ mount | grep /dev/sdb1 > /dev/null && echo mounted || echo unmounted\n\nFor sure, 'echo something' can be substituted by whatever you need to do for each case.\n", "\nAccording to what I've read I don't think it's possible to programmatically do this once the system is started.\n"], "rejected": ["\nI encountered this problem like \"Transport endpoint is not connected\" or \"Permission denied\" when I use rclone to mount Microsoft OneDrive to a Ubuntu system. I am a normal user of the system, so by default my home directory is accessible only to me. When I created the mountpoint directory, it is also accessible only to me.\nI finally figure out that these error messages are related to the file access privilege mode. Since I am a normal user but fusermount runs as root, it cannot access the mountpoint directory while mounting, and cannot access my home directory while unmounting, so it complaints. The solution is very simple: open the file access privilege of both the mountpoint directory and home directory to everyone by setting their mode bits to 777.\n", "\nI encountered this problem like \"Transport endpoint is not connected\" or \"Permission denied\" when I use rclone to mount Microsoft OneDrive to a Ubuntu system. I am a normal user of the system, so by default my home directory is accessible only to me. When I created the mountpoint directory, it is also accessible only to me.\nI finally figure out that these error messages are related to the file access privilege mode. Since I am a normal user but fusermount runs as root, it cannot access the mountpoint directory while mounting, and cannot access my home directory while unmounting, so it complaints. The solution is very simple: open the file access privilege of both the mountpoint directory and home directory to everyone by setting their mode bits to 777.\n", "\nI encountered this problem like \"Transport endpoint is not connected\" or \"Permission denied\" when I use rclone to mount Microsoft OneDrive to a Ubuntu system. I am a normal user of the system, so by default my home directory is accessible only to me. When I created the mountpoint directory, it is also accessible only to me.\nI finally figure out that these error messages are related to the file access privilege mode. Since I am a normal user but fusermount runs as root, it cannot access the mountpoint directory while mounting, and cannot access my home directory while unmounting, so it complaints. The solution is very simple: open the file access privilege of both the mountpoint directory and home directory to everyone by setting their mode bits to 777.\n", "\nI encountered this problem like \"Transport endpoint is not connected\" or \"Permission denied\" when I use rclone to mount Microsoft OneDrive to a Ubuntu system. I am a normal user of the system, so by default my home directory is accessible only to me. When I created the mountpoint directory, it is also accessible only to me.\nI finally figure out that these error messages are related to the file access privilege mode. Since I am a normal user but fusermount runs as root, it cannot access the mountpoint directory while mounting, and cannot access my home directory while unmounting, so it complaints. The solution is very simple: open the file access privilege of both the mountpoint directory and home directory to everyone by setting their mode bits to 777.\n", "\nI encountered this problem like \"Transport endpoint is not connected\" or \"Permission denied\" when I use rclone to mount Microsoft OneDrive to a Ubuntu system. I am a normal user of the system, so by default my home directory is accessible only to me. When I created the mountpoint directory, it is also accessible only to me.\nI finally figure out that these error messages are related to the file access privilege mode. Since I am a normal user but fusermount runs as root, it cannot access the mountpoint directory while mounting, and cannot access my home directory while unmounting, so it complaints. The solution is very simple: open the file access privilege of both the mountpoint directory and home directory to everyone by setting their mode bits to 777.\n", "\nExt2 is a block-based filesystem, i.e. it needs a \"block device\".\nA disk is a block device (e.g. /dev/sda). A disk partition within a disk is also a block device (e.g. /dev/sda1). Linux can also treat memory as block device (/dev/ram0).\nEssentially anything that can be seen as contiguous bytes that are addressable by offset can be seen as a block device.\nAnd that includes files, like base.img, which mount will map to block device such as /dev/loop0.\nExt2 doesn't care about whether the block device is a disk, a partition, memory, or a file, it just writes things in certain offsets.\n(that's a simplification but it's good enough).\nSo to answer your questions:\n\nIs there now a drive partition with this file system?\n\nNo. There's a new block device (/dev/loop0), but not a new partition - partition are a something specific to disks.\n\nHow are changes to the file system managed?\n...\nhow does this all work?\n\n\nYou write to mnt, i.e. \"write data A to /mnt/some/file at offset X\".\nThe writes go to ext2.\next2 computes what data needs to be written at which block device offset, writes to block device, i.e. \"write data B to /dev/loop0 at offset Y\".\nThe loopback driver receives this request and forwards them to the filesystem that hosts base.img (which may or may not be ext2), i.e. \"write data B to base.img at offset Y\".\nThat filesystem does its own computation and creates the request to its own block device, i.e. \"write data C to /dev/sda1 at offset Z\".\nThe disk driver receives this request and writes to the disk.\n\n\nWill these changes be reflected in base.img or is there a new disk partition for it now?\n\nThese changes will be reflected in base.img, by means of ext2 writing to /dev/loop0.\n", "\nJust an addition to Andrew Y's answer.\nIf you run into this error:\n/dev/mapper/control: open failed: Permission denied\nFailure to communicate with kernel device-mapper driver.\n\nThen you just need to run the command again using sudo.\nI know it's not much of an answer, but it might help those that are fairly new to linux.\nAlso as of right now, the solution still works just fine, and I'm running it on Kali linux 2023.1\n", "\nJust an addition to Andrew Y's answer.\nIf you run into this error:\n/dev/mapper/control: open failed: Permission denied\nFailure to communicate with kernel device-mapper driver.\n\nThen you just need to run the command again using sudo.\nI know it's not much of an answer, but it might help those that are fairly new to linux.\nAlso as of right now, the solution still works just fine, and I'm running it on Kali linux 2023.1\n", "\nJust an addition to Andrew Y's answer.\nIf you run into this error:\n/dev/mapper/control: open failed: Permission denied\nFailure to communicate with kernel device-mapper driver.\n\nThen you just need to run the command again using sudo.\nI know it's not much of an answer, but it might help those that are fairly new to linux.\nAlso as of right now, the solution still works just fine, and I'm running it on Kali linux 2023.1\n", "\nJust an addition to Andrew Y's answer.\nIf you run into this error:\n/dev/mapper/control: open failed: Permission denied\nFailure to communicate with kernel device-mapper driver.\n\nThen you just need to run the command again using sudo.\nI know it's not much of an answer, but it might help those that are fairly new to linux.\nAlso as of right now, the solution still works just fine, and I'm running it on Kali linux 2023.1\n", "\nJust an addition to Andrew Y's answer.\nIf you run into this error:\n/dev/mapper/control: open failed: Permission denied\nFailure to communicate with kernel device-mapper driver.\n\nThen you just need to run the command again using sudo.\nI know it's not much of an answer, but it might help those that are fairly new to linux.\nAlso as of right now, the solution still works just fine, and I'm running it on Kali linux 2023.1\n", "\nJust an addition to Andrew Y's answer.\nIf you run into this error:\n/dev/mapper/control: open failed: Permission denied\nFailure to communicate with kernel device-mapper driver.\n\nThen you just need to run the command again using sudo.\nI know it's not much of an answer, but it might help those that are fairly new to linux.\nAlso as of right now, the solution still works just fine, and I'm running it on Kali linux 2023.1\n", "\nYou may also want to create one from scratch:\nFirst create the image file and initialize it\ndd if=/dev/zero of=/tmp/loop.img bs=1024k count=$IMG_SIZE\n\nNext, make it a valid partition using an FS type of your choice\nmkfs.ext3 -F /tmp/loop.img\n\nMount your new image\nmkdir -p /mnt/image\nmount /tmp/loop.img /mnt/image -o loop\n\nYou can now create/copy files and directories in your new image.\n", "\nYou may also want to create one from scratch:\nFirst create the image file and initialize it\ndd if=/dev/zero of=/tmp/loop.img bs=1024k count=$IMG_SIZE\n\nNext, make it a valid partition using an FS type of your choice\nmkfs.ext3 -F /tmp/loop.img\n\nMount your new image\nmkdir -p /mnt/image\nmount /tmp/loop.img /mnt/image -o loop\n\nYou can now create/copy files and directories in your new image.\n", "\nYou may also want to create one from scratch:\nFirst create the image file and initialize it\ndd if=/dev/zero of=/tmp/loop.img bs=1024k count=$IMG_SIZE\n\nNext, make it a valid partition using an FS type of your choice\nmkfs.ext3 -F /tmp/loop.img\n\nMount your new image\nmkdir -p /mnt/image\nmount /tmp/loop.img /mnt/image -o loop\n\nYou can now create/copy files and directories in your new image.\n", "\nYou may also want to create one from scratch:\nFirst create the image file and initialize it\ndd if=/dev/zero of=/tmp/loop.img bs=1024k count=$IMG_SIZE\n\nNext, make it a valid partition using an FS type of your choice\nmkfs.ext3 -F /tmp/loop.img\n\nMount your new image\nmkdir -p /mnt/image\nmount /tmp/loop.img /mnt/image -o loop\n\nYou can now create/copy files and directories in your new image.\n", "\nIn my .bashrc, I made the following alias:\nalias disk-list=\"sudo fdisk -l\"\n\n", "\nIn my .bashrc, I made the following alias:\nalias disk-list=\"sudo fdisk -l\"\n\n", "\nIn my .bashrc, I made the following alias:\nalias disk-list=\"sudo fdisk -l\"\n\n", "\nIn my .bashrc, I made the following alias:\nalias disk-list=\"sudo fdisk -l\"\n\n", "\nIn my .bashrc, I made the following alias:\nalias disk-list=\"sudo fdisk -l\"\n\n", "\nIn my .bashrc, I made the following alias:\nalias disk-list=\"sudo fdisk -l\"\n\n", "\nIn my .bashrc, I made the following alias:\nalias disk-list=\"sudo fdisk -l\"\n\n", "\nprior-art: If you like one, then this is not for you...\nex.\n...previous / partition: /dev/nvme3n2\nsave your root partition to an image file (ie... dd if=/dev/nvme3n2 of=/free_2_be/2022-12-11-awesome.im bs=44M oflag=direct status=progress)\nmount the overlay filesystem to '/' (REALLY not necessary in init *(1) ); then initiate pivot_root  ...glory.\n** realize that you can never go back if you choose switch_root ...now, don't not never say that nobody didn't provide you with a disclaimer.  In regard to the site's privacy policy and whatnot: viking created the word 'law' **\n*(1) derived inference from a retrospective regarding that kind of overlay in init, indicates that that kind of thing, in that circumstance, is a problem.\n"]}