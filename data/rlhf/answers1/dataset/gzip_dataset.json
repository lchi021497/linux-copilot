{"prompt": ["I have a folder structure (a bad rip of an old website - you maybe know about the old double compression problem), and some files are called somefilename.txt but actually gz compressed. I am looking for a way to identify these files and then unpacking them into the txt files that they actually are. Environment is Linux.", "I have a folder structure (a bad rip of an old website - you maybe know about the old double compression problem), and some files are called somefilename.txt but actually gz compressed. I am looking for a way to identify these files and then unpacking them into the txt files that they actually are. Environment is Linux.", "I have a directory. It has about 500K .gz files. How can I extract all .gz in that directory and delete the .gz files?", "I have a directory. It has about 500K .gz files. How can I extract all .gz in that directory and delete the .gz files?", "I have a directory. It has about 500K .gz files. How can I extract all .gz in that directory and delete the .gz files?", "I have a directory. It has about 500K .gz files. How can I extract all .gz in that directory and delete the .gz files?", "I have a directory. It has about 500K .gz files. How can I extract all .gz in that directory and delete the .gz files?", "I have a directory. It has about 500K .gz files. How can I extract all .gz in that directory and delete the .gz files?", "I have a directory. It has about 500K .gz files. How can I extract all .gz in that directory and delete the .gz files?", "I have tried the following, but the resulting file stays at size 0.tail -f /logs/localhost.log | gzip -c -9 -f > compressed.gz\nlocalhost.log is very active.Thank you.", "I have tried the following, but the resulting file stays at size 0.tail -f /logs/localhost.log | gzip -c -9 -f > compressed.gz\nlocalhost.log is very active.Thank you.", "I've got a large collection of gzipped archives on my Ubuntu webserver, and I need them converted to zips. I figure this would be done with a script, but what language should I use, and how would I go about unzipping and rezipping files?", "I've got a large collection of gzipped archives on my Ubuntu webserver, and I need them converted to zips. I figure this would be done with a script, but what language should I use, and how would I go about unzipping and rezipping files?", "I've got a large collection of gzipped archives on my Ubuntu webserver, and I need them converted to zips. I figure this would be done with a script, but what language should I use, and how would I go about unzipping and rezipping files?", "I've got a large collection of gzipped archives on my Ubuntu webserver, and I need them converted to zips. I figure this would be done with a script, but what language should I use, and how would I go about unzipping and rezipping files?", "I've got a large collection of gzipped archives on my Ubuntu webserver, and I need them converted to zips. I figure this would be done with a script, but what language should I use, and how would I go about unzipping and rezipping files?", "I've got a large collection of gzipped archives on my Ubuntu webserver, and I need them converted to zips. I figure this would be done with a script, but what language should I use, and how would I go about unzipping and rezipping files?", "I have a .tar.gz file which has multiple folders underneath. Each folder has multiple files and I only want to extract the SNAPSHOT.jar from all the folders it has underneath.I tried using wildcards but its not helping. Ex:    tar -xf samplejars.tar.gz --wildcards \"*SNAPSHOT*.jar\"\nsamplejars.tar.gz has many folders and I only want to extract SNAPSHOT.jar. How do I do that?Note: All the jars have unique/different names.", "I have a .tar.gz file which has multiple folders underneath. Each folder has multiple files and I only want to extract the SNAPSHOT.jar from all the folders it has underneath.I tried using wildcards but its not helping. Ex:    tar -xf samplejars.tar.gz --wildcards \"*SNAPSHOT*.jar\"\nsamplejars.tar.gz has many folders and I only want to extract SNAPSHOT.jar. How do I do that?Note: All the jars have unique/different names.", "I have a Bash script that creates a .tar.gz file, encrypts, and then sends it to a drive. However, I cannot open the .tar.gz file afterwards. Here is my process...Bash script that encrypts.#!/bin/sh\n\n# Tar the automysqlbackup directory\ntar -zcf \"red-backup-$(date '+%Y-%m-%d').tar.gz\" /var/lib/automysqlbackup/\n\n# Encrypt the tar file\nopenssl aes-256-cbc -a -salt -in \"red-backup-$(date '+%Y-%m-%d').tar.gz\" -out \"red-backup-$(date '+%Y-%m-%d').tar.gz.enc\" -pass 'pass:MySecretPWD'\n\n# Remove the original tar file\nrm -rf \"red-backup-$(date '+%Y-%m-%d').tar.gz\"\n\n# Upload to Google Drive\ngdrive upload --file \"red-backup-$(date '+%Y-%m-%d').tar.gz.enc\" -p \"jofhriout849uioejfoiu09\"\nThen I download the file and usesudo openssl aes-256-cbc -e -in red-backup-2016-09-22.tar.gz.enc -out red-backup-2016-09-22.tar.gz\nI then enter the passphrase for my file twice and I now get a file calledred-backup-2016-09-22.tar.gz\nWhen I then trysudo tar -zxvf red-backup-2016-09-22.tar.gz\nI getgzip: stdin: not in gzip format\ntar: Child returned status 1\ntar: Error is not recoverable: exiting now\nI have also tried renaming the file .tar and also triedsudo tar xvf red-backup-2016-09-22.tar.gz\nandsudo tar xvf red-backup-2016-09-22.tar\n\ntar: This does not look like a tar archive\ntar: Skipping to next header\ntar: Exiting with failure status due to previous errors\nWhere am I going wrong?", "I have a Bash script that creates a .tar.gz file, encrypts, and then sends it to a drive. However, I cannot open the .tar.gz file afterwards. Here is my process...Bash script that encrypts.#!/bin/sh\n\n# Tar the automysqlbackup directory\ntar -zcf \"red-backup-$(date '+%Y-%m-%d').tar.gz\" /var/lib/automysqlbackup/\n\n# Encrypt the tar file\nopenssl aes-256-cbc -a -salt -in \"red-backup-$(date '+%Y-%m-%d').tar.gz\" -out \"red-backup-$(date '+%Y-%m-%d').tar.gz.enc\" -pass 'pass:MySecretPWD'\n\n# Remove the original tar file\nrm -rf \"red-backup-$(date '+%Y-%m-%d').tar.gz\"\n\n# Upload to Google Drive\ngdrive upload --file \"red-backup-$(date '+%Y-%m-%d').tar.gz.enc\" -p \"jofhriout849uioejfoiu09\"\nThen I download the file and usesudo openssl aes-256-cbc -e -in red-backup-2016-09-22.tar.gz.enc -out red-backup-2016-09-22.tar.gz\nI then enter the passphrase for my file twice and I now get a file calledred-backup-2016-09-22.tar.gz\nWhen I then trysudo tar -zxvf red-backup-2016-09-22.tar.gz\nI getgzip: stdin: not in gzip format\ntar: Child returned status 1\ntar: Error is not recoverable: exiting now\nI have also tried renaming the file .tar and also triedsudo tar xvf red-backup-2016-09-22.tar.gz\nandsudo tar xvf red-backup-2016-09-22.tar\n\ntar: This does not look like a tar archive\ntar: Skipping to next header\ntar: Exiting with failure status due to previous errors\nWhere am I going wrong?", "I have a Bash script that creates a .tar.gz file, encrypts, and then sends it to a drive. However, I cannot open the .tar.gz file afterwards. Here is my process...Bash script that encrypts.#!/bin/sh\n\n# Tar the automysqlbackup directory\ntar -zcf \"red-backup-$(date '+%Y-%m-%d').tar.gz\" /var/lib/automysqlbackup/\n\n# Encrypt the tar file\nopenssl aes-256-cbc -a -salt -in \"red-backup-$(date '+%Y-%m-%d').tar.gz\" -out \"red-backup-$(date '+%Y-%m-%d').tar.gz.enc\" -pass 'pass:MySecretPWD'\n\n# Remove the original tar file\nrm -rf \"red-backup-$(date '+%Y-%m-%d').tar.gz\"\n\n# Upload to Google Drive\ngdrive upload --file \"red-backup-$(date '+%Y-%m-%d').tar.gz.enc\" -p \"jofhriout849uioejfoiu09\"\nThen I download the file and usesudo openssl aes-256-cbc -e -in red-backup-2016-09-22.tar.gz.enc -out red-backup-2016-09-22.tar.gz\nI then enter the passphrase for my file twice and I now get a file calledred-backup-2016-09-22.tar.gz\nWhen I then trysudo tar -zxvf red-backup-2016-09-22.tar.gz\nI getgzip: stdin: not in gzip format\ntar: Child returned status 1\ntar: Error is not recoverable: exiting now\nI have also tried renaming the file .tar and also triedsudo tar xvf red-backup-2016-09-22.tar.gz\nandsudo tar xvf red-backup-2016-09-22.tar\n\ntar: This does not look like a tar archive\ntar: Skipping to next header\ntar: Exiting with failure status due to previous errors\nWhere am I going wrong?", "I have a Bash script that creates a .tar.gz file, encrypts, and then sends it to a drive. However, I cannot open the .tar.gz file afterwards. Here is my process...Bash script that encrypts.#!/bin/sh\n\n# Tar the automysqlbackup directory\ntar -zcf \"red-backup-$(date '+%Y-%m-%d').tar.gz\" /var/lib/automysqlbackup/\n\n# Encrypt the tar file\nopenssl aes-256-cbc -a -salt -in \"red-backup-$(date '+%Y-%m-%d').tar.gz\" -out \"red-backup-$(date '+%Y-%m-%d').tar.gz.enc\" -pass 'pass:MySecretPWD'\n\n# Remove the original tar file\nrm -rf \"red-backup-$(date '+%Y-%m-%d').tar.gz\"\n\n# Upload to Google Drive\ngdrive upload --file \"red-backup-$(date '+%Y-%m-%d').tar.gz.enc\" -p \"jofhriout849uioejfoiu09\"\nThen I download the file and usesudo openssl aes-256-cbc -e -in red-backup-2016-09-22.tar.gz.enc -out red-backup-2016-09-22.tar.gz\nI then enter the passphrase for my file twice and I now get a file calledred-backup-2016-09-22.tar.gz\nWhen I then trysudo tar -zxvf red-backup-2016-09-22.tar.gz\nI getgzip: stdin: not in gzip format\ntar: Child returned status 1\ntar: Error is not recoverable: exiting now\nI have also tried renaming the file .tar and also triedsudo tar xvf red-backup-2016-09-22.tar.gz\nandsudo tar xvf red-backup-2016-09-22.tar\n\ntar: This does not look like a tar archive\ntar: Skipping to next header\ntar: Exiting with failure status due to previous errors\nWhere am I going wrong?", "I have a Bash script that creates a .tar.gz file, encrypts, and then sends it to a drive. However, I cannot open the .tar.gz file afterwards. Here is my process...Bash script that encrypts.#!/bin/sh\n\n# Tar the automysqlbackup directory\ntar -zcf \"red-backup-$(date '+%Y-%m-%d').tar.gz\" /var/lib/automysqlbackup/\n\n# Encrypt the tar file\nopenssl aes-256-cbc -a -salt -in \"red-backup-$(date '+%Y-%m-%d').tar.gz\" -out \"red-backup-$(date '+%Y-%m-%d').tar.gz.enc\" -pass 'pass:MySecretPWD'\n\n# Remove the original tar file\nrm -rf \"red-backup-$(date '+%Y-%m-%d').tar.gz\"\n\n# Upload to Google Drive\ngdrive upload --file \"red-backup-$(date '+%Y-%m-%d').tar.gz.enc\" -p \"jofhriout849uioejfoiu09\"\nThen I download the file and usesudo openssl aes-256-cbc -e -in red-backup-2016-09-22.tar.gz.enc -out red-backup-2016-09-22.tar.gz\nI then enter the passphrase for my file twice and I now get a file calledred-backup-2016-09-22.tar.gz\nWhen I then trysudo tar -zxvf red-backup-2016-09-22.tar.gz\nI getgzip: stdin: not in gzip format\ntar: Child returned status 1\ntar: Error is not recoverable: exiting now\nI have also tried renaming the file .tar and also triedsudo tar xvf red-backup-2016-09-22.tar.gz\nandsudo tar xvf red-backup-2016-09-22.tar\n\ntar: This does not look like a tar archive\ntar: Skipping to next header\ntar: Exiting with failure status due to previous errors\nWhere am I going wrong?", "I have a Bash script that creates a .tar.gz file, encrypts, and then sends it to a drive. However, I cannot open the .tar.gz file afterwards. Here is my process...Bash script that encrypts.#!/bin/sh\n\n# Tar the automysqlbackup directory\ntar -zcf \"red-backup-$(date '+%Y-%m-%d').tar.gz\" /var/lib/automysqlbackup/\n\n# Encrypt the tar file\nopenssl aes-256-cbc -a -salt -in \"red-backup-$(date '+%Y-%m-%d').tar.gz\" -out \"red-backup-$(date '+%Y-%m-%d').tar.gz.enc\" -pass 'pass:MySecretPWD'\n\n# Remove the original tar file\nrm -rf \"red-backup-$(date '+%Y-%m-%d').tar.gz\"\n\n# Upload to Google Drive\ngdrive upload --file \"red-backup-$(date '+%Y-%m-%d').tar.gz.enc\" -p \"jofhriout849uioejfoiu09\"\nThen I download the file and usesudo openssl aes-256-cbc -e -in red-backup-2016-09-22.tar.gz.enc -out red-backup-2016-09-22.tar.gz\nI then enter the passphrase for my file twice and I now get a file calledred-backup-2016-09-22.tar.gz\nWhen I then trysudo tar -zxvf red-backup-2016-09-22.tar.gz\nI getgzip: stdin: not in gzip format\ntar: Child returned status 1\ntar: Error is not recoverable: exiting now\nI have also tried renaming the file .tar and also triedsudo tar xvf red-backup-2016-09-22.tar.gz\nandsudo tar xvf red-backup-2016-09-22.tar\n\ntar: This does not look like a tar archive\ntar: Skipping to next header\ntar: Exiting with failure status due to previous errors\nWhere am I going wrong?", "I have a Bash script that creates a .tar.gz file, encrypts, and then sends it to a drive. However, I cannot open the .tar.gz file afterwards. Here is my process...Bash script that encrypts.#!/bin/sh\n\n# Tar the automysqlbackup directory\ntar -zcf \"red-backup-$(date '+%Y-%m-%d').tar.gz\" /var/lib/automysqlbackup/\n\n# Encrypt the tar file\nopenssl aes-256-cbc -a -salt -in \"red-backup-$(date '+%Y-%m-%d').tar.gz\" -out \"red-backup-$(date '+%Y-%m-%d').tar.gz.enc\" -pass 'pass:MySecretPWD'\n\n# Remove the original tar file\nrm -rf \"red-backup-$(date '+%Y-%m-%d').tar.gz\"\n\n# Upload to Google Drive\ngdrive upload --file \"red-backup-$(date '+%Y-%m-%d').tar.gz.enc\" -p \"jofhriout849uioejfoiu09\"\nThen I download the file and usesudo openssl aes-256-cbc -e -in red-backup-2016-09-22.tar.gz.enc -out red-backup-2016-09-22.tar.gz\nI then enter the passphrase for my file twice and I now get a file calledred-backup-2016-09-22.tar.gz\nWhen I then trysudo tar -zxvf red-backup-2016-09-22.tar.gz\nI getgzip: stdin: not in gzip format\ntar: Child returned status 1\ntar: Error is not recoverable: exiting now\nI have also tried renaming the file .tar and also triedsudo tar xvf red-backup-2016-09-22.tar.gz\nandsudo tar xvf red-backup-2016-09-22.tar\n\ntar: This does not look like a tar archive\ntar: Skipping to next header\ntar: Exiting with failure status due to previous errors\nWhere am I going wrong?", "I have a Bash script that creates a .tar.gz file, encrypts, and then sends it to a drive. However, I cannot open the .tar.gz file afterwards. Here is my process...Bash script that encrypts.#!/bin/sh\n\n# Tar the automysqlbackup directory\ntar -zcf \"red-backup-$(date '+%Y-%m-%d').tar.gz\" /var/lib/automysqlbackup/\n\n# Encrypt the tar file\nopenssl aes-256-cbc -a -salt -in \"red-backup-$(date '+%Y-%m-%d').tar.gz\" -out \"red-backup-$(date '+%Y-%m-%d').tar.gz.enc\" -pass 'pass:MySecretPWD'\n\n# Remove the original tar file\nrm -rf \"red-backup-$(date '+%Y-%m-%d').tar.gz\"\n\n# Upload to Google Drive\ngdrive upload --file \"red-backup-$(date '+%Y-%m-%d').tar.gz.enc\" -p \"jofhriout849uioejfoiu09\"\nThen I download the file and usesudo openssl aes-256-cbc -e -in red-backup-2016-09-22.tar.gz.enc -out red-backup-2016-09-22.tar.gz\nI then enter the passphrase for my file twice and I now get a file calledred-backup-2016-09-22.tar.gz\nWhen I then trysudo tar -zxvf red-backup-2016-09-22.tar.gz\nI getgzip: stdin: not in gzip format\ntar: Child returned status 1\ntar: Error is not recoverable: exiting now\nI have also tried renaming the file .tar and also triedsudo tar xvf red-backup-2016-09-22.tar.gz\nandsudo tar xvf red-backup-2016-09-22.tar\n\ntar: This does not look like a tar archive\ntar: Skipping to next header\ntar: Exiting with failure status due to previous errors\nWhere am I going wrong?"], "chosen": ["\nI'd probably do it like this, untested:\n#!/usr/bin/env bash\n\ntmp=$(mktemp) || exit 1\ntrap 'rm -f \"$tmp\"; exit' EXIT\n\nwhile IFS= read -r -d '' file; do\n    gunzip -dc \"$file\" > \"$tmp\" &&\n    mv -- \"$tmp\" \"$file\" &&\n    printf '%s\\0' \"$file\"\ndone < <(find . -type f -name '*.txt' -print0)\n\nThat will output a list of nul-terminated file names it unpacked. If none of your file names can contain newlines then you could change \\0 to \\n to improve readability. You might want to change gunzip -dc \"$file\" > \"$tmp\" to gunzip -dc \"$file\" > \"$tmp\" 2>/dev/null or similar if you find gunzip is spitting out an error message for every file it can't unpack.\n", "\nIf you are using Bash version 4.3 or later then all of the work of finding the files to uncompress can be done with pure Bash.  Try this Shellcheck-clean code:\n#! /bin/bash -p\n\n# Create a temporary file that will disappear no matter how the program ends\ntmpfile=$(mktemp) && exec {tmpfd}<>\"$tmpfile\" && rm -- \"$tmpfile\" || exit\ntmpfile=/dev/fd/$tmpfd\n\nshopt -s dotglob globstar nullglob\n\nfor f in **/*.txt; do\n    if [[ -f $f ]] && read -r -d '' -n 2 s <\"$f\" && [[ $s == $'\\x1f\\x8b' ]]\n    then\n        printf 'Decompressing: %s\\n' \"$f\" >&2\n        gunzip -c <\"$f\" >\"$tmpfile\"\n        cat <\"$tmpfile\" >\"$f\"\n    fi\ndone\n\n\ntmpfile=$(mktemp) && ... is boilerplate code for setting up a temporary file that will automatically disappear no matter how the program ends (even if it is killed with kill -9 or if the whole system crashes).  It is not generally portable, but it has been tested on Linux and Cygwin, should work on WSL, and may work on Solaris.\nshopt -s ... enables some Bash settings that are required by the code:\n\ndotglob enables globs to match files and directories that begin with ..  find processes such files by default.\nglobstar enables the use of ** to match paths recursively through directory trees.  This option was introduced with Bash 4.0 (released in 2009) but it is dangerous to use in versions before 4.3 (released in 2014) because it follows symlinks.\nnullglob makes globs expand to nothing when nothing matches (otherwise they expand to the glob pattern itself, which is almost never useful in programs).\n\n\n[[ $s == $'\\x1f\\x8b' ]] tests if the first two bytes of the file contain the magic number for a gzip file.  (See gzip - Wikipedia).\n\n", "\n@techedemic is correct but is missing '.' to mention the current directory, and this command go throught all subdirectories.\nfind . -name '*.gz' -exec gunzip '{}' \\;\n\n", "\nThis should do it:\ngunzip *.gz\n\n", "\nThere's more than one way to do this obviously.\n    # This will find files recursively (you can limit it by using some 'find' parameters. \n    # see the man pages\n    # Final backslash required for exec example to work\n    find . -name '*.gz' -exec gunzip '{}' \\;\n\n    # This will do it only in the current directory\n    for a in *.gz; do gunzip $a; done\n\nI'm sure there's other ways as well, but this is probably the simplest.\nAnd to remove it, just do a rm -rf *.gz in the applicable directory\n", "\nExtract all gz files in current directory and its subdirectories:\n find . -name \"*.gz\" | xargs gunzip \n\n", "\nIf you want to extract a single file use:\ngunzip file.gz\nIt will extract the file and remove .gz file.\n", "\nfor foo in *.gz\ndo\n  tar xf \"$foo\"\n  rm \"$foo\"\ndone\n\n", "\nTry:\nls -1 | grep -E \"\\.tar\\.gz$\" | xargs -n 1 tar xvfz\n\nThen Try:\nls -1 | grep -E \"\\.tar\\.gz$\" | xargs -n 1 rm\n\nThis will untar all .tar.gz files in the current directory and then delete all the .tar.gz files. If you want an explanation, the \"|\" takes the stdout of the command before it, and uses that as the stdin of the command after it. Use \"man command\" w/o the quotes to figure out what those commands and arguments do. Or, you can research online.\n", "\nYou're just not patient enough.  That will work, and it will write to the gzip file.  It will take a while to accumulate enough input to write the first compressed block.  Especially if the input is highly compressible, e.g. the log entries are very similar to each other.\nThis has a problem though, in that the gzip file will never be properly terminated, since gzip will never get an end-of-file.\n", "\nYou can't do this, because gzip utility doesn't read input line by line, it expects EOF.\nBut you can write your on wrapper using any programming language which has zlib implementation.\n", "\nI'd do it with a bash(1) one-liner:\nfor f in *.tar.gz;\\\ndo rm -rf ${f%.tar.gz} ;\\\nmkdir ${f%.tar.gz} ;\\\ntar -C ${f%.tar.gz} zxvf $f ;\\\nzip -r ${f%.tar.gz} $f.zip ;\\\nrm -rf ${f%.tar.gz} ;\\\ndone\n\nIt isn't very pretty because I'm not great at bash(1). Note that this destroys a lot of directories so be sure you know what this does before doing it.\nSee the bash(1) reference card for more details on the ${foo%bar} syntax.\n", "\nA simple bash script would be easiest, surely? That way you can just invoke the tar and zip commands.\n", "\nthe easiest solution on unix platforms may well be to use fuse and something like archivemount (libarchive), http://en.wikipedia.org/wiki/Archivemount .\n/iaw\n", "\nYou can use node.js and tar-to-zip for this purpose. All you need to do is:\nInstall node.js with nvm if you do not have it.\nAnd then install tar-to-zip with:\nnpm i tar-to-zip -g\n\nAnd use it with:\ntar-to-zip *.tar.gz\n\nAlso you can convert .tar.gz files to .zip programmatically.\nYou should install async and tar-to-zip locally:\nnpm i async tar-to-zip\n\nAnd then create converter.js with contents:\n#!/usr/bin/env node\n\n'use strict';\n\nconst fs = require('fs');\nconst tarToZip = require('tar-to-zip');\nconst eachSeries = require('async/eachSeries');\nconst names = process.argv.slice(2);\n\neachSeries(names, convert, exitIfError);\n\nfunction convert(name, done) {\n    const {stdout} = process;\n    const onProgress = (n) => {\n        stdout.write(`\\r${n}%: ${name}`);\n    };\n    const onFinish = (e) => {\n        stdout.write('\\n');\n        done();\n    };\n\n    const nameZip = name.replace(/\\.tar\\.gz$/, '.zip');    \n    const zip = fs.createWriteStream(nameZip)\n        .on('error', (error) => {\n            exitIfError(error);\n            fs.unlinkSync(zipPath);\n        });\n\n    const progress = true;\n    tarToZip(name, {progress})\n        .on('progress', onProgress)\n        .on('error', exitIfError)\n        .getStream()\n        .pipe(zip)\n        .on('finish', onFinish);\n}\n\nfunction exitIfError(error) {\n    if (!error)\n        return;\n\n    console.error(error.message);\n    process.exit(1);\n}\n\n", "\nZipfiles are handy because they offer random access to files. Tar files only sequential.\nMy solution for this conversion is this shell script, which calls itself via tar(1) \"--to-command\" option. (I prefer that rather than having 2 scripts). But I admit \"untar and zip -r\"  is faster than this, because zipnote(1) cannot work in-place, unfortunately.\n#!/bin/zsh -feu\n\n## Convert a tar file into zip:\n\nusage() {\n    setopt POSIX_ARGZERO\n    cat <<EOF\n    usage: ${0##*/} [+-h] [-v] [--] {tarfile} {zipfile}\"\n\n-v verbose\n-h print this message\nconverts the TAR archive into ZIP archive.\nEOF\n    unsetopt POSIX_ARGZERO\n}\n\nwhile getopts :hv OPT; do\n    case $OPT in\n        h|+h)\n            usage\n            exit\n            ;;\n        v)\n            # todo: ignore TAR_VERBOSE from env?\n            # Pass to the grand-child process:\n            export TAR_VERBOSE=y\n            ;;\n        *)\n            usage >&2\n            exit 2\n    esac\ndone\nshift OPTIND-1\nOPTIND=1\n\n# when invoked w/o parameters:\nif [ $# = 0 ] # todo: or stdin is not terminal\nthen\n    # we are invoked by tar(1)\n    if [ -n \"${TAR_VERBOSE-}\" ]; then echo $TAR_REALNAME >&2;fi\n    zip --grow --quiet $ZIPFILE -\n    # And rename it:\n    # fixme: this still makes a full copy, so slow.\n    printf \"@ -\\n@=$TAR_REALNAME\\n\" | zipnote -w $ZIPFILE\nelse\n    if [ $# != 2 ]; then usage >&2; exit 1;fi\n    # possibly: rm -f $ZIPFILE\n    ZIPFILE=$2 tar -xaf $1 --to-command=$0\nfi\n\n", "\nHere is a python solution based on this answer here: \nimport sys, tarfile, zipfile, glob\n\ndef convert_one_archive(file_name):\n    out_file = file_name.replace('.tar.gz', '.zip')\n    with tarfile.open(file_name, mode='r:gz') as tf:\n        with zipfile.ZipFile(out_file, mode='a', compression=zipfile.ZIP_DEFLATED) as zf:\n            for m in tf.getmembers():\n                f = tf.extractfile( m )\n                fl = f.read()\n                fn = m.name\n                zf.writestr(fn, fl)\n\nfor f in glob.glob('*.tar.gz'):\n    convert_one_archive(f)\n\n", "\nI tested it with the following folder structure:\ndata/\ndata/a\ndata/a/ANOTHER_SNAPSHOT.jar\ndata/b\ndata/c\ndata/c/SNAPSHOT.jar\ndata/d\ndata/e\ndata/f\ndata/f/SNAPSHOT.jar.with.extension\ndata/g\ndata/g/SNAPSHOT.jar\ndata/h\n\nThe following wildcard mask works and extract only the files matching exactly SNAPSHOT.jar not SNAPSHOT.jar.with.extension and ANOTHER_SNAPSHOT.jar\ntar -xf data.tar.gz --wildcards \"*/SNAPSHOT.jar\"\n\nResult:\ndata/c/SNAPSHOT.jar\ndata/g/SNAPSHOT.jar\n\n", "\nYou can use xargs for that :\ntar -tf data.tar.gz | grep SNAPSHOT.jar | xargs tar -xf data.tar.gz \n\nThen, to move all the files to the root directory\nfind archive_root_dir -type f -exec mv -i {} . \\;\n\n", "\nFirst check the type of compression using the file command:\nfile name_name.tgz\n\nOutput: If the output is \" XZ compressed data\", then use tar xf <archive name> to unzip the file, e.g.\n\ntar xf archive.tar.xz\n\ntar xf archive.tar.gz\n\ntar xf archive.tar\n\ntar xf archive.tgz\n\n\n", "\nThis means the file isn't really a gzipped tar file -- or any kind of gzipped file -- in spite of being named like one.\nWhen you download a file with wget, check for indications like Length: unspecified [text/html] which shows it is plain text (text) and that it is intended to be interpreted as html. Check the wget output below -\nwget --no-cookies --no-check-certificate --header \"Cookie: gpw_e24=http%3A%2F%2Fwww.oracle.com%2F; oraclelicense=accept-securebackup-cookie\" \"http://download.oracle.com/otn-pub/java/jdk/8u144-b01/090f390dda5b47b9b721c7dfaa008135/jdk-8u144-linux-x64.tar.gz\"\n\n--2017-10-12 12:39:40--  http://download.oracle.com/otn-pub/java/jdk/8u144-b01/090f390dda5b47b9b721c7dfaa008135/jdk-8u144-linux-x64.tar.gz\nResolving download.oracle.com (download.oracle.com)... 23.72.136.27, 23.72.136.67\nConnecting to download.oracle.com (download.oracle.com)|23.72.136.27|:80... connected.\nHTTP request sent, awaiting response... 302 Not Allowed\nLocation: http://XXXX/FAQs/URLFiltering/ProxyWarning.html [following]\n--2017-10-12 12:39:40--  http://XXXX/FAQs/URLFiltering/ProxyWarning.html\nResolving XXXX (XXXXX)... XXX.XX.XX.XXX\nConnecting to XXXX (XXXX)|XXX.XX.XX.XXX|:80... connected.\nHTTP request sent, awaiting response... 200 OK\nLength: 17121 (17K) [text/html]\nSaving to: \u2018jdk-8u144-linux-x64.tar.gz\u2019\n\n100%[=========================================================================================================================================================================>] 17,121      --.-K/s   in 0.05s\n\n2017-10-12 12:39:40 (349 KB/s) - \u2018jdk-8u144-linux-x64.tar.gz\u2019 saved [17121/17121]\n\nThis sort of confirms that you haven't received a gzip file.\nFor a correct file, the wget output will show something like Length: 185515842 (177M) [application/x-gzip] as shown in the below output -\nwget --no-cookies --no-check-certificate --header \"Cookie: gpw_e24=http%3A%2F%2Fwww.oracle.com%2F; oraclelicense=accept-securebackup-cookie\" \"http://download.oracle.com/otn-pub/java/jdk/8u144-b01/090f390dda5b47b9b721c7dfaa008135/jdk-8u144-linux-x64.tar.gz\"\n\n--2017-10-12 12:50:06--  http://download.oracle.com/otn-pub/java/jdk/8u144-b01/090f390dda5b47b9b721c7dfaa008135/jdk-8u144-linux-x64.tar.gz\nResolving download.oracle.com (download.oracle.com)... XX.XXX.XX.XX, XX.XX.XXX.XX\nConnecting to download.oracle.com (download.oracle.com)|XX.XX.XXX.XX|:80... connected.\nHTTP request sent, awaiting response... 302 Moved Temporarily\nLocation: https://edelivery.oracle.com/otn-pub/java/jdk/8u144-b01/090f390dda5b47b9b721c7dfaa008135/jdk-8u144-linux-x64.tar.gz [following]\n--2017-10-12 12:50:06--  https://edelivery.oracle.com/otn-pub/java/jdk/8u144-b01/090f390dda5b47b9b721c7dfaa008135/jdk-8u144-linux-x64.tar.gz\nResolving edelivery.oracle.com (edelivery.oracle.com)... XXX.XX.XXX.XX, 2600:1404:16:188::2d3e, 2600:1404:16:180::2d3e\nConnecting to edelivery.oracle.com (edelivery.oracle.com)|XXX.XX.XX.XXX|:443... connected.\nHTTP request sent, awaiting response... 302 Moved Temporarily\nLocation: http://download.oracle.com/otn-pub/java/jdk/8u144-b01/090f390dda5b47b9b721c7dfaa008135/jdk-8u144-linux-x64.tar.gz?AuthParam=1507827127_f44251ebbb44c6e61e7f202677f94afd [following]\n--2017-10-12 12:50:07--  http://download.oracle.com/otn-pub/java/jdk/8u144-b01/090f390dda5b47b9b721c7dfaa008135/jdk-8u144-linux-x64.tar.gz?AuthParam=1507827127_f44251ebbb44c6e61\nConnecting to download.oracle.com (download.oracle.com)|XX.XX.XXX.XX|:80... connected.\nHTTP request sent, awaiting response... 200 OK\nLength: 185515842 (177M) [application/x-gzip]\nSaving to: \u2018jdk-8u144-linux-x64.tar.gz\u2019\n\n100%[=========================================================================================================================================================================>] 185,515,842 6.60MB/s   in 28s\n\n2017-10-12 12:50:34 (6.43 MB/s) - \u2018jdk-8u144-linux-x64.tar.gz\u2019 saved [185515842/185515842]\n\nThe above shows a correct gzip application file has been downloaded.\nYou can also file, head, less, view utilities to check the file. For example, an HTML file would give the below output -\nhead jdk-8u144-linux-x64.tar.gz\n\nOutput:\n<!doctype html>\n<html lang=\"en\">\n\n<head>\n    <meta charset=\"utf-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n    <link href=\"/css/print.css\" rel=\"stylesheet\" media=\"print\">\n    <link href=\"/css/main.css\" rel=\"stylesheet\" media=\"screen\">\n    <link href=\"/css/font-awesome.min.css\" rel=\"stylesheet\">\n\nThe above shows it is indeed an HTML page which we are trying to unzip/untar - something that won't work. If it was indeed a correct zip file (binary in nature) the output of head would have produced garbage - something like below -\nhead jdk-8u144-linux-x64.tar.gz\n\nOutput:\nx\ufffdrY\ufffd[ms\ufffdF\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u068dt\u0456l\ufffd\ufffd\ufffdDR\ufffd\ufffd\ufffd\u014a\ufffd\ufffdj\n                                       $\ufffd$,`0\ufffdh\ufffd_\ufffd\ufffd\ufffd\ufffd/\ufffd\ufffd=\ufffd@Q\ufffdw+\ufffd\ufffd\u0571*\ufffdHbfz\ufffd{\ufffd~\ufffd{\ufffdi\ufffdx\ufffd\ufffdk\ufffd\ufffd\ufffd\ufffd\u07be}\ufffd\ufffd\ufffd\ufffdz\ufffd\ufffd\ufffdw\ufffd\ufffd\ufffd\ufffdg\ufffd\ufffd\ufffd\ufffd\ufffd{\ufffd\u07bc\ufffd;{s\ufffd\ufffd\ufffd\ufffdw\ufffd\ufffd\ufffd\u2e73\ufffd7\ufffdN\ufffd\ufffd\ufffd\ufffdi\ufffd\n\ufffd\ufffd\ufffd\ufffd\ufffd}\n\ufffd\u00bfg\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u05e7\ufffd\ufffd\ufffd7\ufffd\ufffds\ufffd\ufffd\ufffd\ufffd\ufffd\ud3fa\u00ee\u07f9\ufffd\ufffd\ufffd\ufffd\ufffd~i\ufffd\ufffdj\ufffd/\ufffd\ufffd\ufffd\ufffd\ufffd\u07bf#\ufffd\ufffd\ufffd=\ufffd\ufffd=>\ufffd\ufffd\u07ff{}\ufffd\ufffd|\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd3\ufffd\ufffd\ufffdX\ufffd\ufffd\ufffd]9\ufffd\u07a0\ufffd\ufffd\ufffd\ufffdu\ufffd\ufffd\ufffd\ufffd\ufffd%\u011f\ufffd<^)\ufffdH\ufffd8\ufffdF\ufffdR\ufffdt\ufffdo\ufffdL\ufffdu\ufffd\ufffdS%\ufffdds5\ufffd2_EZn\ufffdt^\ufffd\ufffd\n                                                                                                                                                 \ufffdN3\ufffd\ufffd(\ufffd\ufffd<\ufffd\ufffd|'\ufffdq\ufffd\ufffd\ufffdR\ufffdN\ufffdgq\ufffdUv!\ufffd\u06fb\ufffdp\ufffd\ufffd\ufffdrL\ufffd\ufffdM\ufffd\ufffdu\ufffd\ufffd.\ufffdQ\ufffd5\ufffdT\ufffd\ufffdBNw\ufffd!$\ufffd\ufffd<>\ufffd7G'$\ufffd,Mt4WY\ufffdGi\"\ufffd=\ufffd\ufffdp\ufffd)\ufffdVIN3\ufffd\ufffd\ufffd\ufffd\\ek\ufffd\ufffd0\ufffd\ufffdG\n                                            \ufffd<L\ufffdc\ufffd\u0113\ufffdt-\ufffd\ufffd\ufffd2\ufffd\ufffd\ufffdG:\u03e2ia\ufffd\ufffdI\ufffd<\u028bg3\ufffd\ufffd\ufffdd\ufffdH\ufffd\ufffd\ufffd\ufffd[2`\ufffd<I\ufffdA\ufffd6\ufffdW\ufffd\ufffd<\ufffd\ufffdC\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdh\ufffd\ufffdA0QL\ufffd2\ufffd4\ufffd-*\n\ufffdx\ufffd\ufffd\ufffd\u0415\ufffdt%t1\ufffd\ufffdf\ufffd>+A\u0342\ufffd,Lr\ufffd\n                        \ufffdFe:MBH\ufffd\ufffd\u0269\ufffd\nC\ufffdQ\ufffdr\ufffdS\ufffd\ufffd<M\ufffdb\ufffd<,5\ufffd\ufffd\ufffd@\ufffd\ufffd\ufffds\ufffd\ufffd\u0749c\ufffd\ufffdsp\ufffdf\ufffd=g\ufffd\ufffd?\ufffd\ufffdk\ufffd\ufffd\ufffd4\ufffd}\ufffd\ufffdkh)\ufffd\u00b9Z\ufffd\ufffd#d\ufffd*{\ufffd\ufffd\ufffd-\ufffd.N\ufffd)\ufffde\ufffd\ufffds:\ufffdH(VQ\ufffd\ufffd3*\ufffd$2\udb39\udd94\ufffd\ufffdr\u03e8v\ufffd\"o\ufffd_\ufffd\ufffd!A\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdB\ufffdl=A\ufffd|\ufffd\ufffd@\ufffd\ufffd0\ufffd\ufffd1\ufffd\ufffd5\ufffd\ufffd4g\ufffd\n\ufffd\n\ufffd\ufffd\ufffdSe\ufffd\ufffd\ufffd\ufffdH[2\ufffd\ufffd\ufffd\ufffd\ufffdt\ufffd\ufffd5\ufffdDf\ufffd\ufffd\ufffd\ufffd$1\ufffd\ufffd\ufffdb$\ufffd h\ufffdOp\ufffd\ufffd\ufffd\ufffd!Lvb!p\ufffd\ufffdb\ufffd8^\ufffdY\ufffd\ufffd\ufffdn\ufffd\n                                                                          O\ufffd\ufffd\u052a\u07f1\ufffd\ufffd|\ufffd\ufffdlW\ufffdlu\ufffd\ufffd*\ufffdN\ufffdM\ufffd\ufffd\ufffd\n\ufffd/\ufffd^0~\ufffd~\ufffd#\ufffd\ufffdq\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdK\ufffd\ufffd;\ufffdd\ufffd\ufffd\ufffdaw4\ufffd\ufffd\ufffd\ufffd\u074e'\ufffd~\ufffd7\ufffd\ufffdky\ufffdo\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffdt\ufffd'k\ufffd\ufffdf\ufffd\ufffd\ufffd\ufffd!vo\ufffd\ufffd\ufffd'o\ufffd\ufffd\ufffd     \ufffd.\ufffdPn\\\ufffd\n               \ufffd+\ufffd\ufffdK\"FA{\ufffd\ufffd\ufffd\ufffdn2\ufffd\ufffd\ufffd\ufffdv\ufffd\ufffd!/Ok\ufffd\ufffdr4\ufffdc5\ufffdx$'\ufffd.\ufffd&w\ufffd!\ufffd%\ufffd\u07a0o\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd2\ufffd\ufffd\ufffdi\n                                                                               \ufffda0\ufffd\ufffdAg\ufffdd\ufffd\ufffd\ufffd\ufffdGH)G7~\ufffdg\ufffd\ufffd\ufffdb\ufffd\ufffd%\ufffdb\ufffd\ufffdrt\ufffdm~\ufffd    \ufffd\ufffd\ufffd\ufffd\ufffdt0\ufffd\ufffd    <\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd5\ufffdq\ufffdt\ufffd\ufffdK(\ufffd\ufffd+Z<\ufffd\ufffd=\ufffd\ufffd\ufffd:1\ufffd\\\ufffdx\ufffdp=t\ufffd`\ufffd\ufffdG@F\ufffd\ufffd    i\ufffd\ufffd\ufffd\ufffd\ufffdp8\ufffd\ufffd\ufffd\ufffd\ufffdH.\ufffd\ufffd\ufffddMLE\ufffd\ufffde[\ufffd`\ufffd'n\ufffd\ufffd*h[\ufffd\ufffd;\ufffd0w'\ufffd\ufffd6A\ufffd\u0661M\ufffdx\ufffdfpeB>&\ufffd\ufffd\ufffdMO\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd`\ufffd@\u00e1/\ufffd\"\ufffd\ufffd\ufffd\ufffd\ufffd(\ufffd\ufffd^\ufffd\ufffd\ufffdn\ufffd\ufffd=\ufffd\ufffd\ufffd\ufffd5\ufffd\ufffd@\ufffdMx\ufffd\ufffdd:\\YAn\ufffd\ufffd\ufffd]|\ufffdw>\ufffd\ufffdS\ufffd\ufffdFA9\ufffdJ\ufffdk!\ufffd@\ufffd\n\nTry downloading from the official site and check if their download links have changed. Also check your proxy settings and make sure you have the right proxies enabled to download/wget it from the correct source.\n", "\nJust click first on that link and go to the HTML page where actual downloads or mirrors are.\nIt's really misleading to have a full link which ends in .tgz when it actually leads to an HTML page where the real download links are.\nI had this problem downloading Apache Spark and Wget-ing it into Ubuntu.\nhttps://spark.apache.org/downloads.html\n\n", "\nInitially, check the type of compression with the below command:\n`file <file_name>`\n\nIf the output is a POSIX compressed file, use the below command to uncompress:\n`tar xvf <file_name>`\n\n", "\nSometimes the .gz extension is wrongfully appended to the filename.\n\nRun file foo.csv.gz to know the actual file type.\nRename the file to foo.csv or whatever the actual file type is.\n\n", "\nAdd \"-O file.tgz\" or \"-O file.tar.gz\" at the end of the wget command and extract \"file.tgz\" or \"file.tar.gz\".\nHere is the sample code for Google Colaboratory:\n!wget -q  --trust-server-names  https://downloads.apache.org/spark/spark-3.0.0/spark-3.0.0-bin-hadoop2.7.tgz  -O file.tgz\nprint(\"Download completed successfully !!!\")\n!tar zxvf  file.tgz\n\nNote: Please ensure that the http path for tgz is valid and the file is not corrupted.\n", "\nunxz worked for me:\nsudo unxz fileName.xz\n\n", "\ncd /Whatever/Directory/Path/The/File/Is/In\n\nchmod +x xampp-linux-x64-7.0.6-0-installer.run\n\nsudo ./xampp-linux-x64-7.0.6-0-installer.run\n\nIt works.\nFor more information, refer to Installing XAMPP on Linux Mint.\n"], "rejected": ["\nYou could use a bash function to test the file type with file and decompress if it is gzip-compressed. And you could call the (exported) function in execdir action of find:\nif_gz_decompress () {\n  type=$(file -bi \"$1\")\n  if [[ \"$type\" =~ ^application/gzip\\; ]]; then\n    tmp=$(mktemp) &&\n    gunzip -dc \"$1\" > \"$tmp\" &&\n    mv -i \"$tmp\" \"$1\" ||\n    rm -f \"$tmp\"\n  fi\n}\nexport -f if_gz_decompress\nfind . -type f -execdir bash -c 'if_gz_decompress \"$1\"' _ {} \\;\n\nBecause of the -i option of mv you will have to confirm for each found file. Remove it if you are 100% sure it works as you wish (or if you have a backup).\nIf you have many such files and some are in the same directory we can maybe optimize a bit with:\nif_gz_decompress () {\n  for f in \"$@\"; do\n    type=$(file -bi \"$f\")\n    if [[ \"$type\" =~ ^application/gzip\\; ]]; then\n      tmp=$(mktemp) &&\n      gunzip -dc \"$f\" > \"$tmp\" &&\n      mv -i \"$tmp\" \"$f\" ||\n      rm -f \"$tmp\"\n    fi\n  done\n}\nexport -f if_gz_decompress\nfind . -type f -execdir bash -c 'if_gz_decompress \"$@\"' _ {} +\n\n", "\nYou could use a bash function to test the file type with file and decompress if it is gzip-compressed. And you could call the (exported) function in execdir action of find:\nif_gz_decompress () {\n  type=$(file -bi \"$1\")\n  if [[ \"$type\" =~ ^application/gzip\\; ]]; then\n    tmp=$(mktemp) &&\n    gunzip -dc \"$1\" > \"$tmp\" &&\n    mv -i \"$tmp\" \"$1\" ||\n    rm -f \"$tmp\"\n  fi\n}\nexport -f if_gz_decompress\nfind . -type f -execdir bash -c 'if_gz_decompress \"$1\"' _ {} \\;\n\nBecause of the -i option of mv you will have to confirm for each found file. Remove it if you are 100% sure it works as you wish (or if you have a backup).\nIf you have many such files and some are in the same directory we can maybe optimize a bit with:\nif_gz_decompress () {\n  for f in \"$@\"; do\n    type=$(file -bi \"$f\")\n    if [[ \"$type\" =~ ^application/gzip\\; ]]; then\n      tmp=$(mktemp) &&\n      gunzip -dc \"$f\" > \"$tmp\" &&\n      mv -i \"$tmp\" \"$f\" ||\n      rm -f \"$tmp\"\n    fi\n  done\n}\nexport -f if_gz_decompress\nfind . -type f -execdir bash -c 'if_gz_decompress \"$@\"' _ {} +\n\n", "\nfor deleting all .gz files in each and every directory. Please use this commands\nstep:1\n\ncd /\n\nstep :2\n\nfind . -type f -iname *.gz -delete\n\n", "\nfor deleting all .gz files in each and every directory. Please use this commands\nstep:1\n\ncd /\n\nstep :2\n\nfind . -type f -iname *.gz -delete\n\n", "\nfor deleting all .gz files in each and every directory. Please use this commands\nstep:1\n\ncd /\n\nstep :2\n\nfind . -type f -iname *.gz -delete\n\n", "\nfor deleting all .gz files in each and every directory. Please use this commands\nstep:1\n\ncd /\n\nstep :2\n\nfind . -type f -iname *.gz -delete\n\n", "\nfor deleting all .gz files in each and every directory. Please use this commands\nstep:1\n\ncd /\n\nstep :2\n\nfind . -type f -iname *.gz -delete\n\n", "\nfor deleting all .gz files in each and every directory. Please use this commands\nstep:1\n\ncd /\n\nstep :2\n\nfind . -type f -iname *.gz -delete\n\n", "\nfor deleting all .gz files in each and every directory. Please use this commands\nstep:1\n\ncd /\n\nstep :2\n\nfind . -type f -iname *.gz -delete\n\n", "\nlogrotate(8) was designed to solve this sort of problem - it rotates and compresses log files. \n", "\nlogrotate(8) was designed to solve this sort of problem - it rotates and compresses log files. \n", "\nHere is script based on @Brad Campbell's answer that works on files passed as command arguments, works with other tar file types (uncompressed or the other compression types supported by tarfile), and handles directories in the source tar file.  It will also print warnings if the source file contains a symlink or hardlink, which are converted to regular files.  For symlinks, the link is resolved during conversion.  This can lead to an error if the link target is not in the tar; this is also potentially dangerous from a security standpoint, so user beware.\n#!/usr/bin/python\n\nimport sys, tarfile, zipfile, glob, re\n\ndef convert_one_archive(in_file, out_file):\n    with tarfile.open(in_file, mode='r:*') as tf:\n        with zipfile.ZipFile(out_file, mode='a', compression=zipfile.ZIP_DEFLATED) as zf:\n            for m in [m for m in tf.getmembers() if not m.isdir()]:\n                if m.issym() or m.islnk():\n                    print('warning: symlink or hardlink converted to file')\n                f = tf.extractfile(m)\n                fl = f.read()\n                fn = m.name\n                zf.writestr(fn, fl)\n\nfor in_file in sys.argv[1:]:\n    out_file = re.sub(r'\\.((tar(\\.(gz|bz2|xz))?)|tgz|tbz|tbz2|txz)$', '.zip', in_file)\n    if out_file == in_file:\n        print(in_file, '---> [skipped]')\n    else:\n        print(in_file, '--->', out_file)\n        convert_one_archive(in_file, out_file)\n\n", "\nHere is script based on @Brad Campbell's answer that works on files passed as command arguments, works with other tar file types (uncompressed or the other compression types supported by tarfile), and handles directories in the source tar file.  It will also print warnings if the source file contains a symlink or hardlink, which are converted to regular files.  For symlinks, the link is resolved during conversion.  This can lead to an error if the link target is not in the tar; this is also potentially dangerous from a security standpoint, so user beware.\n#!/usr/bin/python\n\nimport sys, tarfile, zipfile, glob, re\n\ndef convert_one_archive(in_file, out_file):\n    with tarfile.open(in_file, mode='r:*') as tf:\n        with zipfile.ZipFile(out_file, mode='a', compression=zipfile.ZIP_DEFLATED) as zf:\n            for m in [m for m in tf.getmembers() if not m.isdir()]:\n                if m.issym() or m.islnk():\n                    print('warning: symlink or hardlink converted to file')\n                f = tf.extractfile(m)\n                fl = f.read()\n                fn = m.name\n                zf.writestr(fn, fl)\n\nfor in_file in sys.argv[1:]:\n    out_file = re.sub(r'\\.((tar(\\.(gz|bz2|xz))?)|tgz|tbz|tbz2|txz)$', '.zip', in_file)\n    if out_file == in_file:\n        print(in_file, '---> [skipped]')\n    else:\n        print(in_file, '--->', out_file)\n        convert_one_archive(in_file, out_file)\n\n", "\nHere is script based on @Brad Campbell's answer that works on files passed as command arguments, works with other tar file types (uncompressed or the other compression types supported by tarfile), and handles directories in the source tar file.  It will also print warnings if the source file contains a symlink or hardlink, which are converted to regular files.  For symlinks, the link is resolved during conversion.  This can lead to an error if the link target is not in the tar; this is also potentially dangerous from a security standpoint, so user beware.\n#!/usr/bin/python\n\nimport sys, tarfile, zipfile, glob, re\n\ndef convert_one_archive(in_file, out_file):\n    with tarfile.open(in_file, mode='r:*') as tf:\n        with zipfile.ZipFile(out_file, mode='a', compression=zipfile.ZIP_DEFLATED) as zf:\n            for m in [m for m in tf.getmembers() if not m.isdir()]:\n                if m.issym() or m.islnk():\n                    print('warning: symlink or hardlink converted to file')\n                f = tf.extractfile(m)\n                fl = f.read()\n                fn = m.name\n                zf.writestr(fn, fl)\n\nfor in_file in sys.argv[1:]:\n    out_file = re.sub(r'\\.((tar(\\.(gz|bz2|xz))?)|tgz|tbz|tbz2|txz)$', '.zip', in_file)\n    if out_file == in_file:\n        print(in_file, '---> [skipped]')\n    else:\n        print(in_file, '--->', out_file)\n        convert_one_archive(in_file, out_file)\n\n", "\nHere is script based on @Brad Campbell's answer that works on files passed as command arguments, works with other tar file types (uncompressed or the other compression types supported by tarfile), and handles directories in the source tar file.  It will also print warnings if the source file contains a symlink or hardlink, which are converted to regular files.  For symlinks, the link is resolved during conversion.  This can lead to an error if the link target is not in the tar; this is also potentially dangerous from a security standpoint, so user beware.\n#!/usr/bin/python\n\nimport sys, tarfile, zipfile, glob, re\n\ndef convert_one_archive(in_file, out_file):\n    with tarfile.open(in_file, mode='r:*') as tf:\n        with zipfile.ZipFile(out_file, mode='a', compression=zipfile.ZIP_DEFLATED) as zf:\n            for m in [m for m in tf.getmembers() if not m.isdir()]:\n                if m.issym() or m.islnk():\n                    print('warning: symlink or hardlink converted to file')\n                f = tf.extractfile(m)\n                fl = f.read()\n                fn = m.name\n                zf.writestr(fn, fl)\n\nfor in_file in sys.argv[1:]:\n    out_file = re.sub(r'\\.((tar(\\.(gz|bz2|xz))?)|tgz|tbz|tbz2|txz)$', '.zip', in_file)\n    if out_file == in_file:\n        print(in_file, '---> [skipped]')\n    else:\n        print(in_file, '--->', out_file)\n        convert_one_archive(in_file, out_file)\n\n", "\nHere is script based on @Brad Campbell's answer that works on files passed as command arguments, works with other tar file types (uncompressed or the other compression types supported by tarfile), and handles directories in the source tar file.  It will also print warnings if the source file contains a symlink or hardlink, which are converted to regular files.  For symlinks, the link is resolved during conversion.  This can lead to an error if the link target is not in the tar; this is also potentially dangerous from a security standpoint, so user beware.\n#!/usr/bin/python\n\nimport sys, tarfile, zipfile, glob, re\n\ndef convert_one_archive(in_file, out_file):\n    with tarfile.open(in_file, mode='r:*') as tf:\n        with zipfile.ZipFile(out_file, mode='a', compression=zipfile.ZIP_DEFLATED) as zf:\n            for m in [m for m in tf.getmembers() if not m.isdir()]:\n                if m.issym() or m.islnk():\n                    print('warning: symlink or hardlink converted to file')\n                f = tf.extractfile(m)\n                fl = f.read()\n                fn = m.name\n                zf.writestr(fn, fl)\n\nfor in_file in sys.argv[1:]:\n    out_file = re.sub(r'\\.((tar(\\.(gz|bz2|xz))?)|tgz|tbz|tbz2|txz)$', '.zip', in_file)\n    if out_file == in_file:\n        print(in_file, '---> [skipped]')\n    else:\n        print(in_file, '--->', out_file)\n        convert_one_archive(in_file, out_file)\n\n", "\nHere is script based on @Brad Campbell's answer that works on files passed as command arguments, works with other tar file types (uncompressed or the other compression types supported by tarfile), and handles directories in the source tar file.  It will also print warnings if the source file contains a symlink or hardlink, which are converted to regular files.  For symlinks, the link is resolved during conversion.  This can lead to an error if the link target is not in the tar; this is also potentially dangerous from a security standpoint, so user beware.\n#!/usr/bin/python\n\nimport sys, tarfile, zipfile, glob, re\n\ndef convert_one_archive(in_file, out_file):\n    with tarfile.open(in_file, mode='r:*') as tf:\n        with zipfile.ZipFile(out_file, mode='a', compression=zipfile.ZIP_DEFLATED) as zf:\n            for m in [m for m in tf.getmembers() if not m.isdir()]:\n                if m.issym() or m.islnk():\n                    print('warning: symlink or hardlink converted to file')\n                f = tf.extractfile(m)\n                fl = f.read()\n                fn = m.name\n                zf.writestr(fn, fl)\n\nfor in_file in sys.argv[1:]:\n    out_file = re.sub(r'\\.((tar(\\.(gz|bz2|xz))?)|tgz|tbz|tbz2|txz)$', '.zip', in_file)\n    if out_file == in_file:\n        print(in_file, '---> [skipped]')\n    else:\n        print(in_file, '--->', out_file)\n        convert_one_archive(in_file, out_file)\n\n", "\nYou can create a file with the pattern you are looking for: \necho \"*SNAPSHOT*.jar\" > target\n\nIf you have multiple patterns, you can add multiple lines to your target file\necho \"*.md\" >> target\n\nThen you can use the --files-from switch:\ntar -xf samplejars.tar.gz --files-from=filename\n\nI tested with \ndata/\ndata/a/\ndata/a/ANOTHER_SNAPSHOT.jar\ndata/b/\ndata/c/\ndata/c/SNAPSHOT.jar\ndata/d/\ndata/e/\ndata/f/\ndata/f/SNAPSHOT.jar.with.extension\ndata/g/\ndata/g/SNAPSHOT-2.jar\ndata/g/SNAPSHOT.jar\ndata/h/\n\nResult\ndata/a/ANOTHER_SNAPSHOT.jar\ndata/c/SNAPSHOT.jar\ndata/g/SNAPSHOT-2.jar\ndata/g/SNAPSHOT.jar\n\nIf all the files have unique filenames, as the OP said, you can use --strip-components to remove the file structure\ntar -xf samplejars.tar.gz --files-from=filename --strip-components 2\n\nWith my data, the result was: \nANOTHER_SNAPSHOT.jar\nSNAPSHOT.jar\nSNAPSHOT-2.jar\n\nBecause I did not have unique names, one of the SNAPSHOT.jar files was overwritten in the --strip-components step.\n", "\nYou can create a file with the pattern you are looking for: \necho \"*SNAPSHOT*.jar\" > target\n\nIf you have multiple patterns, you can add multiple lines to your target file\necho \"*.md\" >> target\n\nThen you can use the --files-from switch:\ntar -xf samplejars.tar.gz --files-from=filename\n\nI tested with \ndata/\ndata/a/\ndata/a/ANOTHER_SNAPSHOT.jar\ndata/b/\ndata/c/\ndata/c/SNAPSHOT.jar\ndata/d/\ndata/e/\ndata/f/\ndata/f/SNAPSHOT.jar.with.extension\ndata/g/\ndata/g/SNAPSHOT-2.jar\ndata/g/SNAPSHOT.jar\ndata/h/\n\nResult\ndata/a/ANOTHER_SNAPSHOT.jar\ndata/c/SNAPSHOT.jar\ndata/g/SNAPSHOT-2.jar\ndata/g/SNAPSHOT.jar\n\nIf all the files have unique filenames, as the OP said, you can use --strip-components to remove the file structure\ntar -xf samplejars.tar.gz --files-from=filename --strip-components 2\n\nWith my data, the result was: \nANOTHER_SNAPSHOT.jar\nSNAPSHOT.jar\nSNAPSHOT-2.jar\n\nBecause I did not have unique names, one of the SNAPSHOT.jar files was overwritten in the --strip-components step.\n", "\nThis is probably because of your gzip version incompatibility.\nCheck these points first:\n\nwhich gzip\n\n/usr/bin/gzip   or /bin/gzip\nIt should be either /bin/gzip or /usr/bin/gzip. If your gzip points to some other gzip application, please try by removing that path from your PATH environment variable.\nNext is\n\ngzip -V\n\ngzip 1.3.5\n(2002-09-30)\nYour problem can be resolved with these check points.\n", "\nThis is probably because of your gzip version incompatibility.\nCheck these points first:\n\nwhich gzip\n\n/usr/bin/gzip   or /bin/gzip\nIt should be either /bin/gzip or /usr/bin/gzip. If your gzip points to some other gzip application, please try by removing that path from your PATH environment variable.\nNext is\n\ngzip -V\n\ngzip 1.3.5\n(2002-09-30)\nYour problem can be resolved with these check points.\n", "\nThis is probably because of your gzip version incompatibility.\nCheck these points first:\n\nwhich gzip\n\n/usr/bin/gzip   or /bin/gzip\nIt should be either /bin/gzip or /usr/bin/gzip. If your gzip points to some other gzip application, please try by removing that path from your PATH environment variable.\nNext is\n\ngzip -V\n\ngzip 1.3.5\n(2002-09-30)\nYour problem can be resolved with these check points.\n", "\nThis is probably because of your gzip version incompatibility.\nCheck these points first:\n\nwhich gzip\n\n/usr/bin/gzip   or /bin/gzip\nIt should be either /bin/gzip or /usr/bin/gzip. If your gzip points to some other gzip application, please try by removing that path from your PATH environment variable.\nNext is\n\ngzip -V\n\ngzip 1.3.5\n(2002-09-30)\nYour problem can be resolved with these check points.\n", "\nThis is probably because of your gzip version incompatibility.\nCheck these points first:\n\nwhich gzip\n\n/usr/bin/gzip   or /bin/gzip\nIt should be either /bin/gzip or /usr/bin/gzip. If your gzip points to some other gzip application, please try by removing that path from your PATH environment variable.\nNext is\n\ngzip -V\n\ngzip 1.3.5\n(2002-09-30)\nYour problem can be resolved with these check points.\n", "\nThis is probably because of your gzip version incompatibility.\nCheck these points first:\n\nwhich gzip\n\n/usr/bin/gzip   or /bin/gzip\nIt should be either /bin/gzip or /usr/bin/gzip. If your gzip points to some other gzip application, please try by removing that path from your PATH environment variable.\nNext is\n\ngzip -V\n\ngzip 1.3.5\n(2002-09-30)\nYour problem can be resolved with these check points.\n", "\nThis is probably because of your gzip version incompatibility.\nCheck these points first:\n\nwhich gzip\n\n/usr/bin/gzip   or /bin/gzip\nIt should be either /bin/gzip or /usr/bin/gzip. If your gzip points to some other gzip application, please try by removing that path from your PATH environment variable.\nNext is\n\ngzip -V\n\ngzip 1.3.5\n(2002-09-30)\nYour problem can be resolved with these check points.\n", "\nThis is probably because of your gzip version incompatibility.\nCheck these points first:\n\nwhich gzip\n\n/usr/bin/gzip   or /bin/gzip\nIt should be either /bin/gzip or /usr/bin/gzip. If your gzip points to some other gzip application, please try by removing that path from your PATH environment variable.\nNext is\n\ngzip -V\n\ngzip 1.3.5\n(2002-09-30)\nYour problem can be resolved with these check points.\n"]}