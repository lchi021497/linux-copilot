{"prompt": ["use lsof to show a port, but every port return same info...[kfadmin@master fundrisksys]$ lsof -i:136\n24223   /usr/bin/bash   /dev/pts/0\n24223   /usr/bin/bash   /dev/pts/0\n24223   /usr/bin/bash   /dev/pts/0\n24223   /usr/bin/bash   /dev/pts/0\n\n[kfadmin@master fundrisksys]$ lsof -i:7895\n24223   /usr/bin/bash   /dev/pts/0\n24223   /usr/bin/bash   /dev/pts/0\n24223   /usr/bin/bash   /dev/pts/0\n24223   /usr/bin/bash   /dev/pts/0\nI can't use any port, it shows same info:\nBind for 0.0.0.0:8001 failed: port is already allocatedI try to kill the pid, but the terminal will be killed", "I was trying to run the following instruction in Android (Java): Process p = Runtime.getRuntime().exec(\"/system/bin/lsof|grep mediaserver\");\nbut I am getting an error if I run the following instruction: Process p = Runtime.getRuntime().exec(\"/system/bin/lsof \");\nthe file is successfully saved. Can anyone tell what is the error? Actually I want to list and check if media server service is being running or not.", "I did the following actions on two separate terminals:1s term:Start process that is writing to file in background:\u2514\u2500\u2500> while true; do date >> log; sleep 1; done &\n[1] 20604\nGet the PID of last process that is running in background:\u2514\u2500\u2500> echo $!\n20604\n2nd term:Display the content of file being written:\u2514\u2500\u2500> tail -f log\nThu May  7 18:48:20 CEST 2015\nThu May  7 18:48:21 CEST 2015\nThu May  7 18:48:22 CEST 2015\nThu May  7 18:48:23 CEST 2015\nThu May  7 18:48:24 CEST 2015\nThu May  7 18:48:25 CEST 2015\nThu May  7 18:48:26 CEST 2015\nThu May  7 18:48:27 CEST 2015\n1st term:Check who is accessing the file (note that there is only reader)\u2514\u2500\u2500> lsof log\nCOMMAND   PID  USER      FD   TYPE DEVICE SIZE/OFF   NODE NAME\ntail    21038  wakatana   3r   REG    8,1     5340 797966 log\nAfter Following kill the tail -f on 2nd terminal terminated and lsof returned empty output:\u2514\u2500\u2500> kill 21038\n\u2514\u2500\u2500> lsof log\n\u2514\u2500\u2500>\n2nd term:Then I started tail -f again and I saw that data was still written to log file. This means that some process is still writing to log file:\u2514\u2500\u2500> tail -f log\nThu May  7 18:52:33 CEST 2015\nThu May  7 18:52:34 CEST 2015\nThu May  7 18:52:35 CEST 2015\nThu May  7 18:52:36 CEST 2015\nThu May  7 18:52:37 CEST 2015\nThu May  7 18:52:38 CEST 2015\nThu May  7 18:52:39 CEST 2015\nThu May  7 18:52:40 CEST 2015\nIn this case I actually know the mysterious PID of process which is writing to file, it is PID 20604 so I can kill it and log file will stop growing.My questions are:\nWhy did not lsof display (even if is issued repeatedly) the process that is actually writing to\nlog file? I understand that 20604 belongs to bash and it is not bash that is writing to file directly but it's child date. But the lsof did not display neither bash nor date.\nWhat if I did not know the PID 20604? How can I track the writing process then?\nPS: The shell used: GNU bash, version 4.2.37(1)-release (x86_64-pc-linux-gnu)", "I have a problem where my Java application opens too many files. Debugging this issue, I am dependent on using lsof. \nHowever running lsof this way takes too much time (more than one minutt):lsof |grep \"java\" \nI should be able to run it using the -p option, however it \"lies\". It shows too few lines. lsof -p <PID of the java process>\nThis is my proof : lsof |grep java  | wc -l \n1510146\n\nlsof -p 802 | wc -l\n4735\nThe same happens if I use the -u option limiting to username (process owner).My system is : \nLinux 3.16.0-4-amd64 #1 SMP Debian 3.16.39-1+deb8u2 (2017-03-07) x86_64 GNU/Linux Am I missing something ?  Is there an alternative to using lsof ? ", "I have a problem where my Java application opens too many files. Debugging this issue, I am dependent on using lsof. \nHowever running lsof this way takes too much time (more than one minutt):lsof |grep \"java\" \nI should be able to run it using the -p option, however it \"lies\". It shows too few lines. lsof -p <PID of the java process>\nThis is my proof : lsof |grep java  | wc -l \n1510146\n\nlsof -p 802 | wc -l\n4735\nThe same happens if I use the -u option limiting to username (process owner).My system is : \nLinux 3.16.0-4-amd64 #1 SMP Debian 3.16.39-1+deb8u2 (2017-03-07) x86_64 GNU/Linux Am I missing something ?  Is there an alternative to using lsof ? "], "chosen": ["\nUse netstat -tulpn or ss -tulpn and look at used ports. Find app and pid that uses this port.\n", "\nThe problem is that Runtime.getRuntime().exec(...) does not know how to deal with the shell language.  On a Linux / Unix platform you would so something like this:\nProcess p = Runtime.getRuntime().exec(new String[]{\n    \"/bin/sh\", \"-c\", \"/system/bin/lsof | grep mediaserver\"});\n\nHowever, (apparently) Android doesn't have a command shell / command prompt by default.  So either you need to identify and install a suitable shell on your device, or construct the pipeline \"by hand\"; i.e. by creating a \"pipe\" file descriptor, and execing the two commands so that lsof writes to the pipe and grep reads from it.\nMaybe the answer is to run it like this ...\nProcess p = Runtime.getRuntime().exec(\n        \"adb shell /system/bin/lsof | grep mediaserver\");\n\n(Try running the \"shell ....\" part from adb interactively before doing it from Java.)\n", "\nThanks to https://unix.stackexchange.com/questions/99074/find-which-process-is-modifying-a-file\nUse auditctl -w /path/to/that/file -p wa to log file writing in /var/log/audit/audit.log\nFind some fields like ppid.\nFinally, we find who is writtng our file.\n", "\nlsof without parameter lists all open files, including files which are not using file descriptors \u2013 such as current working directories, memory mapped library files, and executable text files.\nlsof -p <PID> lists open file descriptors. A file descriptor is a data structure used by a program to get a handle on a file, the most well know being 0,1,2 for standard in, standard out, and standard error.\nSee: https://www.netadmintools.com/art295.html\n", "\nlsof is not lying.\nThe output of the command:\nlsof |grep java  | wc -l \n\nmay contain results of files or processes opened by other programs.\nThe result you are searching for is the result of the command:\nlsof -p <PID> | wc -l\n\nYou can increase the limit of opened files for the user running your java application adding this line in  /etc/security/limits.conf:\n<USER>   hard   nofile  65536\n\nyou can check the current user's limits by typing:\nsu - <USER>\nulimit -a \n\n"], "rejected": ["\nDid you try to run a docker ps -a?\nYou may have a stopped container that reserved this port.\n", "\nThe grep utility may not be installed on your device.\nYou can check it by trying the following in a console:\n> adb shell\n$ grep\ngrep: not found\n\nThe last line indicates that this command is not available.\n", "\nYou have a classic engineering problem in the form of asynchronous sampling here.\nEssentially, every long period of waiting time, a process will be very quickly spun up, write to a file, and then die.\nEntirely asynchronous to that, you run lsof which looks for open files - but only effectively at one instant in time that probably will not match when the file is being written.   (In actuality, lsof performs a multi-step operation, but there's probably only one-shot opportunity to catch any given writer).\nIt might be tempting to think that if you ran lsof enough times in a loop, you would eventually catch the writer in the act - and perhaps you will.  However, depending on how your system's scheduler and I/O functionality works, it is possible that the writing process might be so brief as that there is never any chance for another process to run during it.\nIf you want a version of this which you can catch in the act, continue to have the generation spaced in time within a parenthesized subshell, but make the writing one consistent operation:\n(while true; do date ; sleep 1; done) > log &\n\nOr, if you want to try to catch brief events, you might look at the inotify mechanism (you can view its documentation with man inotify)  Bear in mind that there is no identification of the actor, and when the actor is short lived like this you can't then go do an lsof type search to figure out who it was.\n", "\nBased on my observation, it seems that\nlsof | grep <pid> | wc -l \n\nwill give duplicate count, because every thread in the specified process will add a line, e.g. if your process have 8 threads, the result will be more than 8x the actual file count.\nOn the other hand,\nlsof -p <PID> | wc -l\n\nproduce more exact result, because each file is counted (printed) only once.\nAlthough I have not found official reference for this issue yet.\n", "\nBased on my observation, it seems that\nlsof | grep <pid> | wc -l \n\nwill give duplicate count, because every thread in the specified process will add a line, e.g. if your process have 8 threads, the result will be more than 8x the actual file count.\nOn the other hand,\nlsof -p <PID> | wc -l\n\nproduce more exact result, because each file is counted (printed) only once.\nAlthough I have not found official reference for this issue yet.\n"]}