{"prompt": ["Constraints:\n1. Speed matters.\n2. I am allowed to ping once.  I'm debating whether to use Python or shellscripting. Is there a method faster than bash?Here is the current code,for ip in $(seq int1 int2); do\n    ping -c 1 xxx.xxx.xxx.$ip | grep \"bytes from\" &\ndone\nAnything faster than this?", "Constraints:\n1. Speed matters.\n2. I am allowed to ping once.  I'm debating whether to use Python or shellscripting. Is there a method faster than bash?Here is the current code,for ip in $(seq int1 int2); do\n    ping -c 1 xxx.xxx.xxx.$ip | grep \"bytes from\" &\ndone\nAnything faster than this?", "Constraints:\n1. Speed matters.\n2. I am allowed to ping once.  I'm debating whether to use Python or shellscripting. Is there a method faster than bash?Here is the current code,for ip in $(seq int1 int2); do\n    ping -c 1 xxx.xxx.xxx.$ip | grep \"bytes from\" &\ndone\nAnything faster than this?", "Constraints:\n1. Speed matters.\n2. I am allowed to ping once.  I'm debating whether to use Python or shellscripting. Is there a method faster than bash?Here is the current code,for ip in $(seq int1 int2); do\n    ping -c 1 xxx.xxx.xxx.$ip | grep \"bytes from\" &\ndone\nAnything faster than this?", "Constraints:\n1. Speed matters.\n2. I am allowed to ping once.  I'm debating whether to use Python or shellscripting. Is there a method faster than bash?Here is the current code,for ip in $(seq int1 int2); do\n    ping -c 1 xxx.xxx.xxx.$ip | grep \"bytes from\" &\ndone\nAnything faster than this?", "Constraints:\n1. Speed matters.\n2. I am allowed to ping once.  I'm debating whether to use Python or shellscripting. Is there a method faster than bash?Here is the current code,for ip in $(seq int1 int2); do\n    ping -c 1 xxx.xxx.xxx.$ip | grep \"bytes from\" &\ndone\nAnything faster than this?", "Constraints:\n1. Speed matters.\n2. I am allowed to ping once.  I'm debating whether to use Python or shellscripting. Is there a method faster than bash?Here is the current code,for ip in $(seq int1 int2); do\n    ping -c 1 xxx.xxx.xxx.$ip | grep \"bytes from\" &\ndone\nAnything faster than this?", "Constraints:\n1. Speed matters.\n2. I am allowed to ping once.  I'm debating whether to use Python or shellscripting. Is there a method faster than bash?Here is the current code,for ip in $(seq int1 int2); do\n    ping -c 1 xxx.xxx.xxx.$ip | grep \"bytes from\" &\ndone\nAnything faster than this?", "Constraints:\n1. Speed matters.\n2. I am allowed to ping once.  I'm debating whether to use Python or shellscripting. Is there a method faster than bash?Here is the current code,for ip in $(seq int1 int2); do\n    ping -c 1 xxx.xxx.xxx.$ip | grep \"bytes from\" &\ndone\nAnything faster than this?", "i am new to Python and trying to make a script but i am kind of lost.I would like to check if IPs from text1.txt are in text2.txt.\nIf not i want to ping them and if ping is ok then i would like to add them to text3.txt.\nIf ping is not ok i want to add them to text4.txtI only did this .. that tells me if they can be pinged.#!/usr/bin/env python\n\nimport os\n\n\nfile = open(\"input.txt\",\"r+\")\n\nwith open(\"input.txt\",\"r\") as file:\n\n  for line in file:\n     response =  os.system(\"ping -c 1 \" + line)\n     if response == 0:\n        with open(\"output.txt\",\"w\") as file:\n            print(line)\n       \nIt works for me with pinging, atleast T_T .Can you suggest me how to proceed with the main idea?Just asking for some traces for me :).I want to try it alone but iam lost :-/.Thank you.", "I want to display \"Unit 1 is online\" or \"Unit 1 is offline\" based on ping test in Shell Script. However, I can't find a flag or a way to extract text from the output of the ping test so as to use it with an if-case statement to get the desired output.    read -p \"Enter the number of Units: \" x\n    for ((i=1; i<=$x; i++))\n    do\n        ping -c1 a.b.c.\"$i\"\n        if ping=success\n            echo \"Unit \"$i\" is online\"\n        else\n            echo \"Unit \"$i\" is offline\"\n        fi\n    done\n", "I have a server in AWS-East-1 (N. Virginia) and I am trying to ping www.binance.com whose server is located in AWS Tokyo.Command: ping www.binance.comI get ping times of 0.5ms which is not true. Possibly, the ping is returning from some nearby router and theoretically even at the speed of light, the return trip should take atleast 75ms.How do I measure the correct ping latency from my Linux terminal?", "I learnt from here that to specify TTL value we use-COMMAND\n\n$ ping www.google.com -t 100\n\nOUTPUT\n\nPING www.google.com (172.217.167.196) 56(84) bytes of data.\n64 bytes from del03s18-in-f4.1e100.net (172.217.167.196): icmp_seq=1 ttl=128 time=7.61 ms\n64 bytes from del03s18-in-f4.1e100.net (172.217.167.196): icmp_seq=2 ttl=128 time=6.98 ms\n64 bytes from del03s18-in-f4.1e100.net (172.217.167.196): icmp_seq=3 ttl=128 time=6.70 ms\n64 bytes from del03s18-in-f4.1e100.net (172.217.167.196): icmp_seq=4 ttl=128 time=7.37 ms\n64 bytes from del03s18-in-f4.1e100.net (172.217.167.196): icmp_seq=5 ttl=128 time=7.39 ms\n64 bytes from del03s18-in-f4.1e100.net (172.217.167.196): icmp_seq=6 ttl=128 time=13.3 ms\n64 bytes from del03s18-in-f4.1e100.net (172.217.167.196): icmp_seq=7 ttl=128 time=15.7 ms\n64 bytes from del03s18-in-f4.1e100.net (172.217.167.196): icmp_seq=8 ttl=128 time=7.56 ms\n^C\n--- www.google.com ping statistics ---\n8 packets transmitted, 8 received, 0% packet loss, time 7016ms\nrtt min/avg/max/mdev = 6.701/9.077/15.684/3.203 ms\nHere clearly the value of TTL=128 is greater than 100, then why did I not get a message saying that the has packet expired? I tried it for even smaller values like 2 and 3 but the command seems to have no effect.From my understanding 128 is the number of hops that were required for the trip to google server and back, in that case if I set the limit as 100, then the packet should expire. Even with smaller values like 2 and 3, I don't get a message saying that it expired.If my understanding is wrong, what should I do to get varying outputs when I change the TTL values?", "I want to extract from the command ping -c 4 www.stackoverflow.com | tail -1| awk '{print $4}'\n the average time.107.921/108.929/110.394/0.905 ms\nOutput should be: 108.929", "I want to extract from the command ping -c 4 www.stackoverflow.com | tail -1| awk '{print $4}'\n the average time.107.921/108.929/110.394/0.905 ms\nOutput should be: 108.929", "I want to extract from the command ping -c 4 www.stackoverflow.com | tail -1| awk '{print $4}'\n the average time.107.921/108.929/110.394/0.905 ms\nOutput should be: 108.929", "I want to extract from the command ping -c 4 www.stackoverflow.com | tail -1| awk '{print $4}'\n the average time.107.921/108.929/110.394/0.905 ms\nOutput should be: 108.929", "I want to extract from the command ping -c 4 www.stackoverflow.com | tail -1| awk '{print $4}'\n the average time.107.921/108.929/110.394/0.905 ms\nOutput should be: 108.929", "I want to extract from the command ping -c 4 www.stackoverflow.com | tail -1| awk '{print $4}'\n the average time.107.921/108.929/110.394/0.905 ms\nOutput should be: 108.929", "I want to extract from the command ping -c 4 www.stackoverflow.com | tail -1| awk '{print $4}'\n the average time.107.921/108.929/110.394/0.905 ms\nOutput should be: 108.929"], "chosen": ["\nThe following (evil) code runs more than TWICE as fast as the nmap method\nfor i in {1..254} ;do (ping 192.168.1.$i -c 1 -w 5  >/dev/null && echo \"192.168.1.$i\" &) ;done\n\ntakes around 10 seconds, where the standard nmap\nnmap -sP 192.168.1.1-254\n\ntakes 25 seconds...\n", "\nYou should use nmap:\nnmap -T5 -sn 192.168.0.0-255\nnmap -T insane -sn 192.168.0.0-255 # same as above but w/named template\n\nThe -T 5/insane option uses the \"insane\" template, which:\n\ninsane mode assumes that you are on an extraordinarily fast network or are willing to sacrifice some accuracy for speed.\n-T4 (aggressive) prohibits the dynamic scan\ndelay from exceeIf you are on a decent broadband or ethernet connection, I would recommend always using -T4. Some people love -T5 though it is too aggressive\nding 10 ms for TCP ports and -T5 (insane) caps that value at 5 ms.\nIf you are on a decent broadband or ethernet connection, I would recommend always using -T4. Some people love -T5 though it is too aggressive for my taste.\n\nThe -sn option means \"no port scan\":\n\nThis option tells Nmap not to do a port scan after host discovery, and only print out the available hosts that responded to the host discovery\nprobes. This is often known as a \u201cping scan\u201d, but you can also request that traceroute and NSE host scripts be run. This is by default one step\nmore intrusive than the list scan, and can often be used for the same purposes. It allows light reconnaissance of a target network without\nattracting much attention. Knowing how many hosts are up is more valuable to attackers than the list provided by list scan of every single IP\nand host name.\n\n", "\nTry this for a unique list.\nping -c 5 -b 10.10.0.255 | grep 'bytes from' | awk '{ print $4 }' | sort | uniq\nanother method (fetches live hosts):\nfping -ag 192.168.1.0/24\n", "\nTry both of these commands and see for yourself why arp is faster:\nPING:\nfor ip in $(seq 1 254); do ping -c 1 10.185.0.$ip > /dev/null; [ $? -eq 0 ] && echo \"10.185.0.$ip UP\" || : ; done\nARP:\nfor ip in $(seq 1 254); do arp -n 10.185.0.$ip | grep Address; [ $? -eq 0 ] && echo \"10.185.0.$ip UP\" || : ; done\n", "\nThis is python code for the ping in range of the 192.168.0.0-192.168.0.100. You can change for loop as you comfort.\n# -*- coding: utf-8 -*-\nimport socket\nimport os\nimport sys\n\nup_ip =[] #list to store the ip-addresses of server online\nfor x in range(100):  #here range is 0-100. You can change the range according to your comfort\n\n    server_ip = '192.168.0.'+ str(x)\n    print \"Trying ,server_ip,... \\n\"\n\n    rep = os.system('ping -c 1 ' + server_ip)\n\n    if rep == 0:\n        up_ip.append(server_ip)\n        print '******************* Server Is Up **************** \\n'\n    else:\n        print 'server is down \\n'\n\nprint up_ip\n\n", "\nIf time matters (and I know the feeling):\nfor i in {1..254}; do\necho -n -e \"$i      \\r\"     \ntimeout --preserve-status .2  ping -c1 -q 10.0.0.$i  &> /dev/null\n[ $? -eq 0 ]&&echo 10.0.0.$i is happy to serve to his master!\ndone # as I am\n\nThe command:\ntimeout --preserve-status .2  ping -c1 -q 10.0.0.107 &> /dev/null  ;echo $? \n\nreturns 143 with non-existing PC and 0 with existing PC and waits for the answer just and only for .2 second because TIME MATTERS! And therefore I have to look for my lost keys now.\n", "\nsubnet=\"182.17.207\"\nfun(){\n       ip=\"$subnet.$1\"\n       res=`ping -c 1 $ip | grep \"1 packets transmitted, 1 received\" | wc -l`\n       if [ $res == 1 ]\n       then\n           echo \"$ip => live\"\n       fi\n}\nfor i in $(seq 1 254)\ndo\n   fun $i &\n   sleep 0.005\ndone\nsleep 0.5\necho\n\nFast using linux fork, sleep is optional .. just to print in order.\n", "\nThis script runs on Git Bash (MINGW64) on Windows and return a messages depending of the ping result.\n#!/bin/bash\n#$1 should be something like \"19.62.55\"\n\nif [ -z \"$1\" ]\n  then\n    echo \"No identify of the network supplied, i.e. 19.62.55\"\nelse\n    ipAddress=$1\n\n    for i in {1..256} ;do \n    (\n        {\n        ping -w 5 $ipAddress.$i ; \n        result=$(echo $?);\n        } &> /dev/null\n\n\n        if [ $result = 0 ]; then\n            echo Successful Ping From : $ipAddress.$i\n        else\n            echo Failed Ping From : $ipAddress.$i\n        fi &);\n    done\n\nfi\n\n", "\nBSD's\nfor i in $(seq 1 254); do (ping -c1 -W5 192.168.1.$i >/dev/null && echo \"192.168.1.$i\" &) ;done\n", "\nHere is a basic code which will work for you.\nI hope it solves your problem.\n#!/usr/bin/env python\n\nimport os\n\n# Creat a empty list to get contents of text2.txt\nlines = []\n\n# Load contents of text2 file in the list for comparison. (Not memory-efficient)\nwith open(\"/path/to/text2.txt\") as file:\n    lines = [line.strip() for line in file]\n\n\n# Ping each IP from input file (text1) \nwith open(\"/path/to/text1.txt\",\"r\") as input_file:\n   for line in input_file:\n      if line not in lines:\n         response =  os.system(\"ping -c 1 \" + line)\n         if response == 0:\n            with open(\"/path/to/text3.txt\", mode='a') as out_file:\n               out_file.write(line)\n         else:\n            with open(\"/path/to/text4.txt\", mode='a') as out_file:\n               out_file.write(line)\n\n", "\nMaybe this can help you, to handle your stuff. In the below example, I am performing a reboot of the system if the target is unreachable.\n#!/bin/bash\n\n# Set target host IP or hostname\nTARGET_HOST='10.8.0.1'\n\ncount=$(ping -c 3 $TARGET_HOST | grep from* | wc -l)\n\nif [ $count -eq 0 ]; then\n    echo \"$(date)\" \"Target host\" $TARGET_HOST \"unreachable, Rebooting!\" >>/var/log/openvpn_connection_check.log\n    /sbin/shutdown -r 0\n\nelse\n    echo \"$(date) ===-> OK! \" >>/var/log/openvpn_connection_check.log\nfi\n\n", "\nAssuming you need to make this test to check performance of application or network.......\nMaybe, you can use other approach:\ncurl -o /dev/null -s -w '%{time_connect}\\n' https://www.binance.com\n\nIt will return the time_connect so maybe it can help you in your analysis.\n", "\n1.the TTL is not a time unit, is a hop unit.\n2.the ping prints the TTL value from the packet it receives.\nas the man page describe:\nTTL DETAILS\nThe TTL value of an IP packet represents the maximum number of IP routers that the packet can go through before being thrown away.  In current practice you can expect each router  in  the Internet to decrement the TTL field by exactly one.\n       The TCP/IP specification states that the TTL field for TCP packets should be set to 60, but many systems use smaller values (4.3 BSD uses 30, 4.2 used 15).\n\n       The  maximum  possible value of this field is 255, and most Unix systems set the TTL field of ICMP ECHO_REQUEST packets to 255.  This is why you will find you can ``ping'' some hosts, but not reach them with telnet(1) or ftp(1).\n\n       In normal operation ping prints the TTL value from the packet it receives.  When a remote system receives a ping packet, it can do one of three things with the TTL field in its response:\n\n       \u00b7 Not change it; this is what Berkeley Unix systems did before the 4.3BSD Tahoe release. In this case the TTL value in the received packet will be 255 minus the number of routers  in  the round-trip path.\n\n       \u00b7 Set it to 255; this is what current Berkeley Unix systems do.  In this case the TTL value in the received packet will be 255 minus the number of routers in the path from the remote system to the pinging host.\n\n       \u00b7 Set it to some other value. Some machines use the same value for ICMP packets that they use for TCP packets, for example either 30 or 60.  Others may use completely wild values.\n\n", "\nping -c 4 www.stackoverflow.com | tail -1| awk -F '/' '{print $5}'  would work fine.\n\"-F\" option is used to specify the field separator.\n", "\nOne way is to just add a cut to what you have there.\nping -c 4 www.stackoverflow.com | tail -1| awk '{print $4}' | cut -d '/' -f 2\n\n", "\nThis might work for you:\nping -c 4 www.stackoverflow.com | sed '$!d;s|.*/\\([0-9.]*\\)/.*|\\1|'\n\n", "\nThe following solution uses Bash only (requires Bash 3):\n[[ $(ping -q -c 4 www.example.com) =~ \\ =\\ [^/]*/([0-9]+\\.[0-9]+).*ms ]] \\\n&& echo ${BASH_REMATCH[1]}\n\nFor the regular expression it's easier to read (and handle) if it is stored in a variable:\nregex='= [^/]*/([0-9]+\\.[0-9]+).*ms'\n[[ $(ping -q -c 4 www.example.com) =~ $regex ]] && echo ${BASH_REMATCH[1]}\n\n", "\nPromoting luissquall's very elegent comment to an answer:\n ping -c 4 www.stackoverflow.com | awk -F '/' 'END {print $5}'\n\n", "\nDirect extract mean time from ping command:\nping -w 4 -q www.duckduckgo.com  | cut -d \"/\" -s -f5\n\nOptions:\n-w time out 4 seconds\n-q quite mode\n-d delimiter \n-s skip line without delimiter\n-f No. of field - depends on your system - sometimes 5th, sometimes 4th\n\nI personly use is this way:\nif [ $(ping -w 2 -q www.duckduckgo.com | cut -d \"/\" -s -f4 | cut -d \".\" -f1) -lt 20 ]; then\n echo \"good response time\"\nelse \n echo \"bad response time\"\nfi\n\n", "\nUse these to get current ping as a single number:\n123.456: \nping -w1 -c1 8.8.8.8 | tail -1| cut -d '=' -f 2 | cut -d '/' -f 2\n123: \nping -w1 -c1 8.8.8.8 | tail -1| cut -d '=' -f 2 | cut -d '/' -f 2 | cut -d '.' -f 1\nNote that this displays the average of only 1 ping (-c1), you can increase the sample size by increasing this number (i.e. -c1337)\nThis avoids using awk (like @Buggabill posted), which doesn't play nice in bash aliases + takes a nanosecond longer\n"], "rejected": ["\nI really like the original reply but it did not give me the sequential sequence I was looking for.\nI approached this a little different and it works great:\nfor ip in {int1..int2} \ndo\n    ping -c 1 xxx.xxx.xxx.$ip | grep \"bytes from\"\ndone\n\n", "\nI really like the original reply but it did not give me the sequential sequence I was looking for.\nI approached this a little different and it works great:\nfor ip in {int1..int2} \ndo\n    ping -c 1 xxx.xxx.xxx.$ip | grep \"bytes from\"\ndone\n\n", "\nI really like the original reply but it did not give me the sequential sequence I was looking for.\nI approached this a little different and it works great:\nfor ip in {int1..int2} \ndo\n    ping -c 1 xxx.xxx.xxx.$ip | grep \"bytes from\"\ndone\n\n", "\nI really like the original reply but it did not give me the sequential sequence I was looking for.\nI approached this a little different and it works great:\nfor ip in {int1..int2} \ndo\n    ping -c 1 xxx.xxx.xxx.$ip | grep \"bytes from\"\ndone\n\n", "\nI really like the original reply but it did not give me the sequential sequence I was looking for.\nI approached this a little different and it works great:\nfor ip in {int1..int2} \ndo\n    ping -c 1 xxx.xxx.xxx.$ip | grep \"bytes from\"\ndone\n\n", "\nI really like the original reply but it did not give me the sequential sequence I was looking for.\nI approached this a little different and it works great:\nfor ip in {int1..int2} \ndo\n    ping -c 1 xxx.xxx.xxx.$ip | grep \"bytes from\"\ndone\n\n", "\nI really like the original reply but it did not give me the sequential sequence I was looking for.\nI approached this a little different and it works great:\nfor ip in {int1..int2} \ndo\n    ping -c 1 xxx.xxx.xxx.$ip | grep \"bytes from\"\ndone\n\n", "\nI really like the original reply but it did not give me the sequential sequence I was looking for.\nI approached this a little different and it works great:\nfor ip in {int1..int2} \ndo\n    ping -c 1 xxx.xxx.xxx.$ip | grep \"bytes from\"\ndone\n\n", "\nI really like the original reply but it did not give me the sequential sequence I was looking for.\nI approached this a little different and it works great:\nfor ip in {int1..int2} \ndo\n    ping -c 1 xxx.xxx.xxx.$ip | grep \"bytes from\"\ndone\n\n", "\nHere's the corrected version of your code.\nYou only need to open the file once\nYou need to open the destination file in append mode an with another name than the reading one\nYou neeed to actually write into the output file\nimport os\n\nwith open(\"input.txt\", \"r\") as file:\n    for line in file:\n        response =  os.system(\"ping -c 1 \" + line)\n        if response == 0:\n            with open(\"output.txt\", \"a\") as out:\n                out.write(line)\n\n", "\nIf you are using the standard GNU/Linux ping tool, then the manual states:\n\nIf ping does not receive any reply packets at all it will exit with code 1. If a packet count and deadline are both specified, and fewer than count packets are received by the time the deadline has arrived, it will also exit with code 1. On other error it exits with code 2. Otherwise it exits with code 0. This makes it possible to use the exit code to see if a host is alive or not.\n\nThis means you can capture the exit code from the command in the shell and switch on that. For bash:\nif ping -c1 192.168.1.\"$i\" ; then\n    echo \"Unit ${i} is online\"\nelse\n    echo \"Unit ${i} is offline\"\nfi\n\nOr as a one-liner using || and &&:\nping -c 192.168.1.\"$i\" && echo \"Unit ${i} is online\" || echo \"Unit ${i} is offline\"\n\n", "\nI recommend you to measure a round trip delay. It is the delay between the time when your network node request packet is sent and a time when the response packet from remote server arrives back to you. It can be measured by the Wireshark network analyzer. It analyzes a real traffic. The results are more accurate then from the ICMP protocol (ping) tests.\nWireshark usage\n\nEnsure you have not opened any connection to your destination server (e.g. www.binance.com). Check all tabs in your web browser(s).\nFind out the IP address of your destination server: dig +short www.binance.com and note all found addresses.\nInstall the Wireshark application if it is not installed.\nStart the Wireshark, select correct interface on which the network data will be captured and start the capturing.\nOpen the IP address of page you will measure e.g. 65.9.96.71 in the browser. Refresh the page. It is not problem if error is displayed in browser.\nStop the capturing in Wireshark.\nPut a filter string to the display filter field of the Wireshark. (See below for filter examples.) Press Enter. Only packets which have selected IP address will be displayed.\nWatch the packet times in second column. Calculate the delay between the request packet and the response one.\n\nWireshark display filters (each line is one example):\nip.addr==65.9.96.71\nip.addr==65.9.96.30 and tcp.port==80\nip.addr==65.9.96.30 and tcp.port==443\n\nNote:\nThe Wireshark installation in Linux requires some special steps. Confirm you agree that the Wireshark can be used by all users in system. Add your user to the wireshark group and re-login to apply new user setting.\nusermod -aG wireshark <your_user>\n\nAdditional information\nYou can trace the network path between your client and remote server by traceroute. It shows you what nodes (routers) are there.\nVerify in which country the destination IP address is situated. Use some IP Whois web page to get details. https://ipwhois.io/\n", "\nmy os is centOS 7.9\nthis is my test:\n[root@test1 ~]# ping www.stackoverflow.com -c 4\nPING stackoverflow.com (151.101.65.69) 56(84) bytes of data.\n64 bytes from 151.101.65.69 (151.101.65.69): icmp_seq=1 ttl=49 time=83.0 ms\n64 bytes from 151.101.65.69 (151.101.65.69): icmp_seq=2 ttl=49 time=82.4 ms\n64 bytes from 151.101.65.69 (151.101.65.69): icmp_seq=3 ttl=49 time=83.0 ms\n64 bytes from 151.101.65.69 (151.101.65.69): icmp_seq=4 ttl=49 time=81.7 ms\n\n--- stackoverflow.com ping statistics ---\n4 packets transmitted, 4 received, 0% packet loss, time 3004ms\nrtt min/avg/max/mdev = 81.791/82.593/83.068/0.595 ms\n[root@test1 ~]# ping www.stackoverflow.com -c 4 -t 4\nPING stackoverflow.com (151.101.65.69) 56(84) bytes of data.\nFrom 100.110.4.46 (100.110.4.46) icmp_seq=1 Time to live exceeded\nFrom 100.110.4.46 (100.110.4.46) icmp_seq=2 Time to live exceeded\nFrom 100.110.4.46 (100.110.4.46) icmp_seq=3 Time to live exceeded\nFrom 100.110.4.46 (100.110.4.46) icmp_seq=4 Time to live exceeded\n\n--- stackoverflow.com ping statistics ---\n4 packets transmitted, 0 received, +4 errors, 100% packet loss, time 3005ms\n\n", "\nNone of these worked well for me due to various issues such as when a timeout occurs. I only wanted to see bad ping times or timeouts and wanted PING to continue quickly, and none of these solutions worked. Here's my BASH script that works well to do both. Note that in the ping command, response time is limited to 1 second.\nI realize this does not directly answer the OP's question, however it does provide a good way to deal with some issues that occur with some of the incomplete \"solutions\" provided here, thus going beyond the scope of the OPs question, which others coming here are looking for (I cite myself as an example), so I decided to share for those people, not specifically OP's question.\nwhile true\ndo\n###Set your IP amd max milliseconds###\n  ip=\"192.168.1.53\"\n  maxms=50\n###do not edit below###\n  err=\"100% packet loss\"\n  out=\"$(ping -c 1 -i 1 -w 1 $ip)\"\n  t=\"$(echo $out | awk -F '/' 'END {print $5}')\"\n  t=${t%.*}\n  re='^[0-9]+$'\n\n  if ! [[ $t =~ $re ]] ; then\n    if [[ $out == *\"$err\"* ]] ; then\n      echo \"`date` | ${ip}: TIMEOUT\"\n    else \n      echo \"error: Not a number: ${t} was found in: ${out}\"\n    fi\n  else\n    if [ \"$t\" -gt $maxms ]; then\n      echo \"`date` | ${ip}: ${t} ms\"\n    fi\n  fi\ndone\n\n", "\nNone of these worked well for me due to various issues such as when a timeout occurs. I only wanted to see bad ping times or timeouts and wanted PING to continue quickly, and none of these solutions worked. Here's my BASH script that works well to do both. Note that in the ping command, response time is limited to 1 second.\nI realize this does not directly answer the OP's question, however it does provide a good way to deal with some issues that occur with some of the incomplete \"solutions\" provided here, thus going beyond the scope of the OPs question, which others coming here are looking for (I cite myself as an example), so I decided to share for those people, not specifically OP's question.\nwhile true\ndo\n###Set your IP amd max milliseconds###\n  ip=\"192.168.1.53\"\n  maxms=50\n###do not edit below###\n  err=\"100% packet loss\"\n  out=\"$(ping -c 1 -i 1 -w 1 $ip)\"\n  t=\"$(echo $out | awk -F '/' 'END {print $5}')\"\n  t=${t%.*}\n  re='^[0-9]+$'\n\n  if ! [[ $t =~ $re ]] ; then\n    if [[ $out == *\"$err\"* ]] ; then\n      echo \"`date` | ${ip}: TIMEOUT\"\n    else \n      echo \"error: Not a number: ${t} was found in: ${out}\"\n    fi\n  else\n    if [ \"$t\" -gt $maxms ]; then\n      echo \"`date` | ${ip}: ${t} ms\"\n    fi\n  fi\ndone\n\n", "\nNone of these worked well for me due to various issues such as when a timeout occurs. I only wanted to see bad ping times or timeouts and wanted PING to continue quickly, and none of these solutions worked. Here's my BASH script that works well to do both. Note that in the ping command, response time is limited to 1 second.\nI realize this does not directly answer the OP's question, however it does provide a good way to deal with some issues that occur with some of the incomplete \"solutions\" provided here, thus going beyond the scope of the OPs question, which others coming here are looking for (I cite myself as an example), so I decided to share for those people, not specifically OP's question.\nwhile true\ndo\n###Set your IP amd max milliseconds###\n  ip=\"192.168.1.53\"\n  maxms=50\n###do not edit below###\n  err=\"100% packet loss\"\n  out=\"$(ping -c 1 -i 1 -w 1 $ip)\"\n  t=\"$(echo $out | awk -F '/' 'END {print $5}')\"\n  t=${t%.*}\n  re='^[0-9]+$'\n\n  if ! [[ $t =~ $re ]] ; then\n    if [[ $out == *\"$err\"* ]] ; then\n      echo \"`date` | ${ip}: TIMEOUT\"\n    else \n      echo \"error: Not a number: ${t} was found in: ${out}\"\n    fi\n  else\n    if [ \"$t\" -gt $maxms ]; then\n      echo \"`date` | ${ip}: ${t} ms\"\n    fi\n  fi\ndone\n\n", "\nNone of these worked well for me due to various issues such as when a timeout occurs. I only wanted to see bad ping times or timeouts and wanted PING to continue quickly, and none of these solutions worked. Here's my BASH script that works well to do both. Note that in the ping command, response time is limited to 1 second.\nI realize this does not directly answer the OP's question, however it does provide a good way to deal with some issues that occur with some of the incomplete \"solutions\" provided here, thus going beyond the scope of the OPs question, which others coming here are looking for (I cite myself as an example), so I decided to share for those people, not specifically OP's question.\nwhile true\ndo\n###Set your IP amd max milliseconds###\n  ip=\"192.168.1.53\"\n  maxms=50\n###do not edit below###\n  err=\"100% packet loss\"\n  out=\"$(ping -c 1 -i 1 -w 1 $ip)\"\n  t=\"$(echo $out | awk -F '/' 'END {print $5}')\"\n  t=${t%.*}\n  re='^[0-9]+$'\n\n  if ! [[ $t =~ $re ]] ; then\n    if [[ $out == *\"$err\"* ]] ; then\n      echo \"`date` | ${ip}: TIMEOUT\"\n    else \n      echo \"error: Not a number: ${t} was found in: ${out}\"\n    fi\n  else\n    if [ \"$t\" -gt $maxms ]; then\n      echo \"`date` | ${ip}: ${t} ms\"\n    fi\n  fi\ndone\n\n", "\nNone of these worked well for me due to various issues such as when a timeout occurs. I only wanted to see bad ping times or timeouts and wanted PING to continue quickly, and none of these solutions worked. Here's my BASH script that works well to do both. Note that in the ping command, response time is limited to 1 second.\nI realize this does not directly answer the OP's question, however it does provide a good way to deal with some issues that occur with some of the incomplete \"solutions\" provided here, thus going beyond the scope of the OPs question, which others coming here are looking for (I cite myself as an example), so I decided to share for those people, not specifically OP's question.\nwhile true\ndo\n###Set your IP amd max milliseconds###\n  ip=\"192.168.1.53\"\n  maxms=50\n###do not edit below###\n  err=\"100% packet loss\"\n  out=\"$(ping -c 1 -i 1 -w 1 $ip)\"\n  t=\"$(echo $out | awk -F '/' 'END {print $5}')\"\n  t=${t%.*}\n  re='^[0-9]+$'\n\n  if ! [[ $t =~ $re ]] ; then\n    if [[ $out == *\"$err\"* ]] ; then\n      echo \"`date` | ${ip}: TIMEOUT\"\n    else \n      echo \"error: Not a number: ${t} was found in: ${out}\"\n    fi\n  else\n    if [ \"$t\" -gt $maxms ]; then\n      echo \"`date` | ${ip}: ${t} ms\"\n    fi\n  fi\ndone\n\n", "\nNone of these worked well for me due to various issues such as when a timeout occurs. I only wanted to see bad ping times or timeouts and wanted PING to continue quickly, and none of these solutions worked. Here's my BASH script that works well to do both. Note that in the ping command, response time is limited to 1 second.\nI realize this does not directly answer the OP's question, however it does provide a good way to deal with some issues that occur with some of the incomplete \"solutions\" provided here, thus going beyond the scope of the OPs question, which others coming here are looking for (I cite myself as an example), so I decided to share for those people, not specifically OP's question.\nwhile true\ndo\n###Set your IP amd max milliseconds###\n  ip=\"192.168.1.53\"\n  maxms=50\n###do not edit below###\n  err=\"100% packet loss\"\n  out=\"$(ping -c 1 -i 1 -w 1 $ip)\"\n  t=\"$(echo $out | awk -F '/' 'END {print $5}')\"\n  t=${t%.*}\n  re='^[0-9]+$'\n\n  if ! [[ $t =~ $re ]] ; then\n    if [[ $out == *\"$err\"* ]] ; then\n      echo \"`date` | ${ip}: TIMEOUT\"\n    else \n      echo \"error: Not a number: ${t} was found in: ${out}\"\n    fi\n  else\n    if [ \"$t\" -gt $maxms ]; then\n      echo \"`date` | ${ip}: ${t} ms\"\n    fi\n  fi\ndone\n\n", "\nNone of these worked well for me due to various issues such as when a timeout occurs. I only wanted to see bad ping times or timeouts and wanted PING to continue quickly, and none of these solutions worked. Here's my BASH script that works well to do both. Note that in the ping command, response time is limited to 1 second.\nI realize this does not directly answer the OP's question, however it does provide a good way to deal with some issues that occur with some of the incomplete \"solutions\" provided here, thus going beyond the scope of the OPs question, which others coming here are looking for (I cite myself as an example), so I decided to share for those people, not specifically OP's question.\nwhile true\ndo\n###Set your IP amd max milliseconds###\n  ip=\"192.168.1.53\"\n  maxms=50\n###do not edit below###\n  err=\"100% packet loss\"\n  out=\"$(ping -c 1 -i 1 -w 1 $ip)\"\n  t=\"$(echo $out | awk -F '/' 'END {print $5}')\"\n  t=${t%.*}\n  re='^[0-9]+$'\n\n  if ! [[ $t =~ $re ]] ; then\n    if [[ $out == *\"$err\"* ]] ; then\n      echo \"`date` | ${ip}: TIMEOUT\"\n    else \n      echo \"error: Not a number: ${t} was found in: ${out}\"\n    fi\n  else\n    if [ \"$t\" -gt $maxms ]; then\n      echo \"`date` | ${ip}: ${t} ms\"\n    fi\n  fi\ndone\n\n"]}