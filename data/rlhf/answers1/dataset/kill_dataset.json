{"prompt": ["The child process is started withsubprocess.Popen(arg)\nIs there a way to ensure it is killed when parent terminates abnormally? I need this to work both on Windows and Linux. I am aware of this solution for Linux.Edit:the requirement of starting a child process with subprocess.Popen(arg) can be relaxed, if a solution exists using a different method of starting a process.", "The child process is started withsubprocess.Popen(arg)\nIs there a way to ensure it is killed when parent terminates abnormally? I need this to work both on Windows and Linux. I am aware of this solution for Linux.Edit:the requirement of starting a child process with subprocess.Popen(arg) can be relaxed, if a solution exists using a different method of starting a process.", "The child process is started withsubprocess.Popen(arg)\nIs there a way to ensure it is killed when parent terminates abnormally? I need this to work both on Windows and Linux. I am aware of this solution for Linux.Edit:the requirement of starting a child process with subprocess.Popen(arg) can be relaxed, if a solution exists using a different method of starting a process.", "The child process is started withsubprocess.Popen(arg)\nIs there a way to ensure it is killed when parent terminates abnormally? I need this to work both on Windows and Linux. I am aware of this solution for Linux.Edit:the requirement of starting a child process with subprocess.Popen(arg) can be relaxed, if a solution exists using a different method of starting a process.", "while i want to active mongo on linux i get this error and it and it wont work$ sudo systemctl status mongod\u25cf mongod.service - MongoDB Database Server\nLoaded: loaded (/lib/systemd/system/mongod.service; enabled; vendor preset: disabled)\nActive: failed (Result: signal) since Sun 2021-08-01 13:39:18 +03; 47s ago\nDocs: https://docs.mongodb.org/manual\nProcess: 12854 ExecStart=/usr/bin/mongod --config /etc/mongod.conf (code=killed, signal=ILL)\nMain PID: 12854 (code=killed, signal=ILL)\nCPU: 19msAug 01 13:39:18 jr systemd[1]: Started MongoDB Database Server.\nAug 01 13:39:18 jr systemd[1]: mongod.service: Main process exited, code=killed, status=4/ILL\nAug 01 13:39:18 jr systemd[1]: mongod.service: Failed with result 'signal'.and while i type mongod\nit say$ mongod\nzsh: illegal hardware instruction  mongod", "while i want to active mongo on linux i get this error and it and it wont work$ sudo systemctl status mongod\u25cf mongod.service - MongoDB Database Server\nLoaded: loaded (/lib/systemd/system/mongod.service; enabled; vendor preset: disabled)\nActive: failed (Result: signal) since Sun 2021-08-01 13:39:18 +03; 47s ago\nDocs: https://docs.mongodb.org/manual\nProcess: 12854 ExecStart=/usr/bin/mongod --config /etc/mongod.conf (code=killed, signal=ILL)\nMain PID: 12854 (code=killed, signal=ILL)\nCPU: 19msAug 01 13:39:18 jr systemd[1]: Started MongoDB Database Server.\nAug 01 13:39:18 jr systemd[1]: mongod.service: Main process exited, code=killed, status=4/ILL\nAug 01 13:39:18 jr systemd[1]: mongod.service: Failed with result 'signal'.and while i type mongod\nit say$ mongod\nzsh: illegal hardware instruction  mongod", "while i want to active mongo on linux i get this error and it and it wont work$ sudo systemctl status mongod\u25cf mongod.service - MongoDB Database Server\nLoaded: loaded (/lib/systemd/system/mongod.service; enabled; vendor preset: disabled)\nActive: failed (Result: signal) since Sun 2021-08-01 13:39:18 +03; 47s ago\nDocs: https://docs.mongodb.org/manual\nProcess: 12854 ExecStart=/usr/bin/mongod --config /etc/mongod.conf (code=killed, signal=ILL)\nMain PID: 12854 (code=killed, signal=ILL)\nCPU: 19msAug 01 13:39:18 jr systemd[1]: Started MongoDB Database Server.\nAug 01 13:39:18 jr systemd[1]: mongod.service: Main process exited, code=killed, status=4/ILL\nAug 01 13:39:18 jr systemd[1]: mongod.service: Failed with result 'signal'.and while i type mongod\nit say$ mongod\nzsh: illegal hardware instruction  mongod", "I have centos image in virtualbox. When I do curl [url] | tee -a [file] where [url] is the url for a large file, the system start to kill all new proccesses and I get Killed answer in console for any command but kill and cd. How can I disable OOM daemon?", "I have centos image in virtualbox. When I do curl [url] | tee -a [file] where [url] is the url for a large file, the system start to kill all new proccesses and I get Killed answer in console for any command but kill and cd. How can I disable OOM daemon?", "How do I kill the last spawned background task in Linux?Example:doSomething\ndoAnotherThing\ndoB &\ndoC\ndoD\n#kill doB\n????\n", "How do I kill the last spawned background task in Linux?Example:doSomething\ndoAnotherThing\ndoB &\ndoC\ndoD\n#kill doB\n????\n", "How do I kill the last spawned background task in Linux?Example:doSomething\ndoAnotherThing\ndoB &\ndoC\ndoD\n#kill doB\n????\n", "How do I kill the last spawned background task in Linux?Example:doSomething\ndoAnotherThing\ndoB &\ndoC\ndoD\n#kill doB\n????\n", "How do I kill the last spawned background task in Linux?Example:doSomething\ndoAnotherThing\ndoB &\ndoC\ndoD\n#kill doB\n????\n", "How do I kill the last spawned background task in Linux?Example:doSomething\ndoAnotherThing\ndoB &\ndoC\ndoD\n#kill doB\n????\n", "How do I kill the last spawned background task in Linux?Example:doSomething\ndoAnotherThing\ndoB &\ndoC\ndoD\n#kill doB\n????\n", "When I want to kill a process using the pid in linux, its subprocess still existes. I hope to kill all process using one command.", "My application runs as a background process on Linux. It is currently started at the command line in a Terminal window.Recently a user was executing the application for a while and it died mysteriously. The text:\nKilled\nwas on the terminal. This happened two times. I asked if someone at a different Terminal used the kill command to kill the process? No.Under what conditions would Linux decide to kill my process?  I believe the shell displayed \"killed\" because the process died after receiving the kill(9) signal.  If Linux sent the kill signal should there be a message in a system log somewhere that explains why it was killed?", "My application runs as a background process on Linux. It is currently started at the command line in a Terminal window.Recently a user was executing the application for a while and it died mysteriously. The text:\nKilled\nwas on the terminal. This happened two times. I asked if someone at a different Terminal used the kill command to kill the process? No.Under what conditions would Linux decide to kill my process?  I believe the shell displayed \"killed\" because the process died after receiving the kill(9) signal.  If Linux sent the kill signal should there be a message in a system log somewhere that explains why it was killed?", "My application runs as a background process on Linux. It is currently started at the command line in a Terminal window.Recently a user was executing the application for a while and it died mysteriously. The text:\nKilled\nwas on the terminal. This happened two times. I asked if someone at a different Terminal used the kill command to kill the process? No.Under what conditions would Linux decide to kill my process?  I believe the shell displayed \"killed\" because the process died after receiving the kill(9) signal.  If Linux sent the kill signal should there be a message in a system log somewhere that explains why it was killed?", "My application runs as a background process on Linux. It is currently started at the command line in a Terminal window.Recently a user was executing the application for a while and it died mysteriously. The text:\nKilled\nwas on the terminal. This happened two times. I asked if someone at a different Terminal used the kill command to kill the process? No.Under what conditions would Linux decide to kill my process?  I believe the shell displayed \"killed\" because the process died after receiving the kill(9) signal.  If Linux sent the kill signal should there be a message in a system log somewhere that explains why it was killed?", "My application runs as a background process on Linux. It is currently started at the command line in a Terminal window.Recently a user was executing the application for a while and it died mysteriously. The text:\nKilled\nwas on the terminal. This happened two times. I asked if someone at a different Terminal used the kill command to kill the process? No.Under what conditions would Linux decide to kill my process?  I believe the shell displayed \"killed\" because the process died after receiving the kill(9) signal.  If Linux sent the kill signal should there be a message in a system log somewhere that explains why it was killed?", "My application runs as a background process on Linux. It is currently started at the command line in a Terminal window.Recently a user was executing the application for a while and it died mysteriously. The text:\nKilled\nwas on the terminal. This happened two times. I asked if someone at a different Terminal used the kill command to kill the process? No.Under what conditions would Linux decide to kill my process?  I believe the shell displayed \"killed\" because the process died after receiving the kill(9) signal.  If Linux sent the kill signal should there be a message in a system log somewhere that explains why it was killed?", "My application runs as a background process on Linux. It is currently started at the command line in a Terminal window.Recently a user was executing the application for a while and it died mysteriously. The text:\nKilled\nwas on the terminal. This happened two times. I asked if someone at a different Terminal used the kill command to kill the process? No.Under what conditions would Linux decide to kill my process?  I believe the shell displayed \"killed\" because the process died after receiving the kill(9) signal.  If Linux sent the kill signal should there be a message in a system log somewhere that explains why it was killed?", "My application runs as a background process on Linux. It is currently started at the command line in a Terminal window.Recently a user was executing the application for a while and it died mysteriously. The text:\nKilled\nwas on the terminal. This happened two times. I asked if someone at a different Terminal used the kill command to kill the process? No.Under what conditions would Linux decide to kill my process?  I believe the shell displayed \"killed\" because the process died after receiving the kill(9) signal.  If Linux sent the kill signal should there be a message in a system log somewhere that explains why it was killed?", "My application runs as a background process on Linux. It is currently started at the command line in a Terminal window.Recently a user was executing the application for a while and it died mysteriously. The text:\nKilled\nwas on the terminal. This happened two times. I asked if someone at a different Terminal used the kill command to kill the process? No.Under what conditions would Linux decide to kill my process?  I believe the shell displayed \"killed\" because the process died after receiving the kill(9) signal.  If Linux sent the kill signal should there be a message in a system log somewhere that explains why it was killed?", "My application runs as a background process on Linux. It is currently started at the command line in a Terminal window.Recently a user was executing the application for a while and it died mysteriously. The text:\nKilled\nwas on the terminal. This happened two times. I asked if someone at a different Terminal used the kill command to kill the process? No.Under what conditions would Linux decide to kill my process?  I believe the shell displayed \"killed\" because the process died after receiving the kill(9) signal.  If Linux sent the kill signal should there be a message in a system log somewhere that explains why it was killed?", "My application runs as a background process on Linux. It is currently started at the command line in a Terminal window.Recently a user was executing the application for a while and it died mysteriously. The text:\nKilled\nwas on the terminal. This happened two times. I asked if someone at a different Terminal used the kill command to kill the process? No.Under what conditions would Linux decide to kill my process?  I believe the shell displayed \"killed\" because the process died after receiving the kill(9) signal.  If Linux sent the kill signal should there be a message in a system log somewhere that explains why it was killed?", "My application runs as a background process on Linux. It is currently started at the command line in a Terminal window.Recently a user was executing the application for a while and it died mysteriously. The text:\nKilled\nwas on the terminal. This happened two times. I asked if someone at a different Terminal used the kill command to kill the process? No.Under what conditions would Linux decide to kill my process?  I believe the shell displayed \"killed\" because the process died after receiving the kill(9) signal.  If Linux sent the kill signal should there be a message in a system log somewhere that explains why it was killed?", "Sometimes when I try to start Firefox it says \"a Firefox process is already running\". So I have to do this:jeremy@jeremy-desktop:~$ ps aux | grep firefox\njeremy    7451 25.0 27.4 170536 65680 ?        Sl   22:39   1:18 /usr/lib/firefox-3.0.1/firefox\njeremy    7578  0.0  0.3   3004   768 pts/0    S+   22:44   0:00 grep firefox\njeremy@jeremy-desktop:~$ kill 7451\nWhat I'd like is a command that would do all that for me. It would take an input string and grep for it (or whatever) in the list of processes, and would kill all the processes in the output:jeremy@jeremy-desktop:~$ killbyname firefox\nI tried doing it in PHP but exec('ps aux') seems to only show processes that have been executed with exec() in the PHP script itself (so the only process it shows is itself.)", "Sometimes when I try to start Firefox it says \"a Firefox process is already running\". So I have to do this:jeremy@jeremy-desktop:~$ ps aux | grep firefox\njeremy    7451 25.0 27.4 170536 65680 ?        Sl   22:39   1:18 /usr/lib/firefox-3.0.1/firefox\njeremy    7578  0.0  0.3   3004   768 pts/0    S+   22:44   0:00 grep firefox\njeremy@jeremy-desktop:~$ kill 7451\nWhat I'd like is a command that would do all that for me. It would take an input string and grep for it (or whatever) in the list of processes, and would kill all the processes in the output:jeremy@jeremy-desktop:~$ killbyname firefox\nI tried doing it in PHP but exec('ps aux') seems to only show processes that have been executed with exec() in the PHP script itself (so the only process it shows is itself.)", "Sometimes when I try to start Firefox it says \"a Firefox process is already running\". So I have to do this:jeremy@jeremy-desktop:~$ ps aux | grep firefox\njeremy    7451 25.0 27.4 170536 65680 ?        Sl   22:39   1:18 /usr/lib/firefox-3.0.1/firefox\njeremy    7578  0.0  0.3   3004   768 pts/0    S+   22:44   0:00 grep firefox\njeremy@jeremy-desktop:~$ kill 7451\nWhat I'd like is a command that would do all that for me. It would take an input string and grep for it (or whatever) in the list of processes, and would kill all the processes in the output:jeremy@jeremy-desktop:~$ killbyname firefox\nI tried doing it in PHP but exec('ps aux') seems to only show processes that have been executed with exec() in the PHP script itself (so the only process it shows is itself.)", "Sometimes when I try to start Firefox it says \"a Firefox process is already running\". So I have to do this:jeremy@jeremy-desktop:~$ ps aux | grep firefox\njeremy    7451 25.0 27.4 170536 65680 ?        Sl   22:39   1:18 /usr/lib/firefox-3.0.1/firefox\njeremy    7578  0.0  0.3   3004   768 pts/0    S+   22:44   0:00 grep firefox\njeremy@jeremy-desktop:~$ kill 7451\nWhat I'd like is a command that would do all that for me. It would take an input string and grep for it (or whatever) in the list of processes, and would kill all the processes in the output:jeremy@jeremy-desktop:~$ killbyname firefox\nI tried doing it in PHP but exec('ps aux') seems to only show processes that have been executed with exec() in the PHP script itself (so the only process it shows is itself.)", "Sometimes when I try to start Firefox it says \"a Firefox process is already running\". So I have to do this:jeremy@jeremy-desktop:~$ ps aux | grep firefox\njeremy    7451 25.0 27.4 170536 65680 ?        Sl   22:39   1:18 /usr/lib/firefox-3.0.1/firefox\njeremy    7578  0.0  0.3   3004   768 pts/0    S+   22:44   0:00 grep firefox\njeremy@jeremy-desktop:~$ kill 7451\nWhat I'd like is a command that would do all that for me. It would take an input string and grep for it (or whatever) in the list of processes, and would kill all the processes in the output:jeremy@jeremy-desktop:~$ killbyname firefox\nI tried doing it in PHP but exec('ps aux') seems to only show processes that have been executed with exec() in the PHP script itself (so the only process it shows is itself.)", "Sometimes when I try to start Firefox it says \"a Firefox process is already running\". So I have to do this:jeremy@jeremy-desktop:~$ ps aux | grep firefox\njeremy    7451 25.0 27.4 170536 65680 ?        Sl   22:39   1:18 /usr/lib/firefox-3.0.1/firefox\njeremy    7578  0.0  0.3   3004   768 pts/0    S+   22:44   0:00 grep firefox\njeremy@jeremy-desktop:~$ kill 7451\nWhat I'd like is a command that would do all that for me. It would take an input string and grep for it (or whatever) in the list of processes, and would kill all the processes in the output:jeremy@jeremy-desktop:~$ killbyname firefox\nI tried doing it in PHP but exec('ps aux') seems to only show processes that have been executed with exec() in the PHP script itself (so the only process it shows is itself.)", "Sometimes when I try to start Firefox it says \"a Firefox process is already running\". So I have to do this:jeremy@jeremy-desktop:~$ ps aux | grep firefox\njeremy    7451 25.0 27.4 170536 65680 ?        Sl   22:39   1:18 /usr/lib/firefox-3.0.1/firefox\njeremy    7578  0.0  0.3   3004   768 pts/0    S+   22:44   0:00 grep firefox\njeremy@jeremy-desktop:~$ kill 7451\nWhat I'd like is a command that would do all that for me. It would take an input string and grep for it (or whatever) in the list of processes, and would kill all the processes in the output:jeremy@jeremy-desktop:~$ killbyname firefox\nI tried doing it in PHP but exec('ps aux') seems to only show processes that have been executed with exec() in the PHP script itself (so the only process it shows is itself.)", "Sometimes when I try to start Firefox it says \"a Firefox process is already running\". So I have to do this:jeremy@jeremy-desktop:~$ ps aux | grep firefox\njeremy    7451 25.0 27.4 170536 65680 ?        Sl   22:39   1:18 /usr/lib/firefox-3.0.1/firefox\njeremy    7578  0.0  0.3   3004   768 pts/0    S+   22:44   0:00 grep firefox\njeremy@jeremy-desktop:~$ kill 7451\nWhat I'd like is a command that would do all that for me. It would take an input string and grep for it (or whatever) in the list of processes, and would kill all the processes in the output:jeremy@jeremy-desktop:~$ killbyname firefox\nI tried doing it in PHP but exec('ps aux') seems to only show processes that have been executed with exec() in the PHP script itself (so the only process it shows is itself.)", "Sometimes when I try to start Firefox it says \"a Firefox process is already running\". So I have to do this:jeremy@jeremy-desktop:~$ ps aux | grep firefox\njeremy    7451 25.0 27.4 170536 65680 ?        Sl   22:39   1:18 /usr/lib/firefox-3.0.1/firefox\njeremy    7578  0.0  0.3   3004   768 pts/0    S+   22:44   0:00 grep firefox\njeremy@jeremy-desktop:~$ kill 7451\nWhat I'd like is a command that would do all that for me. It would take an input string and grep for it (or whatever) in the list of processes, and would kill all the processes in the output:jeremy@jeremy-desktop:~$ killbyname firefox\nI tried doing it in PHP but exec('ps aux') seems to only show processes that have been executed with exec() in the PHP script itself (so the only process it shows is itself.)", "Sometimes when I try to start Firefox it says \"a Firefox process is already running\". So I have to do this:jeremy@jeremy-desktop:~$ ps aux | grep firefox\njeremy    7451 25.0 27.4 170536 65680 ?        Sl   22:39   1:18 /usr/lib/firefox-3.0.1/firefox\njeremy    7578  0.0  0.3   3004   768 pts/0    S+   22:44   0:00 grep firefox\njeremy@jeremy-desktop:~$ kill 7451\nWhat I'd like is a command that would do all that for me. It would take an input string and grep for it (or whatever) in the list of processes, and would kill all the processes in the output:jeremy@jeremy-desktop:~$ killbyname firefox\nI tried doing it in PHP but exec('ps aux') seems to only show processes that have been executed with exec() in the PHP script itself (so the only process it shows is itself.)", "Sometimes when I try to start Firefox it says \"a Firefox process is already running\". So I have to do this:jeremy@jeremy-desktop:~$ ps aux | grep firefox\njeremy    7451 25.0 27.4 170536 65680 ?        Sl   22:39   1:18 /usr/lib/firefox-3.0.1/firefox\njeremy    7578  0.0  0.3   3004   768 pts/0    S+   22:44   0:00 grep firefox\njeremy@jeremy-desktop:~$ kill 7451\nWhat I'd like is a command that would do all that for me. It would take an input string and grep for it (or whatever) in the list of processes, and would kill all the processes in the output:jeremy@jeremy-desktop:~$ killbyname firefox\nI tried doing it in PHP but exec('ps aux') seems to only show processes that have been executed with exec() in the PHP script itself (so the only process it shows is itself.)", "Sometimes when I try to start Firefox it says \"a Firefox process is already running\". So I have to do this:jeremy@jeremy-desktop:~$ ps aux | grep firefox\njeremy    7451 25.0 27.4 170536 65680 ?        Sl   22:39   1:18 /usr/lib/firefox-3.0.1/firefox\njeremy    7578  0.0  0.3   3004   768 pts/0    S+   22:44   0:00 grep firefox\njeremy@jeremy-desktop:~$ kill 7451\nWhat I'd like is a command that would do all that for me. It would take an input string and grep for it (or whatever) in the list of processes, and would kill all the processes in the output:jeremy@jeremy-desktop:~$ killbyname firefox\nI tried doing it in PHP but exec('ps aux') seems to only show processes that have been executed with exec() in the PHP script itself (so the only process it shows is itself.)", "Sometimes when I try to start Firefox it says \"a Firefox process is already running\". So I have to do this:jeremy@jeremy-desktop:~$ ps aux | grep firefox\njeremy    7451 25.0 27.4 170536 65680 ?        Sl   22:39   1:18 /usr/lib/firefox-3.0.1/firefox\njeremy    7578  0.0  0.3   3004   768 pts/0    S+   22:44   0:00 grep firefox\njeremy@jeremy-desktop:~$ kill 7451\nWhat I'd like is a command that would do all that for me. It would take an input string and grep for it (or whatever) in the list of processes, and would kill all the processes in the output:jeremy@jeremy-desktop:~$ killbyname firefox\nI tried doing it in PHP but exec('ps aux') seems to only show processes that have been executed with exec() in the PHP script itself (so the only process it shows is itself.)", "Sometimes when I try to start Firefox it says \"a Firefox process is already running\". So I have to do this:jeremy@jeremy-desktop:~$ ps aux | grep firefox\njeremy    7451 25.0 27.4 170536 65680 ?        Sl   22:39   1:18 /usr/lib/firefox-3.0.1/firefox\njeremy    7578  0.0  0.3   3004   768 pts/0    S+   22:44   0:00 grep firefox\njeremy@jeremy-desktop:~$ kill 7451\nWhat I'd like is a command that would do all that for me. It would take an input string and grep for it (or whatever) in the list of processes, and would kill all the processes in the output:jeremy@jeremy-desktop:~$ killbyname firefox\nI tried doing it in PHP but exec('ps aux') seems to only show processes that have been executed with exec() in the PHP script itself (so the only process it shows is itself.)", "Sometimes when I try to start Firefox it says \"a Firefox process is already running\". So I have to do this:jeremy@jeremy-desktop:~$ ps aux | grep firefox\njeremy    7451 25.0 27.4 170536 65680 ?        Sl   22:39   1:18 /usr/lib/firefox-3.0.1/firefox\njeremy    7578  0.0  0.3   3004   768 pts/0    S+   22:44   0:00 grep firefox\njeremy@jeremy-desktop:~$ kill 7451\nWhat I'd like is a command that would do all that for me. It would take an input string and grep for it (or whatever) in the list of processes, and would kill all the processes in the output:jeremy@jeremy-desktop:~$ killbyname firefox\nI tried doing it in PHP but exec('ps aux') seems to only show processes that have been executed with exec() in the PHP script itself (so the only process it shows is itself.)", "Sometimes when I try to start Firefox it says \"a Firefox process is already running\". So I have to do this:jeremy@jeremy-desktop:~$ ps aux | grep firefox\njeremy    7451 25.0 27.4 170536 65680 ?        Sl   22:39   1:18 /usr/lib/firefox-3.0.1/firefox\njeremy    7578  0.0  0.3   3004   768 pts/0    S+   22:44   0:00 grep firefox\njeremy@jeremy-desktop:~$ kill 7451\nWhat I'd like is a command that would do all that for me. It would take an input string and grep for it (or whatever) in the list of processes, and would kill all the processes in the output:jeremy@jeremy-desktop:~$ killbyname firefox\nI tried doing it in PHP but exec('ps aux') seems to only show processes that have been executed with exec() in the PHP script itself (so the only process it shows is itself.)", "Sometimes when I try to start Firefox it says \"a Firefox process is already running\". So I have to do this:jeremy@jeremy-desktop:~$ ps aux | grep firefox\njeremy    7451 25.0 27.4 170536 65680 ?        Sl   22:39   1:18 /usr/lib/firefox-3.0.1/firefox\njeremy    7578  0.0  0.3   3004   768 pts/0    S+   22:44   0:00 grep firefox\njeremy@jeremy-desktop:~$ kill 7451\nWhat I'd like is a command that would do all that for me. It would take an input string and grep for it (or whatever) in the list of processes, and would kill all the processes in the output:jeremy@jeremy-desktop:~$ killbyname firefox\nI tried doing it in PHP but exec('ps aux') seems to only show processes that have been executed with exec() in the PHP script itself (so the only process it shows is itself.)", "I am trying to figure how to kill all processses in a session (with the same SID) using system calls with C. I am not interested in to just kill all with a specific PGID since not all processes I am interested about does not have the same PGID, but they have the same SID.My research have only found this, there Graeme made an excellent answer for scripts:\nhttps://unix.stackexchange.com/questions/124127/kill-all-descendant-processesI would be pleased to get an answer for how it would be possible to kill all direct descendant children and even more pleased how I could kill all children within the session.Or is what I am asking possible? I am not intrested in a solution there I am simply listing the PIDs of the parents descendant.", "I am trying to figure how to kill all processses in a session (with the same SID) using system calls with C. I am not interested in to just kill all with a specific PGID since not all processes I am interested about does not have the same PGID, but they have the same SID.My research have only found this, there Graeme made an excellent answer for scripts:\nhttps://unix.stackexchange.com/questions/124127/kill-all-descendant-processesI would be pleased to get an answer for how it would be possible to kill all direct descendant children and even more pleased how I could kill all children within the session.Or is what I am asking possible? I am not intrested in a solution there I am simply listing the PIDs of the parents descendant.", "I am trying to figure how to kill all processses in a session (with the same SID) using system calls with C. I am not interested in to just kill all with a specific PGID since not all processes I am interested about does not have the same PGID, but they have the same SID.My research have only found this, there Graeme made an excellent answer for scripts:\nhttps://unix.stackexchange.com/questions/124127/kill-all-descendant-processesI would be pleased to get an answer for how it would be possible to kill all direct descendant children and even more pleased how I could kill all children within the session.Or is what I am asking possible? I am not intrested in a solution there I am simply listing the PIDs of the parents descendant."], "chosen": ["\nHeh, I was just researching this myself yesterday! Assuming you can't alter the child program:\nOn Linux, prctl(PR_SET_PDEATHSIG, ...) is probably the only reliable choice. (If it's absolutely necessary that the child process be killed, then you might want to set the death signal to SIGKILL instead of SIGTERM; the code you linked to uses SIGTERM, but the child does have the option of ignoring SIGTERM if it wants to.)\nOn Windows, the most reliable options is to use a Job object. The idea is that you create a \"Job\" (a kind of container for processes), then you place the child process into the Job, and you set the magic option that says \"when no-one holds a 'handle' for this Job, then kill the processes that are in it\". By default, the only 'handle' to the job is the one that your parent process holds, and when the parent process dies, the OS will go through and close all its handles, and then notice that this means there are no open handles for the Job. So then it kills the child, as requested. (If you have multiple child processes, you can assign them all to the same job.) This answer has sample code for doing this, using the win32api module. That code uses CreateProcess to launch the child, instead of subprocess.Popen. The reason is that they need to get a \"process handle\" for the spawned child, and CreateProcess returns this by default. If you'd rather use subprocess.Popen, then here's an (untested) copy of the code from that answer, that uses subprocess.Popen and OpenProcess instead of CreateProcess:\nimport subprocess\nimport win32api\nimport win32con\nimport win32job\n\nhJob = win32job.CreateJobObject(None, \"\")\nextended_info = win32job.QueryInformationJobObject(hJob, win32job.JobObjectExtendedLimitInformation)\nextended_info['BasicLimitInformation']['LimitFlags'] = win32job.JOB_OBJECT_LIMIT_KILL_ON_JOB_CLOSE\nwin32job.SetInformationJobObject(hJob, win32job.JobObjectExtendedLimitInformation, extended_info)\n\nchild = subprocess.Popen(...)\n# Convert process id to process handle:\nperms = win32con.PROCESS_TERMINATE | win32con.PROCESS_SET_QUOTA\nhProcess = win32api.OpenProcess(perms, False, child.pid)\n\nwin32job.AssignProcessToJobObject(hJob, hProcess)\n\nTechnically, there's a tiny race condition here in case the child dies in between the Popen and OpenProcess calls, you can decide whether you want to worry about that.\nOne downside to using a job object is that when running on Vista or Win7, if your program is launched from the Windows shell (i.e., by clicking on an icon), then there will probably already be a job object assigned and trying to create a new job object will fail. Win8 fixes this (by allowing job objects to be nested), or if your program is run from the command line then it should be fine.\nIf you can modify the child (e.g., like when using multiprocessing), then probably the best option is to somehow pass the parent's PID to the child (e.g. as a command line argument, or in the args= argument to multiprocessing.Process), and then:\nOn POSIX: Spawn a thread in the child that just calls os.getppid() occasionally, and if the return value ever stops matching the pid passed in from the parent, then call os._exit(). (This approach is portable to all Unixes, including OS X, while the prctl trick is Linux-specific.)\nOn Windows: Spawn a thread in the child that uses OpenProcess and os.waitpid. Example using ctypes:\nfrom ctypes import WinDLL, WinError\nfrom ctypes.wintypes import DWORD, BOOL, HANDLE\n# Magic value from http://msdn.microsoft.com/en-us/library/ms684880.aspx\nSYNCHRONIZE = 0x00100000\nkernel32 = WinDLL(\"kernel32.dll\")\nkernel32.OpenProcess.argtypes = (DWORD, BOOL, DWORD)\nkernel32.OpenProcess.restype = HANDLE\nparent_handle = kernel32.OpenProcess(SYNCHRONIZE, False, parent_pid)\n# Block until parent exits\nos.waitpid(parent_handle, 0)\nos._exit(0)\n\nThis avoids any of the possible issues with job objects that I mentioned.\nIf you want to be really, really sure, then you can combine all these solutions.\nHope that helps!\n", "\nThe Popen object offers the terminate and kill methods. \nhttps://docs.python.org/2/library/subprocess.html#subprocess.Popen.terminate\nThese send the SIGTERM and SIGKILL signals for you. \nYou can do something akin to the below:\nfrom subprocess import Popen\n\np = None\ntry:\n    p = Popen(arg)\n    # some code here\nexcept Exception as ex:\n    print 'Parent program has exited with the below error:\\n{0}'.format(ex)\n    if p:\n        p.terminate()\n\nUPDATE:\nYou are correct--the above code will not protect against hard-crashing or someone killing your process. In that case you can try wrapping the child process in a class and employ a polling model to watch the parent process.\nBe aware psutil is non-standard. \nimport os\nimport psutil\n\nfrom multiprocessing import Process\nfrom time import sleep\n\n\nclass MyProcessAbstraction(object):\n    def __init__(self, parent_pid, command):\n        \"\"\"\n        @type parent_pid: int\n        @type command: str\n        \"\"\"\n        self._child = None\n        self._cmd = command\n        self._parent = psutil.Process(pid=parent_pid)\n\n    def run_child(self):\n        \"\"\"\n        Start a child process by running self._cmd. \n        Wait until the parent process (self._parent) has died, then kill the \n        child.\n        \"\"\"\n        print '---- Running command: \"%s\" ----' % self._cmd\n        self._child = psutil.Popen(self._cmd)\n        try:\n            while self._parent.status == psutil.STATUS_RUNNING:\n                sleep(1)\n        except psutil.NoSuchProcess:\n            pass\n        finally:\n            print '---- Terminating child PID %s ----' % self._child.pid\n            self._child.terminate()\n\n\nif __name__ == \"__main__\":\n    parent = os.getpid()\n    child = MyProcessAbstraction(parent, 'ping -t localhost')\n    child_proc = Process(target=child.run_child)\n    child_proc.daemon = True\n    child_proc.start()\n\n    print '---- Try killing PID: %s ----' % parent\n    while True:\n        sleep(1)\n\nIn this example I run 'ping -t localhost' b/c that will  run forever. If you kill the parent process, the child process (the ping command) will also be killed. \n", "\nSince, from what I can tell, the PR_SET_PDEATHSIG solution can result in a deadlock when any threads are running in the parent process, I didn't want to use that and figured out another way. I created a separate auto-terminate process that detects when its parent process is done and kills the other subprocess that is its target.\nTo accomplish this, you need to pip install psutil, and then write code similar to the following:\ndef start_auto_cleanup_subprocess(target_pid):\n    cleanup_script = f\"\"\"\nimport os\nimport psutil\nimport signal\nfrom time import sleep\n\ntry:                                                            \n    # Block until stdin is closed which means the parent process\n    # has terminated.                                           \n    input()                                                     \nexcept Exception:                                               \n    # Should be an EOFError, but if any other exception happens,\n    # assume we should respond in the same way.                 \n    pass                                                        \n\nif not psutil.pid_exists({target_pid}):              \n    # Target process has already exited, so nothing to do.      \n    exit()                                                      \n                                                                \nos.kill({target_pid}, signal.SIGTERM)                           \nfor count in range(10):                                         \n    if not psutil.pid_exists({target_pid}):  \n        # Target process no longer running.        \n        exit()\n    sleep(1)\n                                                                \nos.kill({target_pid}, signal.SIGKILL)                           \n# Don't bother waiting to see if this works since if it doesn't,\n# there is nothing else we can do.                              \n\"\"\"\n\n    return Popen(\n        [\n            sys.executable,  # Python executable\n            '-c', cleanup_script\n        ],\n        stdin=subprocess.PIPE\n    )\n\nThis is similar to https://stackoverflow.com/a/23436111/396373 that I had failed to notice, but I think the way that I came up with is easier for me to use because the process that is the target of cleanup is created directly by the parent. Also note that it is not necessary to poll the status of the parent, though it is still necessary to use psutil and to poll the status of the target subprocess during the termination sequence if you want to try, as in this example, to terminate, monitor, and then kill if terminate didn't work expeditiously.\n", "\nHook exit of your process using SetConsoleCtrlHandler, and kill subprocess. I think I do a bit of a overkill there, but it works :)\nimport psutil, os\n\ndef kill_proc_tree(pid, including_parent=True):\n    parent = psutil.Process(pid)\n    children = parent.children(recursive=True)\n    for child in children:\n        child.kill()\n    gone, still_alive = psutil.wait_procs(children, timeout=5)\n    if including_parent:\n        parent.kill()\n        parent.wait(5)\n\ndef func(x):\n    print(\"killed\")\n    if anotherproc:\n        kill_proc_tree(anotherproc.pid)\n    kill_proc_tree(os.getpid())\n\nimport win32api,shlex\nwin32api.SetConsoleCtrlHandler(func, True)      \n\nPROCESSTORUN=\"your process\"\nanotherproc=None\ncmdline=f\"/c start /wait \\\"{PROCESSTORUN}\\\" \"\nanotherproc=subprocess.Popen(executable='C:\\\\Windows\\\\system32\\\\cmd.EXE', args=shlex.split(cmdline,posix=\"false\"))\n...\nrun program\n...\n\nTook kill_proc_tree from:\nsubprocess: deleting child processes in Windows\n", "\ni had the same problem with the same message. Seems to be a problem of processor compability.\nFound this post https://www.mongodb.com/community/forums/t/mongodb-5-0-cpu-intel-g4650-compatibility/116610\nCheck if your pocessor has the flags mentioned in the answer with the command:\ncat /proc/cpuinfo\n\nif not, you can try with an older version of mongo.\nIn my case my processor can't handle mongo4.4, but installed mongo4.2 and works fine, but depends of your processor and SO.\n", "\nDowngrade to 4.4\nfirst, remove MongoDB\nsudo apt-get purge mongodb-org*\n\nsudo rm -r /var/log/mongodb\n\nsudo rm -r /var/lib/mongodb\n\nsudo rm -rf /etc/apt/sources.list.d/mongodb-org-5.0.list\n\ninstall MongoDB 4.4\nwget -qO - https://www.mongodb.org/static/pgp/server-4.4.asc | sudo apt- \nkey add -\n\nThis worked for me seems to be a hardware problem, especially the CPU\n", "\nAlso had the same problem and the above answer did help tremendously, but I found a couple stuff missing. My issue was also of the processor compatibility and required to uninstall the version I had installed and install a earlier version of MongoDB.\nHere are the steps I followed, that did it for me\nFirst, Uninstall the MongoDB version you had installed, requires removing the used repo from the sources.list, otherwise it will just keep installing that one (or latest version), even after uninstalling it. So to remove the repo from the sources.list follow these steps:\n\nList the contents of sources.list directory using\nls -l /etc/apt/sources.list.d/\n\n\nRemove the repo(s) using the command\nsudo rm /etc/apt/sources.list.d/<repo_name>\n\n\n\nOnce the repo(s) are removed, uninstall MongoDB. Use these commands:\nsudo apt purge mongodb-org*\nsudo rm -r /var/log/mongodb\nsudo rm -r /var/lib/mongodb\n\nAfter uninstalling MongoDB, you might want to update the package list, so use\nsudo apt update\n\nFrom here onward, you can follow the steps for installing the lower version of MongoDB you want as outlined in the manual. Just make sure you select the version you want.\nIf it happens that the earlier version you get to also throws the same error, repeat the process, going to an earlier version still.\n", "\nIf you don't like \"your friend\", the OOM killer, to kill innocent processes, a short answer is:\nsysctl -w vm.overcommit_memory=2\n\nMore verbose answers and recommended reading:\n\nEffects of configuring vm.overcommit_memory\nHow to disable the oom killer in linux?\nTurn off the Linux OOM killer by default?\n\n", "\nWhat worked for me is to store the response in a temporary file then using cat to further process the response.\ncurl [url] > curl_repsponse_temp_file\n...\n\n", "\nThere's a special variable for this in Bash:\nkill $!\n\n$! expands to the PID of the last process executed in the background.\n", "\nThe following command gives you a list of all background processes in your session, along with the pid. You can then use it to kill the process.\njobs -l\n\nExample usage:\n$ sleep 300 &\n$ jobs -l\n[1]+ 31139 Running                 sleep 300 &\n$ kill 31139\n\n", "\nYou can kill by job number. When you put a task in the background you'll see something like:\n$ ./script &\n[1] 35341\n\nThat [1] is the job number and can be referenced like:\n$ kill %1\n$ kill %%  # Most recent background job\n\nTo see a list of job numbers use the jobs command. More from man bash:\n\nThere are a number of ways to refer to a job in the shell.  The character % introduces a job name.  Job number n may  be\n         referred  to  as %n.  A job may also be referred to using a prefix of the name used to start it, or using a substring that\n         appears in its command line.  For example, %ce refers to a stopped ce job.  If a prefix matches more than  one  job,  bash\n         reports  an error.  Using %?ce, on the other hand, refers to any job containing the string ce in its command line.  If the\n         substring matches more than one job, bash reports an error.  The symbols %% and %+ refer to the shell's notion of the current job, which is the last job stopped while it was in the foreground or started in the background.  The previous job may\n         be referenced using %-.  In output pertaining to jobs (e.g., the output of the jobs command), the current  job  is  always\n         flagged  with  a +, and the previous job with a -.  A single % (with no accompanying job specification) also refers to the\n         current job.\n\n", "\nThis should kill all background processes:\njobs -p | xargs kill -9\n\n", "\nskill doB\n\nskill is a version of the kill command that lets you select one or multiple processes based on a given criteria.  \n", "\nYou need its pid... use \"ps -A\" to find it.\n", "\nAs in John Kugelman's answer, % is related to job specification.\nHow can we efficiently find that? Use less's &pattern command. It seems man uses the less pager (I am not that sure). In 'man' Bash, type &%, and then type Enter. It will only show lines that containing '%'. To reshow all, type &. And then Enter.\n", "\nCheck out process groups:\nhttps://en.wikipedia.org/wiki/Process_group\nAssuming you want to do this from a shell?\nIf you do a kill and make the top process negative it does a killpg under the covers and sends the signal to all the processes in the group.\n", "\nIf the user or sysadmin did not kill the program the kernel may have. The kernel would only kill a process under exceptional circumstances such as extreme resource starvation (think mem+swap exhaustion).\n", "\nTry:\ndmesg -T| grep -E -i -B100 'killed process'\n\nWhere -B100 signifies the number of lines before the kill happened.\nOmit -T on Mac OS.\n", "\nThis looks like a good article on the subject: Taming the OOM killer (1).\nThe gist is that Linux overcommits memory. When a process asks for more space, Linux will give it that space, even if it is claimed by another process, under the assumption that nobody actually uses all of the memory they ask for. The process will get exclusive use of the memory it has allocated when it actually uses it, not when it asks for it. This makes allocation quick, and might allow you to \"cheat\" and allocate more memory than you really have. However, once processes start using this memory, Linux might realize that it has been too generous in allocating memory it doesn't have, and will have to kill off a process to free some up. The process to be killed is based on a score taking into account runtime (long-running processes are safer), memory usage (greedy processes are less safe), and a few other factors, including a value you can adjust to make a process less likely to be killed. It's all described in the article in a lot more detail.\nEdit: And here is [another article] (2) that explains pretty well how a process is chosen (annotated with some kernel code examples). The great thing about this is that it includes some commentary on the reasoning behind the various badness() rules.\n", "\nLet me first explain when and why OOMKiller get invoked?\nSay you have 512 RAM + 1GB Swap memory. So in theory, your CPU has access to total of 1.5GB of virtual memory.\nNow, for some time everything is running fine within 1.5GB of total memory. But all of sudden (or gradually) your system has started consuming more and more memory and it reached at a point around 95% of total memory used.\nNow say any process has requested large chunck of memory from the kernel. Kernel check for the available memory and find that there is no way it can allocate your process more memory. So it will try to free some memory calling/invoking OOMKiller (http://linux-mm.org/OOM).\nOOMKiller has its own algorithm to score the rank for every process. Typically which process uses more memory becomes the victim to be killed.\nWhere can I find logs of OOMKiller?\nTypically in /var/log directory. Either /var/log/kern.log or /var/log/dmesg\nHope this will help you.\nSome typical solutions:\n\nIncrease memory (not swap) \nFind the memory leaks in your program and fix them \nRestrict memory any process can consume (for example JVM memory can be restricted using JAVA_OPTS) \nSee the logs and google :)\n\n", "\nThis is the Linux out of memory manager (OOM). Your process was selected due to 'badness' - a combination of recentness, resident size (memory in use, rather than just allocated) and other factors.\nsudo journalctl -xb\n\nYou'll see a message like:\nJul 20 11:05:00 someapp kernel: Mem-Info:\nJul 20 11:05:00 someapp kernel: Node 0 DMA per-cpu:\nJul 20 11:05:00 someapp kernel: CPU    0: hi:    0, btch:   1 usd:   0\nJul 20 11:05:00 someapp kernel: Node 0 DMA32 per-cpu:\nJul 20 11:05:00 someapp kernel: CPU    0: hi:  186, btch:  31 usd:  30\nJul 20 11:05:00 someapp kernel: active_anon:206043 inactive_anon:6347 isolated_anon:0\n                                    active_file:722 inactive_file:4126 isolated_file:0\n                                    unevictable:0 dirty:5 writeback:0 unstable:0\n                                    free:12202 slab_reclaimable:3849 slab_unreclaimable:14574\n                                    mapped:792 shmem:12802 pagetables:1651 bounce:0\n                                    free_cma:0\nJul 20 11:05:00 someapp kernel: Node 0 DMA free:4576kB min:708kB low:884kB high:1060kB active_anon:10012kB inactive_anon:488kB active_file:4kB inactive_file:4kB unevictable:0kB isolated(anon):0kB isolated(file):0kB present\nJul 20 11:05:00 someapp kernel: lowmem_reserve[]: 0 968 968 968\nJul 20 11:05:00 someapp kernel: Node 0 DMA32 free:44232kB min:44344kB low:55428kB high:66516kB active_anon:814160kB inactive_anon:24900kB active_file:2884kB inactive_file:16500kB unevictable:0kB isolated(anon):0kB isolated\nJul 20 11:05:00 someapp kernel: lowmem_reserve[]: 0 0 0 0\nJul 20 11:05:00 someapp kernel: Node 0 DMA: 17*4kB (UEM) 22*8kB (UEM) 15*16kB (UEM) 12*32kB (UEM) 8*64kB (E) 9*128kB (UEM) 2*256kB (UE) 3*512kB (UM) 0*1024kB 0*2048kB 0*4096kB = 4580kB\nJul 20 11:05:00 someapp kernel: Node 0 DMA32: 216*4kB (UE) 601*8kB (UE) 448*16kB (UE) 311*32kB (UEM) 135*64kB (UEM) 74*128kB (UEM) 5*256kB (EM) 0*512kB 0*1024kB 1*2048kB (R) 0*4096kB = 44232kB\nJul 20 11:05:00 someapp kernel: Node 0 hugepages_total=0 hugepages_free=0 hugepages_surp=0 hugepages_size=2048kB\nJul 20 11:05:00 someapp kernel: 17656 total pagecache pages\nJul 20 11:05:00 someapp kernel: 0 pages in swap cache\nJul 20 11:05:00 someapp kernel: Swap cache stats: add 0, delete 0, find 0/0\nJul 20 11:05:00 someapp kernel: Free swap  = 0kB\nJul 20 11:05:00 someapp kernel: Total swap = 0kB\nJul 20 11:05:00 someapp kernel: 262141 pages RAM\nJul 20 11:05:00 someapp kernel: 7645 pages reserved\nJul 20 11:05:00 someapp kernel: 264073 pages shared\nJul 20 11:05:00 someapp kernel: 240240 pages non-shared\nJul 20 11:05:00 someapp kernel: [ pid ]   uid  tgid total_vm      rss nr_ptes swapents oom_score_adj name\nJul 20 11:05:00 someapp kernel: [  241]     0   241    13581     1610      26        0             0 systemd-journal\nJul 20 11:05:00 someapp kernel: [  246]     0   246    10494      133      22        0         -1000 systemd-udevd\nJul 20 11:05:00 someapp kernel: [  264]     0   264    29174      121      26        0         -1000 auditd\nJul 20 11:05:00 someapp kernel: [  342]     0   342    94449      466      67        0             0 NetworkManager\nJul 20 11:05:00 someapp kernel: [  346]     0   346   137495     3125      88        0             0 tuned\nJul 20 11:05:00 someapp kernel: [  348]     0   348    79595      726      60        0             0 rsyslogd\nJul 20 11:05:00 someapp kernel: [  353]    70   353     6986       72      19        0             0 avahi-daemon\nJul 20 11:05:00 someapp kernel: [  362]    70   362     6986       58      18        0             0 avahi-daemon\nJul 20 11:05:00 someapp kernel: [  378]     0   378     1621       25       8        0             0 iprinit\nJul 20 11:05:00 someapp kernel: [  380]     0   380     1621       26       9        0             0 iprupdate\nJul 20 11:05:00 someapp kernel: [  384]    81   384     6676      142      18        0          -900 dbus-daemon\nJul 20 11:05:00 someapp kernel: [  385]     0   385     8671       83      21        0             0 systemd-logind\nJul 20 11:05:00 someapp kernel: [  386]     0   386    31573      153      15        0             0 crond\nJul 20 11:05:00 someapp kernel: [  391]   999   391   128531     2440      48        0             0 polkitd\nJul 20 11:05:00 someapp kernel: [  400]     0   400     9781       23       8        0             0 iprdump\nJul 20 11:05:00 someapp kernel: [  419]     0   419    27501       32      10        0             0 agetty\nJul 20 11:05:00 someapp kernel: [  855]     0   855    22883      258      43        0             0 master\nJul 20 11:05:00 someapp kernel: [  862]    89   862    22926      254      44        0             0 qmgr\nJul 20 11:05:00 someapp kernel: [23631]     0 23631    20698      211      43        0         -1000 sshd\nJul 20 11:05:00 someapp kernel: [12884]     0 12884    81885     3754      80        0             0 firewalld\nJul 20 11:05:00 someapp kernel: [18130]     0 18130    33359      291      65        0             0 sshd\nJul 20 11:05:00 someapp kernel: [18132]  1000 18132    33791      748      64        0             0 sshd\nJul 20 11:05:00 someapp kernel: [18133]  1000 18133    28867      122      13        0             0 bash\nJul 20 11:05:00 someapp kernel: [18428]    99 18428   208627    42909     151        0             0 node\nJul 20 11:05:00 someapp kernel: [18486]    89 18486    22909      250      46        0             0 pickup\nJul 20 11:05:00 someapp kernel: [18515]  1000 18515   352905   141851     470        0             0 npm\nJul 20 11:05:00 someapp kernel: [18520]     0 18520    33359      291      66        0             0 sshd\nJul 20 11:05:00 someapp kernel: [18522]  1000 18522    33359      294      64        0             0 sshd\nJul 20 11:05:00 someapp kernel: [18523]  1000 18523    28866      115      12        0             0 bash\nJul 20 11:05:00 someapp kernel: Out of memory: Kill process 18515 (npm) score 559 or sacrifice child\nJul 20 11:05:00 someapp kernel: Killed process 18515 (npm) total-vm:1411620kB, anon-rss:567404kB, file-rss:0kB\n\n", "\nAs dwc and Adam Jaskiewicz have stated, the culprit is likely the OOM Killer. However, the next question that follows is: How do I prevent this?\nThere are several ways:\n\nGive your system more RAM if you can (easy if its a VM)\nMake sure the OOM killer chooses a different process.\nDisable the OOM Killer\nChoose a Linux distro which ships with the OOM Killer disabled.\n\nI found (2) to be especially easy to implement:\nAdjust /proc/<PID>/oom_score_adj to -1000 (which automatically takes oom_adj to -17 and oom_score to 0).\nSee how To Create OOM Exclusions in Linux for more.\n", "\nA tool like systemtap (or a tracer) can monitor kernel signal-transmission logic and report.  e.g., https://sourceware.org/systemtap/examples/process/sigmon.stp\n# stap --example sigmon.stp -x 31994 SIGKILL\n   SPID     SNAME            RPID  RNAME            SIGNUM SIGNAME\n   5609     bash             31994 find             9      SIGKILL\n\nThe filtering if block in that script can be adjusted to taste, or eliminated to trace systemwide signal traffic.  Causes can be further isolated by collecting backtraces (add a print_backtrace() and/or print_ubacktrace() to the probe, for kernel- and userspace- respectively).\n", "\nThe PAM module to limit resources caused exactly the results you described: My process died mysteriously with the text Killed on the console window. No log output, neither in syslog nor in kern.log. The top program helped me to discover that exactly after one minute of CPU usage my process gets killed. \n", "\nIn an lsf environment (interactive or otherwise) if the application exceeds memory utilization beyond some preset threshold by the admins on the queue or the resource request in submit to the queue the processes will be killed so other users don't fall victim to a potential run away. It doesn't always send an email when it does so, depending on how its set up.\nOne solution in this case is to find a queue with larger resources or define larger resource requirements in the submission.\nYou may also want to review man ulimit\nAlthough I don't remember ulimit resulting in Killed its been a while since I needed that.\n", "\nIn my case this was happening with a Laravel queue worker. The system logs did not mention any killing so I looked further and it turned out that the worker was basically killing itself because of a job that exceeded the memory limit (which is set to 128M by default).\nRunning the queue worker with --timeout=600 and --memory=1024 fixed the problem for me.\n", "\nWe have had recurring problems under Linux at a customer site (Red Hat, I think), with OOMKiller (out-of-memory killer) killing both our principle application (i.e. the reason the server exists) and it's data base processes.  \nIn each case OOMKiller simply decided that the processes were using to much resources... the machine wasn't even about to fail for lack of resources.  Neither the application nor it's database has problems with memory leaks (or any other resource leak).\nI am not a Linux expert, but I rather gathered it's algorithm for deciding when to kill something and what to kill is complex.  Also, I was told (I can't speak as to the accuracy of this) that OOMKiller is baked into the Kernel and you can't simply not run it.\n", "\nThe user has the ability to kill his own programs, using kill or Control+C, but I get the impression that's not what happened, and that the user complained to you.\nroot has the ability to kill programs of course, but if someone has root on your machine and is killing stuff you have bigger problems.\nIf you are not the sysadmin, the sysadmin may have set up quotas on CPU, RAM, ort disk usage and auto-kills processes that exceed them.\nOther than those guesses, I'm not sure without more info about the program.\n", "\nAlso possible to use: \npkill -f \"Process name\"\n\nFor me, it worked up perfectly. It was what I have been looking for.\npkill doesn't work with name without the flag.\nWhen -f is set, the full command line is used for pattern matching. \n", "\npkill firefox\n\nMore information: http://linux.about.com/library/cmd/blcmdl1_pkill.htm\n", "\nYou can kill processes by name with killall <name>\n\nkillall sends a signal to all\n  processes running any of the specified\n  commands. If no signal name is\n  specified, SIGTERM is sent.\nSignals can be specified either by\n  name (e.g. -HUP or -SIGHUP ) or by number (e.g.\n  -1) or by option -s.\nIf the command name is not regular\n  expression (option -r) and contains a\n  slash (/), processes executing that\n  particular file will be selected for\n  killing, independent of their name.\n\nBut if you don't see the process with ps aux, you probably won't have the right to kill it ...\n", "\nThe easiest way to do is first check you are getting right process IDs with:\npgrep -f [part_of_a_command]\n\nIf the result is as expected. Go with:\npkill -f [part_of_a_command]\n\nIf processes get stuck and are unable to accomplish the request you can use kill.\nkill -9 $(pgrep -f [part_of_a_command])\n\nIf you want to be on the safe side and only terminate processes that you initially started add -u along with your username\npkill -f [part_of_a_command] -u [username]\n\n", "\nA bit longer alternative:\nkill `pidof firefox`\n\n", "\nKill all processes having snippet in startup path. You can kill all apps started from some directory by for putting /directory/ as a snippet. This is quite usefull when you start several components for the same application from the same app directory.\nps ax | grep <snippet> | grep -v grep | awk '{print $1}' | xargs kill\n\n* I would prefer pgrep if available\n", "\nStrange, but I haven't seen the solution like this:\nkill -9 `pidof firefox`\n\nit can also kill multiple processes (multiple pids) like:\nkill -9 `pgrep firefox`\n\nI prefer pidof since it has single line output:\n> pgrep firefox\n6316\n6565\n> pidof firefox\n6565 6316\n\n", "\nUsing killall command:\nkillall processname\n\nUse -9 or -KILL to forcefully kill the program (the options are similar to the kill command).\n", "\nOn Mac I could not find the pgrep and pkill neither was killall working so wrote a simple one liner script:-\nexport pid=`ps | grep process_name | awk 'NR==1{print $1}' | cut -d' ' -f1`;kill $pid\n\nIf there's an easier way of doing this then please share.\n", "\nTo kill with grep:\nkill -9 `pgrep myprocess`\n\n", "\nmore correct would be: \nexport pid=`ps aux | grep process_name | awk 'NR==1{print $2}' | cut -d' ' -f1`;kill -9 $pid\n\n", "\nI normally use the killall command.\nCheck this link for details of this command.\n", "\nI was asking myself the same question but the problem with the current answers is that they don't safe check the processes to be killed so... it could lead to terrible mistakes :)... especially if several processes matches the pattern.\nAs a disclaimer, I'm not a sh pro and there is certainly room for improvement.\nSo I wrote a little sh script :\n#!/bin/sh\n\nkillables=$(ps aux | grep $1 | grep -v mykill | grep -v grep)\nif [ ! \"${killables}\" = \"\" ]\nthen\n  echo \"You are going to kill some process:\"\n  echo \"${killables}\"\nelse\n  echo \"No process with the pattern $1 found.\"\n  return\nfi\necho -n \"Is it ok?(Y/N)\"\nread input\nif [ \"$input\" = \"Y\" ]\nthen\n  for pid in $(echo \"${killables}\" | awk '{print $2}')\n  do\n    echo killing $pid \"...\"\n    kill $pid \n    echo $pid killed\n  done\nfi\n\n", "\nkill -9 $(ps aux | grep -e myprocessname| awk '{ print $2 }')\n", "\nIf you run GNOME, you can use the system monitor (System->Administration->System Monitor) to kill processes as you would under Windows. KDE will have something similar.\n", "\nThe default kill command accepts command names as an alternative to PID. See kill (1). An often occurring trouble is that bash provides its own kill which accepts job numbers, like kill %1, but not command names. This hinders the default command. If the former functionality is more useful to you than the latter, you can disable the bash version by calling\nenable -n kill\nFor more info see kill and enable entries in bash (1).\n", "\nps aux | grep processname | cut -d' ' -f7 | xargs kill -9 $\n\n", "\nYou can always use the /proc/ file system to query processes (see proc(5) for more). In particular you can then scan the /proc/PID/ directories (where PID is some numerical name like 1234, it is the relevant pid, so process of pid 1234 is described in /proc/1234/ pseudo-directory; hence you could readdir the /proc/ directory and find every numerical name inside it) and check which processes have a defined parent pid. You'll read sequentially pseudo-files like /proc/1234/status (and its PPid: line). See also this answer and that one.\n", "\nplease try this\npkill -9 -s [session id]\n", "\nAs far as I understand, you can't do that safely. \nThe only processes you can safely kill are your direct children because only for them you'll be able to know with certainty that their pid is accurate.*\nFor any other process, pids of their nonchildren processes are a moving target (though very very slowly moving, unless you're on an extremely busy system where processes are spawned like crazy, making pid recycling very fast).\nSo you could theoretically walk the process tree, e.g.:\n#This will create a nice process tree\n(sleep 1000 & ( sleep 1000&  sleep 1000& sleep 1000)&  sleep 1000 )&\n#View it with \nps T --forest\n#Or recursively get all the nodes (this should match the corresponding part of the above ps command)\nwalk_processes() { echo $1; cat /proc/$1/task/$1/children | while read -d ' ' pid; do walk_processes $pid; done;  }\nwalk_processes $!\n\nBut you can't use the pids obtained in the above fashion to implement a safe \"kill a whole process tree\" (with a session being a specific type of a process tree).\nYou can only kill the direct children of the session leader or their whole process groups, but the processes that get killed in this fashion may not transmit the kill signal further on to their subgroups\u2014something you can't safely/reliably do for them. The processes that remained after a closing of a session in this way are then reparented to init. If they're stopped process groups, they'd have no one to wake them up (these are called orphaned groups), so init will send them SIGCONT and SIGHUP (these two, with SIGHUP being sent first). SIGHUP will normally kill them. If they have a handler for SIGHUP, they may live on as daemons.\nIn other words, if you want to safely kill children of your session leader, prevent those children from creating subgroups, (making your session id always match with a single process group id). \n\n*The reason for that is after you successfully kill your own child process, it becomes a zombie until you wait on it, and that zombie reserves the pid spot so until you've waited on your child, your child's pid is not a moving target (all other pids are).\n"], "rejected": ["\nIf the child process is something you've written in Python, a simple method is to periodically check if the parent has exited:\nimport os, sys, asyncio, psutil\n\nasync def check_orphaned():\n        parent = psutil.Process(os.getppid())\n        while True:\n            if not parent.is_running():\n                sys.exit()\n            await asyncio.sleep(2.5)\n\n# check if orphaned in the background\norphan_listener_task = asyncio.create_task(check_orphaned()))\n\nMuch simpler than setting up OS specific parent-child bindings, and should be good enough in most scenarios I think.\n", "\nIf the child process is something you've written in Python, a simple method is to periodically check if the parent has exited:\nimport os, sys, asyncio, psutil\n\nasync def check_orphaned():\n        parent = psutil.Process(os.getppid())\n        while True:\n            if not parent.is_running():\n                sys.exit()\n            await asyncio.sleep(2.5)\n\n# check if orphaned in the background\norphan_listener_task = asyncio.create_task(check_orphaned()))\n\nMuch simpler than setting up OS specific parent-child bindings, and should be good enough in most scenarios I think.\n", "\nIf the child process is something you've written in Python, a simple method is to periodically check if the parent has exited:\nimport os, sys, asyncio, psutil\n\nasync def check_orphaned():\n        parent = psutil.Process(os.getppid())\n        while True:\n            if not parent.is_running():\n                sys.exit()\n            await asyncio.sleep(2.5)\n\n# check if orphaned in the background\norphan_listener_task = asyncio.create_task(check_orphaned()))\n\nMuch simpler than setting up OS specific parent-child bindings, and should be good enough in most scenarios I think.\n", "\nIf the child process is something you've written in Python, a simple method is to periodically check if the parent has exited:\nimport os, sys, asyncio, psutil\n\nasync def check_orphaned():\n        parent = psutil.Process(os.getppid())\n        while True:\n            if not parent.is_running():\n                sys.exit()\n            await asyncio.sleep(2.5)\n\n# check if orphaned in the background\norphan_listener_task = asyncio.create_task(check_orphaned()))\n\nMuch simpler than setting up OS specific parent-child bindings, and should be good enough in most scenarios I think.\n", "\nsame for me on a proxmox VM using mongodb-7.0\nI just had to change my default CPU type\nfrom x86-64-v2-AES to x86-64-v4\n", "\nsame for me on a proxmox VM using mongodb-7.0\nI just had to change my default CPU type\nfrom x86-64-v2-AES to x86-64-v4\n", "\nsame for me on a proxmox VM using mongodb-7.0\nI just had to change my default CPU type\nfrom x86-64-v2-AES to x86-64-v4\n", "\nThe OOM Killer is your friend, why would you want to disable it? When the system is running out of memory, the kernel must start killing processes in order to stay operational. So lets be honest, you need the OOM Killer.\nInstead, you might consider configuring the OOM Killer with some configuration that suits your needs; yet your current problems may persist.\nIn the light of the facts, it may be better to implement a more efficient way of doing these tasks you are doing.\n", "\nThe OOM Killer is your friend, why would you want to disable it? When the system is running out of memory, the kernel must start killing processes in order to stay operational. So lets be honest, you need the OOM Killer.\nInstead, you might consider configuring the OOM Killer with some configuration that suits your needs; yet your current problems may persist.\nIn the light of the facts, it may be better to implement a more efficient way of doing these tasks you are doing.\n", "\nJust use the killall command:\nkillall taskname\nfor more info and more advanced options, type \"man killall\".\n", "\nJust use the killall command:\nkillall taskname\nfor more info and more advanced options, type \"man killall\".\n", "\nJust use the killall command:\nkillall taskname\nfor more info and more advanced options, type \"man killall\".\n", "\nJust use the killall command:\nkillall taskname\nfor more info and more advanced options, type \"man killall\".\n", "\nJust use the killall command:\nkillall taskname\nfor more info and more advanced options, type \"man killall\".\n", "\nJust use the killall command:\nkillall taskname\nfor more info and more advanced options, type \"man killall\".\n", "\nJust use the killall command:\nkillall taskname\nfor more info and more advanced options, type \"man killall\".\n", "\nSuggesting command pkill -P PID pattern .\nNotice capital P.\nSee more documentation here.\n", "\nI encountered this problem lately. Finally, I found my processes were killed just after Opensuse zypper update was called automatically. To disable zypper update solved my problem.\n", "\nI encountered this problem lately. Finally, I found my processes were killed just after Opensuse zypper update was called automatically. To disable zypper update solved my problem.\n", "\nI encountered this problem lately. Finally, I found my processes were killed just after Opensuse zypper update was called automatically. To disable zypper update solved my problem.\n", "\nI encountered this problem lately. Finally, I found my processes were killed just after Opensuse zypper update was called automatically. To disable zypper update solved my problem.\n", "\nI encountered this problem lately. Finally, I found my processes were killed just after Opensuse zypper update was called automatically. To disable zypper update solved my problem.\n", "\nI encountered this problem lately. Finally, I found my processes were killed just after Opensuse zypper update was called automatically. To disable zypper update solved my problem.\n", "\nI encountered this problem lately. Finally, I found my processes were killed just after Opensuse zypper update was called automatically. To disable zypper update solved my problem.\n", "\nI encountered this problem lately. Finally, I found my processes were killed just after Opensuse zypper update was called automatically. To disable zypper update solved my problem.\n", "\nI encountered this problem lately. Finally, I found my processes were killed just after Opensuse zypper update was called automatically. To disable zypper update solved my problem.\n", "\nI encountered this problem lately. Finally, I found my processes were killed just after Opensuse zypper update was called automatically. To disable zypper update solved my problem.\n", "\nI encountered this problem lately. Finally, I found my processes were killed just after Opensuse zypper update was called automatically. To disable zypper update solved my problem.\n", "\nI encountered this problem lately. Finally, I found my processes were killed just after Opensuse zypper update was called automatically. To disable zypper update solved my problem.\n", "\nawk oneliner, which parses the header of ps output, so you don't need to care about column numbers (but column names). Support regex. For example, to kill all processes, which executable name (without path) contains word \"firefox\" try\nps -fe | awk 'NR==1{for (i=1; i<=NF; i++) {if ($i==\"COMMAND\") Ncmd=i; else if ($i==\"PID\") Npid=i} if (!Ncmd || !Npid) {print \"wrong or no header\" > \"/dev/stderr\"; exit} }$Ncmd~\"/\"name\"$\"{print \"killing \"$Ncmd\" with PID \" $Npid; system(\"kill \"$Npid)}' name=.*firefox.*\n\n", "\nawk oneliner, which parses the header of ps output, so you don't need to care about column numbers (but column names). Support regex. For example, to kill all processes, which executable name (without path) contains word \"firefox\" try\nps -fe | awk 'NR==1{for (i=1; i<=NF; i++) {if ($i==\"COMMAND\") Ncmd=i; else if ($i==\"PID\") Npid=i} if (!Ncmd || !Npid) {print \"wrong or no header\" > \"/dev/stderr\"; exit} }$Ncmd~\"/\"name\"$\"{print \"killing \"$Ncmd\" with PID \" $Npid; system(\"kill \"$Npid)}' name=.*firefox.*\n\n", "\nawk oneliner, which parses the header of ps output, so you don't need to care about column numbers (but column names). Support regex. For example, to kill all processes, which executable name (without path) contains word \"firefox\" try\nps -fe | awk 'NR==1{for (i=1; i<=NF; i++) {if ($i==\"COMMAND\") Ncmd=i; else if ($i==\"PID\") Npid=i} if (!Ncmd || !Npid) {print \"wrong or no header\" > \"/dev/stderr\"; exit} }$Ncmd~\"/\"name\"$\"{print \"killing \"$Ncmd\" with PID \" $Npid; system(\"kill \"$Npid)}' name=.*firefox.*\n\n", "\nawk oneliner, which parses the header of ps output, so you don't need to care about column numbers (but column names). Support regex. For example, to kill all processes, which executable name (without path) contains word \"firefox\" try\nps -fe | awk 'NR==1{for (i=1; i<=NF; i++) {if ($i==\"COMMAND\") Ncmd=i; else if ($i==\"PID\") Npid=i} if (!Ncmd || !Npid) {print \"wrong or no header\" > \"/dev/stderr\"; exit} }$Ncmd~\"/\"name\"$\"{print \"killing \"$Ncmd\" with PID \" $Npid; system(\"kill \"$Npid)}' name=.*firefox.*\n\n", "\nawk oneliner, which parses the header of ps output, so you don't need to care about column numbers (but column names). Support regex. For example, to kill all processes, which executable name (without path) contains word \"firefox\" try\nps -fe | awk 'NR==1{for (i=1; i<=NF; i++) {if ($i==\"COMMAND\") Ncmd=i; else if ($i==\"PID\") Npid=i} if (!Ncmd || !Npid) {print \"wrong or no header\" > \"/dev/stderr\"; exit} }$Ncmd~\"/\"name\"$\"{print \"killing \"$Ncmd\" with PID \" $Npid; system(\"kill \"$Npid)}' name=.*firefox.*\n\n", "\nawk oneliner, which parses the header of ps output, so you don't need to care about column numbers (but column names). Support regex. For example, to kill all processes, which executable name (without path) contains word \"firefox\" try\nps -fe | awk 'NR==1{for (i=1; i<=NF; i++) {if ($i==\"COMMAND\") Ncmd=i; else if ($i==\"PID\") Npid=i} if (!Ncmd || !Npid) {print \"wrong or no header\" > \"/dev/stderr\"; exit} }$Ncmd~\"/\"name\"$\"{print \"killing \"$Ncmd\" with PID \" $Npid; system(\"kill \"$Npid)}' name=.*firefox.*\n\n", "\nawk oneliner, which parses the header of ps output, so you don't need to care about column numbers (but column names). Support regex. For example, to kill all processes, which executable name (without path) contains word \"firefox\" try\nps -fe | awk 'NR==1{for (i=1; i<=NF; i++) {if ($i==\"COMMAND\") Ncmd=i; else if ($i==\"PID\") Npid=i} if (!Ncmd || !Npid) {print \"wrong or no header\" > \"/dev/stderr\"; exit} }$Ncmd~\"/\"name\"$\"{print \"killing \"$Ncmd\" with PID \" $Npid; system(\"kill \"$Npid)}' name=.*firefox.*\n\n", "\nawk oneliner, which parses the header of ps output, so you don't need to care about column numbers (but column names). Support regex. For example, to kill all processes, which executable name (without path) contains word \"firefox\" try\nps -fe | awk 'NR==1{for (i=1; i<=NF; i++) {if ($i==\"COMMAND\") Ncmd=i; else if ($i==\"PID\") Npid=i} if (!Ncmd || !Npid) {print \"wrong or no header\" > \"/dev/stderr\"; exit} }$Ncmd~\"/\"name\"$\"{print \"killing \"$Ncmd\" with PID \" $Npid; system(\"kill \"$Npid)}' name=.*firefox.*\n\n", "\nawk oneliner, which parses the header of ps output, so you don't need to care about column numbers (but column names). Support regex. For example, to kill all processes, which executable name (without path) contains word \"firefox\" try\nps -fe | awk 'NR==1{for (i=1; i<=NF; i++) {if ($i==\"COMMAND\") Ncmd=i; else if ($i==\"PID\") Npid=i} if (!Ncmd || !Npid) {print \"wrong or no header\" > \"/dev/stderr\"; exit} }$Ncmd~\"/\"name\"$\"{print \"killing \"$Ncmd\" with PID \" $Npid; system(\"kill \"$Npid)}' name=.*firefox.*\n\n", "\nawk oneliner, which parses the header of ps output, so you don't need to care about column numbers (but column names). Support regex. For example, to kill all processes, which executable name (without path) contains word \"firefox\" try\nps -fe | awk 'NR==1{for (i=1; i<=NF; i++) {if ($i==\"COMMAND\") Ncmd=i; else if ($i==\"PID\") Npid=i} if (!Ncmd || !Npid) {print \"wrong or no header\" > \"/dev/stderr\"; exit} }$Ncmd~\"/\"name\"$\"{print \"killing \"$Ncmd\" with PID \" $Npid; system(\"kill \"$Npid)}' name=.*firefox.*\n\n", "\nawk oneliner, which parses the header of ps output, so you don't need to care about column numbers (but column names). Support regex. For example, to kill all processes, which executable name (without path) contains word \"firefox\" try\nps -fe | awk 'NR==1{for (i=1; i<=NF; i++) {if ($i==\"COMMAND\") Ncmd=i; else if ($i==\"PID\") Npid=i} if (!Ncmd || !Npid) {print \"wrong or no header\" > \"/dev/stderr\"; exit} }$Ncmd~\"/\"name\"$\"{print \"killing \"$Ncmd\" with PID \" $Npid; system(\"kill \"$Npid)}' name=.*firefox.*\n\n", "\nawk oneliner, which parses the header of ps output, so you don't need to care about column numbers (but column names). Support regex. For example, to kill all processes, which executable name (without path) contains word \"firefox\" try\nps -fe | awk 'NR==1{for (i=1; i<=NF; i++) {if ($i==\"COMMAND\") Ncmd=i; else if ($i==\"PID\") Npid=i} if (!Ncmd || !Npid) {print \"wrong or no header\" > \"/dev/stderr\"; exit} }$Ncmd~\"/\"name\"$\"{print \"killing \"$Ncmd\" with PID \" $Npid; system(\"kill \"$Npid)}' name=.*firefox.*\n\n", "\nawk oneliner, which parses the header of ps output, so you don't need to care about column numbers (but column names). Support regex. For example, to kill all processes, which executable name (without path) contains word \"firefox\" try\nps -fe | awk 'NR==1{for (i=1; i<=NF; i++) {if ($i==\"COMMAND\") Ncmd=i; else if ($i==\"PID\") Npid=i} if (!Ncmd || !Npid) {print \"wrong or no header\" > \"/dev/stderr\"; exit} }$Ncmd~\"/\"name\"$\"{print \"killing \"$Ncmd\" with PID \" $Npid; system(\"kill \"$Npid)}' name=.*firefox.*\n\n", "\nawk oneliner, which parses the header of ps output, so you don't need to care about column numbers (but column names). Support regex. For example, to kill all processes, which executable name (without path) contains word \"firefox\" try\nps -fe | awk 'NR==1{for (i=1; i<=NF; i++) {if ($i==\"COMMAND\") Ncmd=i; else if ($i==\"PID\") Npid=i} if (!Ncmd || !Npid) {print \"wrong or no header\" > \"/dev/stderr\"; exit} }$Ncmd~\"/\"name\"$\"{print \"killing \"$Ncmd\" with PID \" $Npid; system(\"kill \"$Npid)}' name=.*firefox.*\n\n", "\nawk oneliner, which parses the header of ps output, so you don't need to care about column numbers (but column names). Support regex. For example, to kill all processes, which executable name (without path) contains word \"firefox\" try\nps -fe | awk 'NR==1{for (i=1; i<=NF; i++) {if ($i==\"COMMAND\") Ncmd=i; else if ($i==\"PID\") Npid=i} if (!Ncmd || !Npid) {print \"wrong or no header\" > \"/dev/stderr\"; exit} }$Ncmd~\"/\"name\"$\"{print \"killing \"$Ncmd\" with PID \" $Npid; system(\"kill \"$Npid)}' name=.*firefox.*\n\n", "\nawk oneliner, which parses the header of ps output, so you don't need to care about column numbers (but column names). Support regex. For example, to kill all processes, which executable name (without path) contains word \"firefox\" try\nps -fe | awk 'NR==1{for (i=1; i<=NF; i++) {if ($i==\"COMMAND\") Ncmd=i; else if ($i==\"PID\") Npid=i} if (!Ncmd || !Npid) {print \"wrong or no header\" > \"/dev/stderr\"; exit} }$Ncmd~\"/\"name\"$\"{print \"killing \"$Ncmd\" with PID \" $Npid; system(\"kill \"$Npid)}' name=.*firefox.*\n\n", "\nawk oneliner, which parses the header of ps output, so you don't need to care about column numbers (but column names). Support regex. For example, to kill all processes, which executable name (without path) contains word \"firefox\" try\nps -fe | awk 'NR==1{for (i=1; i<=NF; i++) {if ($i==\"COMMAND\") Ncmd=i; else if ($i==\"PID\") Npid=i} if (!Ncmd || !Npid) {print \"wrong or no header\" > \"/dev/stderr\"; exit} }$Ncmd~\"/\"name\"$\"{print \"killing \"$Ncmd\" with PID \" $Npid; system(\"kill \"$Npid)}' name=.*firefox.*\n\n", "\nWith inspiration from Basile Starynkevitch I used this simple loop, there I afterwards waits for the children.\n/* Searches through all directories in /proc */\nwhile((dent = readdir(srcdir)) != NULL) {\n    /* If numerical */\n    if (dent->d_name[0] >= '0' && dent->d_name[0] <= '9') {\n        /* Take data from /proc/[pid]/stat, see URL below for more info */\n        /* http://man7.org/linux/man-pages/man5/proc.5.html */\n        sprintf(path, \"/proc/%s/stat\", dent->d_name);\n        stat_f = fopen(path,\"r\");\n        fscanf(stat_f, \"%d %*s %*c %d\", &pid, &ppid);\n        fclose(stat_f);\n        /* Kill if shell is parent to process */\n        if (shell_pid == ppid) kill(pid, SIGKILL);\n    }\n}\n\n", "\nWith inspiration from Basile Starynkevitch I used this simple loop, there I afterwards waits for the children.\n/* Searches through all directories in /proc */\nwhile((dent = readdir(srcdir)) != NULL) {\n    /* If numerical */\n    if (dent->d_name[0] >= '0' && dent->d_name[0] <= '9') {\n        /* Take data from /proc/[pid]/stat, see URL below for more info */\n        /* http://man7.org/linux/man-pages/man5/proc.5.html */\n        sprintf(path, \"/proc/%s/stat\", dent->d_name);\n        stat_f = fopen(path,\"r\");\n        fscanf(stat_f, \"%d %*s %*c %d\", &pid, &ppid);\n        fclose(stat_f);\n        /* Kill if shell is parent to process */\n        if (shell_pid == ppid) kill(pid, SIGKILL);\n    }\n}\n\n", "\nWith inspiration from Basile Starynkevitch I used this simple loop, there I afterwards waits for the children.\n/* Searches through all directories in /proc */\nwhile((dent = readdir(srcdir)) != NULL) {\n    /* If numerical */\n    if (dent->d_name[0] >= '0' && dent->d_name[0] <= '9') {\n        /* Take data from /proc/[pid]/stat, see URL below for more info */\n        /* http://man7.org/linux/man-pages/man5/proc.5.html */\n        sprintf(path, \"/proc/%s/stat\", dent->d_name);\n        stat_f = fopen(path,\"r\");\n        fscanf(stat_f, \"%d %*s %*c %d\", &pid, &ppid);\n        fclose(stat_f);\n        /* Kill if shell is parent to process */\n        if (shell_pid == ppid) kill(pid, SIGKILL);\n    }\n}\n\n"]}