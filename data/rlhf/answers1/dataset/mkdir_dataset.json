{"prompt": ["So, if I'm in my home directory and I want to move foo.c to ~/bar/baz/foo.c , but those directories don't exist, is there some way to have those directories automatically created, so that you would only have to typemv foo.c ~/bar/baz/ \nand everything would work out? It seems like you could alias mv to a simple bash script that would check if those directories existed and if not would call mkdir and then mv, but I thought I'd check to see if anyone had a better idea.", "So, if I'm in my home directory and I want to move foo.c to ~/bar/baz/foo.c , but those directories don't exist, is there some way to have those directories automatically created, so that you would only have to typemv foo.c ~/bar/baz/ \nand everything would work out? It seems like you could alias mv to a simple bash script that would check if those directories existed and if not would call mkdir and then mv, but I thought I'd check to see if anyone had a better idea.", "So, if I'm in my home directory and I want to move foo.c to ~/bar/baz/foo.c , but those directories don't exist, is there some way to have those directories automatically created, so that you would only have to typemv foo.c ~/bar/baz/ \nand everything would work out? It seems like you could alias mv to a simple bash script that would check if those directories existed and if not would call mkdir and then mv, but I thought I'd check to see if anyone had a better idea.", "So, if I'm in my home directory and I want to move foo.c to ~/bar/baz/foo.c , but those directories don't exist, is there some way to have those directories automatically created, so that you would only have to typemv foo.c ~/bar/baz/ \nand everything would work out? It seems like you could alias mv to a simple bash script that would check if those directories existed and if not would call mkdir and then mv, but I thought I'd check to see if anyone had a better idea.", "So, if I'm in my home directory and I want to move foo.c to ~/bar/baz/foo.c , but those directories don't exist, is there some way to have those directories automatically created, so that you would only have to typemv foo.c ~/bar/baz/ \nand everything would work out? It seems like you could alias mv to a simple bash script that would check if those directories existed and if not would call mkdir and then mv, but I thought I'd check to see if anyone had a better idea.", "So, if I'm in my home directory and I want to move foo.c to ~/bar/baz/foo.c , but those directories don't exist, is there some way to have those directories automatically created, so that you would only have to typemv foo.c ~/bar/baz/ \nand everything would work out? It seems like you could alias mv to a simple bash script that would check if those directories existed and if not would call mkdir and then mv, but I thought I'd check to see if anyone had a better idea.", "So, if I'm in my home directory and I want to move foo.c to ~/bar/baz/foo.c , but those directories don't exist, is there some way to have those directories automatically created, so that you would only have to typemv foo.c ~/bar/baz/ \nand everything would work out? It seems like you could alias mv to a simple bash script that would check if those directories existed and if not would call mkdir and then mv, but I thought I'd check to see if anyone had a better idea.", "So, if I'm in my home directory and I want to move foo.c to ~/bar/baz/foo.c , but those directories don't exist, is there some way to have those directories automatically created, so that you would only have to typemv foo.c ~/bar/baz/ \nand everything would work out? It seems like you could alias mv to a simple bash script that would check if those directories existed and if not would call mkdir and then mv, but I thought I'd check to see if anyone had a better idea.", "So, if I'm in my home directory and I want to move foo.c to ~/bar/baz/foo.c , but those directories don't exist, is there some way to have those directories automatically created, so that you would only have to typemv foo.c ~/bar/baz/ \nand everything would work out? It seems like you could alias mv to a simple bash script that would check if those directories existed and if not would call mkdir and then mv, but I thought I'd check to see if anyone had a better idea.", "So, if I'm in my home directory and I want to move foo.c to ~/bar/baz/foo.c , but those directories don't exist, is there some way to have those directories automatically created, so that you would only have to typemv foo.c ~/bar/baz/ \nand everything would work out? It seems like you could alias mv to a simple bash script that would check if those directories existed and if not would call mkdir and then mv, but I thought I'd check to see if anyone had a better idea.", "So, if I'm in my home directory and I want to move foo.c to ~/bar/baz/foo.c , but those directories don't exist, is there some way to have those directories automatically created, so that you would only have to typemv foo.c ~/bar/baz/ \nand everything would work out? It seems like you could alias mv to a simple bash script that would check if those directories existed and if not would call mkdir and then mv, but I thought I'd check to see if anyone had a better idea.", "So, if I'm in my home directory and I want to move foo.c to ~/bar/baz/foo.c , but those directories don't exist, is there some way to have those directories automatically created, so that you would only have to typemv foo.c ~/bar/baz/ \nand everything would work out? It seems like you could alias mv to a simple bash script that would check if those directories existed and if not would call mkdir and then mv, but I thought I'd check to see if anyone had a better idea.", "So, if I'm in my home directory and I want to move foo.c to ~/bar/baz/foo.c , but those directories don't exist, is there some way to have those directories automatically created, so that you would only have to typemv foo.c ~/bar/baz/ \nand everything would work out? It seems like you could alias mv to a simple bash script that would check if those directories existed and if not would call mkdir and then mv, but I thought I'd check to see if anyone had a better idea.", "So, if I'm in my home directory and I want to move foo.c to ~/bar/baz/foo.c , but those directories don't exist, is there some way to have those directories automatically created, so that you would only have to typemv foo.c ~/bar/baz/ \nand everything would work out? It seems like you could alias mv to a simple bash script that would check if those directories existed and if not would call mkdir and then mv, but I thought I'd check to see if anyone had a better idea.", "So, if I'm in my home directory and I want to move foo.c to ~/bar/baz/foo.c , but those directories don't exist, is there some way to have those directories automatically created, so that you would only have to typemv foo.c ~/bar/baz/ \nand everything would work out? It seems like you could alias mv to a simple bash script that would check if those directories existed and if not would call mkdir and then mv, but I thought I'd check to see if anyone had a better idea.", "So, if I'm in my home directory and I want to move foo.c to ~/bar/baz/foo.c , but those directories don't exist, is there some way to have those directories automatically created, so that you would only have to typemv foo.c ~/bar/baz/ \nand everything would work out? It seems like you could alias mv to a simple bash script that would check if those directories existed and if not would call mkdir and then mv, but I thought I'd check to see if anyone had a better idea.", "So, if I'm in my home directory and I want to move foo.c to ~/bar/baz/foo.c , but those directories don't exist, is there some way to have those directories automatically created, so that you would only have to typemv foo.c ~/bar/baz/ \nand everything would work out? It seems like you could alias mv to a simple bash script that would check if those directories existed and if not would call mkdir and then mv, but I thought I'd check to see if anyone had a better idea.", "So, if I'm in my home directory and I want to move foo.c to ~/bar/baz/foo.c , but those directories don't exist, is there some way to have those directories automatically created, so that you would only have to typemv foo.c ~/bar/baz/ \nand everything would work out? It seems like you could alias mv to a simple bash script that would check if those directories existed and if not would call mkdir and then mv, but I thought I'd check to see if anyone had a better idea.", "So, if I'm in my home directory and I want to move foo.c to ~/bar/baz/foo.c , but those directories don't exist, is there some way to have those directories automatically created, so that you would only have to typemv foo.c ~/bar/baz/ \nand everything would work out? It seems like you could alias mv to a simple bash script that would check if those directories existed and if not would call mkdir and then mv, but I thought I'd check to see if anyone had a better idea.", "So, if I'm in my home directory and I want to move foo.c to ~/bar/baz/foo.c , but those directories don't exist, is there some way to have those directories automatically created, so that you would only have to typemv foo.c ~/bar/baz/ \nand everything would work out? It seems like you could alias mv to a simple bash script that would check if those directories existed and if not would call mkdir and then mv, but I thought I'd check to see if anyone had a better idea.", "I have a bash script that sets a directory as a lock, and if the lock is in place then it send a message to the user who attempted to run it.I'm wondering if its possible to somehow suppress the \"directory already exists\" message, but still run the other function (warning_run_in_place). Because if using the -p flag on mkdir it would not execute the warning_run_in_place portion.Essentially it's something likemkdir MYLOCK || warning_run_in_place\n\nwarning_run_in_place() \n{\n  echo \"Hey I'm already running...\"\n  exit 1;\n}\n\n", "I'm trying to solve bandit24 on overthe wire on ubuntu virtual machine.\nI have already seen the solution.\nBut i have a problem,when i try to create a directory on tmp as bandit24@bandit i get this message:\nCannot create directory \"name_of_directory\": file exists.\nIf I try with find command there is only  the \".\" directory and with ls I get the message:\nCannot open directory '.' : permission denied.\nI also have tried with ls -l on tmp and I get the message:\nCannot open directory 'tmp': Permission denied\nWhat else could I do?\nWhat could be the problem?", "I'm new to shell scripting. I'm trying to create a main folder called Analysis. In the Analysis folder I would like four sub-folders named, PhenV1, PhenV2, HypV1, and HypV2. I then want to have each of those four sub-folders have another 2 folders named Genes and Variants and in each of the Genes and Variants folders to have two more folders named CNV and SNV. The directory structure is depicted by the image below. Here is what I've attemptedmkdir -p Analysis/PhenV1/{Genes/{CNV,SNV},Variants/{CNV,SNV},PhenV2/{Genes/{CNV,SNV},Variants/{CNV,SNV},HypV1/{Genes/{CNV,SNV},Variants/{CNV,SNV},HypV2/{Genes/{CNV,SNV},Variants/{CNV,SNV}}\nThis code only creates the parent folder Analysis, and subdirectories, PhenV1 and {Genes''m", "#!/bin/sh\nDOMAINLIST='*.io.domain.fun io.domain.fun *.*.domain.fun'\n\nfor i in $DOMAINLIST\ndo\n    mkdir $i\ndone\nThis shell code run out unreadable directory nameon my windows 10 . chinese character set$ dir\n_2X68P~X.A   _E2MJ8~X.FUN  \n\non my linux# ls -alh .\ntotal 32K\ndrwxr-xr-x 5 admin administrators 4.0K 2022-04-09 12:33 ./\ndrwxr-xr-x 6 admin administrators 4.0K 2022-04-09 11:06 ../\ndrwxr-xr-x 2 admin administrators 4.0K 2022-04-09 12:33 *.io.17lai.fun/\ndrwxr-xr-x 2 admin administrators 4.0K 2022-04-09 12:33 *.a/\nmaybe this is a character set problem?", "I'm running a shell script for some testing and I'm having a weird issue. The script is meant to run tests and then grab the logs and move them to folders. Here's my code:#!/bin/bash\n\n# Variables\narg_1=$1        # $1 is argument PATH\narg_2=$2        # $2 is argument NAME\n\ncount=1\n\nfor i in 32 64 128\ndo\n    # Case statement to go between different tests\n    case $count in\n        1) # test 1 (32MB test) ;;\n        2) # test 2 (64MB test);;\n        3) # test 3 (128MB test);;\n        *) break ;;\n\n    # Make directories\n    mkdir ${2}_${i}MB    # Specific MB test\n    mkdir ${2}_lat       # Latency logs\n    mkdir ${2}_times     # Timings\n   \n    # Move logs here \n    for j in {1..10}\n    do\n        mv lat_log_$j ${2}_lat\n    done\n\n    for j in {1..5}\n    do\n        mv times_$j ${2}_times\n    done\n    \n    # Move files\n    mv ${2}_lat ${2}_times ${2}_${i}MB\n    mv ${2}_${i}MB $2\n\n    # Increment Count\n    ((count++))\ndone\nSo here's my problem: in the initial for loop when i = 32 is ran, the specific directory ${2}_32MB isn't being created. However, subsequent loops make the files just fine. So ${2}_64MB and ${2}_128MB are created normally. I'm not sure what the issue is :(", "ls -1 | sort -V > txt_list\nandcat txt_list\ngivesASOFJ.txt\nBJWIF.txt\nCWORI.txt\n...\nI want to mkdir with suffix in ascending order like folder_1, folder_2, folder_3and mv ASOFJ.txt folder_1 , mv BJWIF.txt folder_2, mv CWORI.txt folder_3I have triednum=0 ; while read p ; do ( num=$(expr $num + 1) && mkdir \"folder_\"$num && mv $p \"folder_\"$num ) ; done < txt_list\nBut it didn't work.Do you have any idea on a one-liner that executes the above?Thanks."], "chosen": ["\nmkdir -p `dirname /destination/moved_file_name.txt`  \nmv /full/path/the/file.txt  /destination/moved_file_name.txt\n\n", "\nHow about this one-liner (in bash):\nmkdir --parents ./some/path/; mv yourfile.txt $_\n\nBreaking that down:\nmkdir --parents ./some/path\n# if it doesn't work; try\nmkdir -p ./some/path\n\ncreates the directory (including all intermediate directories), after which:\nmv yourfile.txt $_\n\nmoves the file to that directory ($_ expands to the last argument passed to the previous shell command, ie: the newly created directory).\nI am not sure how far this will work in other shells, but it might give you some ideas about what to look for.\nHere is an example using this technique:\n$ > ls\n$ > touch yourfile.txt\n$ > ls\nyourfile.txt\n$ > mkdir --parents ./some/path/; mv yourfile.txt $_\n$ > ls -F\nsome/\n$ > ls some/path/\nyourfile.txt\n\n", "\nSave as a script named mv.sh\n#!/bin/bash\n# mv.sh\ndir=\"$2\" # Include a / at the end to indicate directory (not filename)\ntmp=\"$2\"; tmp=\"${tmp: -1}\"\n[ \"$tmp\" != \"/\" ] && dir=\"$(dirname \"$2\")\"\n[ -a \"$dir\" ] ||\nmkdir -p \"$dir\" &&\nmv \"$@\"\n\nOr put at the end of your ~/.bashrc file as a function that replaces the default mv on every new terminal. Using a function allows bash keep it memory, instead of having to read a script file every time.\nfunction mvp ()\n{\n    dir=\"$2\" # Include a / at the end to indicate directory (not filename)\n    tmp=\"$2\"; tmp=\"${tmp: -1}\"\n    [ \"$tmp\" != \"/\" ] && dir=\"$(dirname \"$2\")\"\n    [ -a \"$dir\" ] ||\n    mkdir -p \"$dir\" &&\n    mv \"$@\"\n}\n\nExample usage:\nmv.sh file ~/Download/some/new/path/ # <-End with slash\n\nThese based on the submission of Chris Lutz.\n", "\nYou can use mkdir:\nmkdir -p ~/bar/baz/ && \\\nmv foo.c ~/bar/baz/\n\nA simple script to do it automatically (untested):\n#!/bin/sh\n\n# Grab the last argument (argument number $#)    \neval LAST_ARG=\\$$#\n\n# Strip the filename (if it exists) from the destination, getting the directory\nDIR_NAME=`echo $2 | sed -e 's_/[^/]*$__'`\n\n# Move to the directory, making the directory if necessary\nmkdir -p \"$DIR_NAME\" || exit\nmv \"$@\"\n\n", "\nIt sounds like the answer is no :). I don't really want to create an alias or func just to do this, often because it's one-off and I'm already in the middle of typing the mv command, but I found something that works well for that:\nmv *.sh shell_files/also_with_subdir/ || mkdir -p $_\n\nIf mv fails (dir does not exist), it will make the directory (which is the last argument to the previous command, so $_ has it). So just run this command, then up to re-run it, and this time mv should succeed.\n", "\nThe simplest way to do it is:\nmkdir -p [path/to/directory] && mv [filename] $_\n\nThe nice part about this is it will only move the file if mkdir succeeds.\n\nExplanation:\nLet's suppose I downloaded some PDF files located in my directory (~/download ). I want to move all of them into a directory that doesn't exist (let's say my_PDF).\nI'll type the following command (making sure my current working directory is ~/download):\nmkdir my_PDF && mv *.pdf $_\n\nYou can add -p option to mkdir if you want to create subdirectories just like this: (supposed I want to create a subdirectory named python):\nmkdir -p my_PDF/python && mv *.pdf $_\n\n", "\nMaking use of the tricks in \"Getting the last argument passed to a shell script\" we can make a simple shell function that should work no matter how many files you want to move:\n# Bash only\nmvdir() { mkdir -p \"${@: -1}\" && mv \"$@\"; }\n\n# Other shells may need to search for the last argument\nmvdir() { for last; do true; done; mkdir -p \"$last\" && mv \"$@\"; }\n\nUse the command like this:\nmvdir foo.c foo.h ~/some/new/folder/\n\n", "\nrsync command can do the trick only if the last directory in the destination path doesn't exist, e.g. for the destination path of ~/bar/baz/ if bar exists but baz doesn't, then the following command can be used:\nrsync -av --remove-source-files foo.c ~/bar/baz/\n-a, --archive               archive mode; equals -rlptgoD (no -H,-A,-X)\n-v, --verbose               increase verbosity\n--remove-source-files   sender removes synchronized files (non-dir)\n\nIn this case baz directory will be created if it doesn't exist. But if both bar and baz don't exist rsync will fail:\nsending incremental file list\nrsync: mkdir \"/root/bar/baz\" failed: No such file or directory (2)\nrsync error: error in file IO (code 11) at main.c(657) [Receiver=3.1.2]\n\nSo basically it should be safe to use rsync -av --remove-source-files as an alias for mv.\n", "\nThe following shell script, perhaps?\n#!/bin/sh\nif [[ -e $1 ]]\nthen\n  if [[ ! -d $2 ]]\n  then\n    mkdir --parents $2\n  fi\nfi\nmv $1 $2\n\nThat's the basic part. You might want to add in a bit to check for arguments, and you may want the behavior to change if the destination exists, or the source directory exists, or doesn't exist (i.e. don't overwrite something that doesn't exist).\n", "\nBased on a comment in another answer, here's my shell function.\n# mvp = move + create parents\nfunction mvp () {\n    source=\"$1\"\n    target=\"$2\"\n    target_dir=\"$(dirname \"$target\")\"\n    mkdir --parents $target_dir; mv $source $target\n}\n\nInclude this in .bashrc or similar so you can use it everywhere.\n", "\ni accomplished this with the install command on linux:\nroot@logstash:# myfile=bash_history.log.2021-02-04.gz ; install -v -p -D $myfile /tmp/a/b/$myfile\n\nbash_history.log.2021-02-04.gz -> /tmp/a/b/bash_history.log.2021-02-04.gz\n\nthe only downside being the file permissions are changed:\nroot@logstash:# ls -lh /tmp/a/b/\n\n-rwxr-xr-x 1 root root 914 Fev  4 09:11 bash_history.log.2021-02-04.gz\n\nif you dont mind resetting the permission, you can use:\n-g, --group=GROUP   set group ownership, instead of process' current group\n-m, --mode=MODE     set permission mode (as in chmod), instead of rwxr-xr-x\n-o, --owner=OWNER   set ownership (super-user only)\n\n", "\nCode:\nif [[ -e $1 && ! -e $2 ]]; then\n   mkdir --parents --verbose -- \"$(dirname -- \"$2\")\"\nfi\nmv --verbose -- \"$1\" \"$2\"\n\nExample:\narguments: \"d1\" \"d2/sub\"\nmkdir: created directory 'd2'\nrenamed 'd1' -> 'd2/sub'\n\n", "\nSillier, but working way:\nmkdir -p $2\nrmdir $2\nmv $1 $2\n\nMake the directory with mkdir -p including a temporary directory that is shares the destination file name, then remove that file name directory with a simple rmdir, then move your file to its new destination.\nI think answer using dirname is probably the best though.\n", "\nThis will move foo.c to the new directory baz with the parent directory bar.\nmv foo.c `mkdir -p ~/bar/baz/ && echo $_`\n\nThe -p option to mkdir will create intermediate directories as required.\nWithout -p all directories in the path prefix must already exist.\nEverything inside backticks `` is executed and the output is returned in-line as part of your command.\nSince mkdir doesn't return anything, only the output of echo $_ will be added to the command.\n$_ references the last argument to the previously executed command.\nIn this case, it will return the path to your new directory (~/bar/baz/) passed to the mkdir command.\n\nI unzipped an archive without giving a destination and wanted to move all the files except `demo-app.zip` from my current directory to a new directory called `demo-app`. The following line does the trick:\nmv `ls -A | grep -v demo-app.zip` `mkdir -p demo-app && echo $_`\n\nls -A returns all file names including hidden files (except for the implicit . and ..).\nThe pipe symbol | is used to pipe the output of the ls command to grep (a command-line, plain-text search utility).\nThe -v flag directs grep to find and return all file names excluding demo-app.zip.\nThat list of files is added to our command-line as source arguments to the move command mv. The target argument is the path to the new directory passed to mkdir referenced using $_ and output using echo.\n", "\nI frequently stumble upon this issue while bulk moving files to new subdirectories. Ideally, I want to do this:\nmv * newdir/  \n\nMost of the answers in this thread propose to mkdir and then mv, but this results in:\nmkdir newdir && mv * newdir \nmv: cannot move 'newdir/' to a subdirectory of itself\n\nThe problem I face is slightly different in that I want to blanket move everything, and, if I create the new directory before moving then it also tries to move the new directory to itself. So, I work around this by using the parent directory:\nmkdir ../newdir && mv * ../newdir && mv ../newdir .\n\nCaveats: Does not work in the root folder (/).\n", "\n((cd src-path && tar --remove-files -cf - files-to-move) | ( cd dst-path && tar -xf -))\n\n", "\nThere's a lot of conflicting solutions around for this, here's what worked for us:\n## ss_mv ##\nfunction ss_mv {\n    mkdir -p $(dirname \"$2\") && mv -f \"$@\"\n}\n\nThis assumes commands in the following syntax:\nss_mv /var/www/myfile /var/www/newdir/myfile\n\nIn this way the directory path /var/www/newdir is extracted from the 2nd part of the command, and that new directory is then created (it's critical that you use the dirname tag to avoid myfile being added to the new directory being created).\nThen we go ahead and mv on the entire string again by using the \"$@\" tag.\n", "\nI wrote a script that is a drop-in replacement for mv\nthat should handle all the edge cases,\nincluding the cases where the destination is a file\nbut in a non-existent directory\nor a non-existent directory itself,\nand the case that there are options to be passed to mv,\nand is compliant with POSIX sh.\n#!/bin/sh\n# USAGE:\n# mkdmv [-if] source_file target_file\n# mkdmv [-if] source_file... target_dir\nmkdmv() {\n    n=0 endofargs=\n    for arg; do\n        if [ -n \"$endofargs\" ] || [ \"${arg#-}\" = \"$arg\" ]; then\n            # dest will be set to last non-option arg\n            n=$((n+1)) dest=$arg\n        elif [ \"$arg\" = '--' ]; then\n            endofargs=1\n        fi\n    done\n    # dest is a dir to be created\n    # if there are multiple src files\n    # or if target ends with \"/\"\n    if [ \"$n\" -gt 2 ] || [ \"${dest%/}\" != \"$dest\" ]; then\n        # append `.` to prevent `dirname` from returning parent dir\n        dest=\"$dest/.\"\n    fi\n    mkdir -p -- \"$(dirname -- \"$dest\")\" &&\n        mv \"$@\"\n}\n\n", "\nMy one string solution:\ntest -d \"/home/newdir/\" || mkdir -p \"/home/newdir/\" && mv /home/test.txt /home/newdir/\n\n", "\nYou can even use brace extensions:\nmkdir -p directory{1..3}/subdirectory{1..3}/subsubdirectory{1..2}\n\n\nwhich creates 3 directories (directory1, directory2, directory3),\n\nand in each one of them two subdirectories (subdirectory1, subdirectory2),\n\nand in each of them two subsubdirectories (subsubdirectory1 and subsubdirectory2).\n\n\n\n\n\nYou have to use bash 3.0 or newer.\n", "\nSuggesting -p option in mkdir command (as documented here):\n  mkdir -p MYLOCK || warning_run_in_place\n\n", "\n\nIt means that there is a directory under /tmp/ with the same name that you specified. But since you did not create it (in this case, someone created with a different bandit user), you cannot view it. There is not read permission for bandit24 to access it.\nSince /tmp/ is directory accessible for all user accounts, you cannot list the files/directories under it without the root permission. (Which means the root of the bandit machine has configured like that) \n\nWhat you need to do\nTry a random name. Create anything random under /tmp/. It will work. \n", "\nYour brackets are not properly balanced. Try:\nAnalysis/{PhenV1/{Genes/{CNV,SNV},Variants/{CNV,SNV}},PhenV2/{Genes/{CNV,SNV},Variants/{CNV,SNV}},HypV1/{Genes/{CNV,SN},Variants/{CMC,VT}},HypV2/{Genes/{CNV,SNV},Variants/{CNV,SNV}}}\n\nWhich can be simplified a bit:\nAnalysis/{{PhenV1,PhenV2,HypV2}/{Genes,Variants}/{CNV,SNV},HypV1/{Genes/{CNV,SN},Variants/{CMC,VT}}}\n\n", "\nit's probably not a good practice, but you can escape special characters with \\ (e.g. mkdir '\\*.a')\n", "\nTry adding 16 before 32 in for loop. Best guess its just skipping?\n", "\n#!/bin/bash\n\ncounter=1\nwhile read line\ndo\n    mkdir \"folder_${counter}\" && mv $line \"folder_${counter}\"\n    ((counter++))\ndone <<< $(ls -1 | sort -V)\n\n"], "rejected": ["\n$what=/path/to/file;\n$dest=/dest/path;\n\nmkdir -p \"$(dirname \"$dest\")\";\nmv \"$what\" \"$dest\"\n\n", "\n$what=/path/to/file;\n$dest=/dest/path;\n\nmkdir -p \"$(dirname \"$dest\")\";\nmv \"$what\" \"$dest\"\n\n", "\n$what=/path/to/file;\n$dest=/dest/path;\n\nmkdir -p \"$(dirname \"$dest\")\";\nmv \"$what\" \"$dest\"\n\n", "\n$what=/path/to/file;\n$dest=/dest/path;\n\nmkdir -p \"$(dirname \"$dest\")\";\nmv \"$what\" \"$dest\"\n\n", "\n$what=/path/to/file;\n$dest=/dest/path;\n\nmkdir -p \"$(dirname \"$dest\")\";\nmv \"$what\" \"$dest\"\n\n", "\n$what=/path/to/file;\n$dest=/dest/path;\n\nmkdir -p \"$(dirname \"$dest\")\";\nmv \"$what\" \"$dest\"\n\n", "\n$what=/path/to/file;\n$dest=/dest/path;\n\nmkdir -p \"$(dirname \"$dest\")\";\nmv \"$what\" \"$dest\"\n\n", "\n$what=/path/to/file;\n$dest=/dest/path;\n\nmkdir -p \"$(dirname \"$dest\")\";\nmv \"$what\" \"$dest\"\n\n", "\n$what=/path/to/file;\n$dest=/dest/path;\n\nmkdir -p \"$(dirname \"$dest\")\";\nmv \"$what\" \"$dest\"\n\n", "\n$what=/path/to/file;\n$dest=/dest/path;\n\nmkdir -p \"$(dirname \"$dest\")\";\nmv \"$what\" \"$dest\"\n\n", "\n$what=/path/to/file;\n$dest=/dest/path;\n\nmkdir -p \"$(dirname \"$dest\")\";\nmv \"$what\" \"$dest\"\n\n", "\n$what=/path/to/file;\n$dest=/dest/path;\n\nmkdir -p \"$(dirname \"$dest\")\";\nmv \"$what\" \"$dest\"\n\n", "\n$what=/path/to/file;\n$dest=/dest/path;\n\nmkdir -p \"$(dirname \"$dest\")\";\nmv \"$what\" \"$dest\"\n\n", "\n$what=/path/to/file;\n$dest=/dest/path;\n\nmkdir -p \"$(dirname \"$dest\")\";\nmv \"$what\" \"$dest\"\n\n", "\n$what=/path/to/file;\n$dest=/dest/path;\n\nmkdir -p \"$(dirname \"$dest\")\";\nmv \"$what\" \"$dest\"\n\n", "\n$what=/path/to/file;\n$dest=/dest/path;\n\nmkdir -p \"$(dirname \"$dest\")\";\nmv \"$what\" \"$dest\"\n\n", "\n$what=/path/to/file;\n$dest=/dest/path;\n\nmkdir -p \"$(dirname \"$dest\")\";\nmv \"$what\" \"$dest\"\n\n", "\n$what=/path/to/file;\n$dest=/dest/path;\n\nmkdir -p \"$(dirname \"$dest\")\";\nmv \"$what\" \"$dest\"\n\n", "\n$what=/path/to/file;\n$dest=/dest/path;\n\nmkdir -p \"$(dirname \"$dest\")\";\nmv \"$what\" \"$dest\"\n\n", "\n$what=/path/to/file;\n$dest=/dest/path;\n\nmkdir -p \"$(dirname \"$dest\")\";\nmv \"$what\" \"$dest\"\n\n", "\nYou should replace:\nmkdir MYLOCK\nby:\nmkdir MYLOCK 2>/dev/null\n", "\nTry to prepend sudo at your command. Seems you don't have permissions to read the /tmp directory, what is pretty weird.\nExample that might works:\nTo list the /tmp contents:\nsudo ls -l /tmp\n\nTo create the 'my_new_dir' inside /tmp:\nsudo mkdir /tmp/my_new_dir \n\n", "\nmkdir -p Analysis/{PhenV1,Phenv2,HypV1,HypV2}/{Genes,Variants}/{CNV,SNV}\n\nCreates:\n$ tree\n.\n\u2514\u2500\u2500 Analysis\n    \u251c\u2500\u2500 HypV1\n    \u2502\u00a0\u00a0 \u251c\u2500\u2500 Genes\n    \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 CNV\n    \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 SNV\n    \u2502\u00a0\u00a0 \u2514\u2500\u2500 Variants\n    \u2502\u00a0\u00a0     \u251c\u2500\u2500 CNV\n    \u2502\u00a0\u00a0     \u2514\u2500\u2500 SNV\n    \u251c\u2500\u2500 HypV2\n    \u2502\u00a0\u00a0 \u251c\u2500\u2500 Genes\n    \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 CNV\n    \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 SNV\n    \u2502\u00a0\u00a0 \u2514\u2500\u2500 Variants\n    \u2502\u00a0\u00a0     \u251c\u2500\u2500 CNV\n    \u2502\u00a0\u00a0     \u2514\u2500\u2500 SNV\n    \u251c\u2500\u2500 PhenV1\n    \u2502\u00a0\u00a0 \u251c\u2500\u2500 Genes\n    \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 CNV\n    \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 SNV\n    \u2502\u00a0\u00a0 \u2514\u2500\u2500 Variants\n    \u2502\u00a0\u00a0     \u251c\u2500\u2500 CNV\n    \u2502\u00a0\u00a0     \u2514\u2500\u2500 SNV\n    \u2514\u2500\u2500 Phenv2\n        \u251c\u2500\u2500 Genes\n        \u2502\u00a0\u00a0 \u251c\u2500\u2500 CNV\n        \u2502\u00a0\u00a0 \u2514\u2500\u2500 SNV\n        \u2514\u2500\u2500 Variants\n            \u251c\u2500\u2500 CNV\n            \u2514\u2500\u2500 SNV\n\n29 directories, 0 files\n\n", "\nI know now . Win10 can not have * in file or dir name!\n", "\nIf the directory $2 doesn't exist when the script starts running, then in the first iteration of the loop mv ${2}_${i}MB $2 will rename the directory you are trying to find to $2.\nThen in later iterations, when that destination directory already exists, it will instead move a directory to be inside of $2.\n", "\nlet c=0; for i in $('ls'); do c=$((c+1)); mkdir -p folder_$c; mv $i folder_$c; done\n\nThis should do it, I think.\nExplanation:\n\ndefine variable c\ngo over each element in ls\n\nadd 1 to c\ncreate folder with suffix c\nmove element to folder\n\n\n\n"]}