{"prompt": ["netstat lists all the connections (incoming and outgoing)\nhow do I filter out just the incoming connectionsI have tried the netstat command but it lists all the connections but j need only the incoming connections", "My netstat command is as below on the Centos machine#netstat -n | grep 172.18.0.6 | more\ntcp        0      0 172.18.0.1:57332        172.18.0.6:8444         FIN_WAIT2  \n\nI want to find out which process is running with the IP address 172.18.0.1 . Any way to find out the same", "My netstat command is as below on the Centos machine#netstat -n | grep 172.18.0.6 | more\ntcp        0      0 172.18.0.1:57332        172.18.0.6:8444         FIN_WAIT2  \n\nI want to find out which process is running with the IP address 172.18.0.1 . Any way to find out the same", "I have a script that performs netstat -an calls to show TCP status for two ports (8080 and 5555). I have it print it out onto one row into a log file every minute. This is all fine and dandy but due to the nature of the traffic the status values change often. I need to grab the counts of these statuses and be able to plug them into excel and plot a graph for each status. I need static data so that means i also need the statuses that don't show up (the counts that equal 0).\nWith sort | uniq -c it only picks up positive results obviously. My question is how can I fill in the blank for the statuses that don't show up so I can have full data?Here is my script(it is in a while loop to run till 2pm):#!/bin/bash\nTS=$(date '+%Y-%m-%d %H:%M:%S')\nLOG=_$(hostname)_TCP.log\nLOGTS=$(date '+%Y%m%d')\nHR=$(date '+%H')\n\nwhile [ \"$HR\" != \"14\" ]; do\nTS=$(date '+%Y-%m-%d %H:%M:%S')\n        echo \"$(echo $TS) $(printf \"Port 8080 \")( $(netstat -an | grep 8080 | awk '{print $6}' | sort -k1 | uniq -c | awk '{print $2\" \" $1 \",\"}' |  xargs)) $(printf \"Port 5555 \")( $(netstat -an | grep 5555 | awk '{print $6}' | sort -k1 | uniq -c | awk '{print $2\" \" $1 \",\"}' |  xargs)) \" | tee -a $LOGTS$LOG\n#       sleep 3600\n        sleep 60\n        HR=$(date '+%H')\ndone\n\necho \"Past 14:00 so script is finished\"\nThis is my current results:2015-08-13 09:55:27 Port 8080 ( ESTABLISHED 7, FIN_WAIT2 1, LISTEN 1,) Port 5555 ( CLOSE_WAIT 1, ESTABLISHED 2,)\n2015-08-13 09:56:27 Port 8080 ( ESTABLISHED 1, LISTEN 1,) Port 5555 ( CLOSE_WAIT 1, ESTABLISHED 1,)\nAs you can see I can get the counts nicely.\nBut if i import it into excel the data will not be uniform and I will have to fill in blanks for the no counts in order to be able to plot the graph.\nUnless there is another method or way to do this nicely with excel?My idea is possibly use an array with the tcp statuses to keep like a table of result hits and also count the zeros. Is this the right way of thinking?Sorry for the long post. Thank you in advance.", "I have a script that performs netstat -an calls to show TCP status for two ports (8080 and 5555). I have it print it out onto one row into a log file every minute. This is all fine and dandy but due to the nature of the traffic the status values change often. I need to grab the counts of these statuses and be able to plug them into excel and plot a graph for each status. I need static data so that means i also need the statuses that don't show up (the counts that equal 0).\nWith sort | uniq -c it only picks up positive results obviously. My question is how can I fill in the blank for the statuses that don't show up so I can have full data?Here is my script(it is in a while loop to run till 2pm):#!/bin/bash\nTS=$(date '+%Y-%m-%d %H:%M:%S')\nLOG=_$(hostname)_TCP.log\nLOGTS=$(date '+%Y%m%d')\nHR=$(date '+%H')\n\nwhile [ \"$HR\" != \"14\" ]; do\nTS=$(date '+%Y-%m-%d %H:%M:%S')\n        echo \"$(echo $TS) $(printf \"Port 8080 \")( $(netstat -an | grep 8080 | awk '{print $6}' | sort -k1 | uniq -c | awk '{print $2\" \" $1 \",\"}' |  xargs)) $(printf \"Port 5555 \")( $(netstat -an | grep 5555 | awk '{print $6}' | sort -k1 | uniq -c | awk '{print $2\" \" $1 \",\"}' |  xargs)) \" | tee -a $LOGTS$LOG\n#       sleep 3600\n        sleep 60\n        HR=$(date '+%H')\ndone\n\necho \"Past 14:00 so script is finished\"\nThis is my current results:2015-08-13 09:55:27 Port 8080 ( ESTABLISHED 7, FIN_WAIT2 1, LISTEN 1,) Port 5555 ( CLOSE_WAIT 1, ESTABLISHED 2,)\n2015-08-13 09:56:27 Port 8080 ( ESTABLISHED 1, LISTEN 1,) Port 5555 ( CLOSE_WAIT 1, ESTABLISHED 1,)\nAs you can see I can get the counts nicely.\nBut if i import it into excel the data will not be uniform and I will have to fill in blanks for the no counts in order to be able to plot the graph.\nUnless there is another method or way to do this nicely with excel?My idea is possibly use an array with the tcp statuses to keep like a table of result hits and also count the zeros. Is this the right way of thinking?Sorry for the long post. Thank you in advance.", "I use the simple netstat command \"netstat -nltp\" which shows me all active TCP connections along with the PID and process name.\nHowever even after playing around with parameters, I am unabe to get an important information from the command.That is:I want to see the number of packets received and sent from/to this PID\nI learnt that Recv-Q and Send-Q are not indicative of this. Also, the statistics parameter seems to sum up for all processes. How can I see the packets received and sent to a PID?Thanks", "What I'm trying to do is use netstat -an | grep ESTABLISHED to check all IP addresses in my system from a whois search and ban any belonging to china.So I'm wondering how I could achieve this? Possibly by piping the strings into each other command? but how could I do this?(trying to ban china without adding ssh security, I'm looking to achieve this in either bash or python)code I have so far:#!/bin/bash\nnetstat -an | grep ESTABLISHED > log.txt;\nmyvar=$(awk -F\"|\" '{print $NF}' log.txt)\nwhois $myvar\nI am struggling to automate the process that checks if the country is china and bans the ip.", "I want to combine the output of the following commands:-NETSTAT    [root]# netstat -nltp\n    Active Internet connections (only servers)\n    Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name\n    tcp        0      0 127.0.0.1:32552 0.0.0.0:*               LISTEN     \n 151634/java\n-PS[root]# ps -eo pid,cmd | grep 151634\n130485 grep --color=auto 151634\n151634 java -classpath\nI want to combine the following 2 commands and have the following OUTPUT (txt file):PORT PID CMD\n123  333 java/etc\n234  444 java/etcetc\n345  555 java/etcetcetc\nI've made the following:netstat -nltp | awk '{print $4}' | sed -e 's/.*://' \nThis prints the PORT from netstat -nltp outputfor i in `netstat -nltp | awk {'print $7}' | awk -F '/' {'print $1'} | uniq` ; do ps -eo pid,cmd | grep $(echo $i | sed \"s/^\\(.\\)/[\\1]/g\") ; done \nThis gets the PID from netstat -nltp command and after that it displays the PID and CMD from PS command (also it excludes displaying grep --color=auto resultsThank you very much! LE: I've removed the output html to avoid confusion. It was just an example on how it should look like. "], "chosen": ["\nOnce sockets are created, there isn't really such thing as inbound and outbound, as connections go both ways. What you really care about are connections you started, vs connections others started. To do that, you have to monitor for new connections, and log them as they are created.\ntcpdump is a great tool for this. There are tons of guides on the internet, but a command to get you started would be tcpdump -Qin ....\n", "\nYou can use lsof.\nIf you want to see which service is running in port 57332:\nlsof -i TCP:57332\n\nor by IP:\nlsof -i |grep 172.18.0.1\n\n", "\nI think you are looking for the netstat -p option.\n#netstat -np | grep 172.18.0.6 | more\nShould work.\n", "\nI made a bash script that convert your file output :\n2015-08-13 09:55:27 Port 8080 ( ESTABLISHED 7, FIN_WAIT2 1, LISTEN 1,) Port 5555 ( CLOSE_WAIT 1, ESTABLISHED 2,)\n2015-08-13 09:56:27 Port 8080 ( ESTABLISHED 1, LISTEN 1,) Port 5555 ( CLOSE_WAIT 1, ESTABLISHED 1,)\n\nto :\n2015-08-13,09:55:27,8080,7,,,,1,,,,,1,,5555,2,,,,,,,1,,,,0\n2015-08-13,09:56:27,8080,1,,,,,,,,,1,,5555,1,,,,,,,1,,,,1\n\nwith the definition of all the session state you can have in linux system for each port you have :\ndeclare -a arr=(\"ESTABLISHED\" \"SYN_SENT\" \"SYN_RECV\" \"FIN_WAIT1\" \"FIN_WAIT2\" \"TIME_WAIT\" \"CLOSED\" \"CLOSE_WAIT\" \"LAST_ACK\" \"LISTEN\" \"CLOSING\")\n\nThe last number in each line is a line count variable.\nUsage :\nnetstat_format.sh your_output.txt formatted_output.txt\n\nFull code of netstat_format.sh :\n#!/bin/bash\n#title         :format_netstat.sh\n#author        :Bertrand Martel\n#date          :13/08/2015\n\n#declare a list of all session state you may find in linux system\ndeclare -a arr=(\"ESTABLISHED\" \"SYN_SENT\" \"SYN_RECV\" \"FIN_WAIT1\" \"FIN_WAIT2\" \"TIME_WAIT\" \"CLOSED\" \"CLOSE_WAIT\" \"LAST_ACK\" \"LISTEN\" \"CLOSING\")\n\nIFS=$'\\n'     #line delimiter\nset -f        #Disable file name generation (globbing)\ncount_line=0  #line counter\n\n#empty your output file\ncp /dev/null \"$2\"\n\nfor i in $(cat \"$1\"); do\n\n    #test=\"2015-08-13 09:55:27 Port 8080 ( ESTABLISHED 7, FIN_WAIT2 1, LISTEN 1,) Port 5555 ( CLOSE_WAIT 1, ESTABLISHED 2,)\"\n    main_part=$i\n\n    new_line=\"\"\n\n    #extract first,second and fourth column with ' ' delimiter\n    date_val=`echo $main_part | cut -d' ' -f1`\n    time_val=`echo $main_part | cut -d' ' -f2`\n    port_val=`echo $main_part | cut -d' ' -f4`\n\n    #append these fields to new line output var\n    new_line=\"$date_val,$time_val,$port_val\"\n\n    for i in {0..10}\n    {\n        #here extract all that is between parenthesis and process it independently with replacing \",\" with ' ', looking for session state in arr defined in the beginning.\n        #  awk '{print $2}' => will finally print the second argument eg the value of the key found in arr\n        result=`echo $main_part | awk -v FS=\"([(]|[)])\" '{print $2}'  | sed 's/,/ /g' | grep -o \"${arr[i]} [^ ]*\" | awk '{print $2}'`\n        if [ -z \"$result\" ]; then\n            result=\"\"\n        fi\n        new_line=\"$new_line,$result\"\n    }\n\n    #cut all before \" Port\"\n    second_part=`echo $main_part | sed 's/.*) Port //'`\n\n    #second port in line\n    port2_val=`echo $second_part | cut -d' ' -f1`\n\n    #add port2 value to line output\n    new_line=\"$new_line,$port2_val\"\n\n    for i in {0..10}\n    {\n        result=`echo $second_part | awk -v FS=\"([(]|[)])\" '{print $2}'  | sed 's/,/ /g' | grep -o \"${arr[i]} [^ ]*\" | awk '{print $2}'`\n        if [ -z \"$result\" ]; then\n            result=\"\"\n        fi\n        new_line=\"$new_line,$result\"\n    }\n\n    #############################################\n\n    #cut all before \" Port\"\n    third_part=`echo $second_part | sed 's/.*) Port //'`\n\n    #second port in line\n    port3_val=`echo $third_part | cut -d' ' -f1`\n\n    #add port2 value to line output\n    new_line=\"$new_line,$port3_val\"\n\n    for i in {0..10}\n    {\n        result=`echo $third_part | awk -v FS=\"([(]|[)])\" '{print $2}'  | sed 's/,/ /g' | grep -o \"${arr[i]} [^ ]*\" | awk '{print $2}'`\n        if [ -z \"$result\" ]; then\n            result=\"\"\n        fi\n        new_line=\"$new_line,$result\"\n    }\n\n    ############################################\n\n    #add line count\n    new_line=\"$new_line,$count_line\"\n\n    #increment line count\n    count_line=$((count_line+1))\n\n    #append content of new line to output file\n    echo $new_line >> \"$2\"\ndone\n\ncat \"$2\"\n\nI created a gist when you can take the file :\nhttps://gist.github.com/bertrandmartel/5f1c0c0c84db44e85ca8#file-netstat_format-sh\nNevertheless, it only processes 2 series of Port XXX (....) strings, if you expect to have more you have to modify the script a little\n", "\nI tried to modify your script to handle a string output with 3 port results. \nwith the $second_part and $third_part variables I could not accomplish this using sed, so instead used awk. I had no proper delimiters, so I modified my original script to include comma delimiters so the awk could work. \nHere is your script I modified to handle 3 port strings.\nThanks again for taking the time to write and notate this bash script. Learnt a few things from it. :)\n#!/bin/bash\n#title         :format_netstat.sh\n#author        :Bertrand Martel\n#date          :13/08/2015\n\n#declare a list of all session state you may find in linux system\ndeclare -a arr=(\"ESTABLISHED\" \"SYN_SENT\" \"SYN_RECV\" \"FIN_WAIT1\" \"FIN_WAIT2\" \"TIME_WAIT\" \"CLOSED\" \"CLOSE_WAIT\" \"LAST_ACK\" \"LISTEN\" \"CLOSING\")\n\nIFS=$'\\n'     #line delimiter\nset -f        #Disable file name generation (globbing)\ncount_line=0  #line counter\n\n#empty your output file\ncp /dev/null \"$2\"\n\nfor i in $(cat \"$1\"); do\n\n    #test=\"2015-08-13 09:55:27 Port 8080 ( ESTABLISHED 7, FIN_WAIT2 1, LISTEN 1,) Port 5555 ( CLOSE_WAIT 1, ESTABLISHED 2,)\"\n    main_part=$i\n    new_line=\"\"\n\n    #extract first,second and fourth column with ' ' delimiter\n    date_val=`echo $main_part | cut -d' ' -f1`\n    time_val=`echo $main_part | cut -d' ' -f2`\n    port_val=`echo $main_part | cut -d' ' -f4`\n\n    #append these fields to new line output var\n    new_line=\"$date_val,$time_val,$port_val\"\n\n    for i in {0..10}\n    {\n        #here extract all that is between parenthesis and process it independently with replacing \",\" with ' ', looking for session state in arr defined in the beginning.\n        #  awk '{print $2}' => will finally print the second argument eg the value of the key found in arr\n        result=`echo $main_part | awk -v FS=\"([(]|[)])\" '{print $2}'  | sed 's/,/ /g' | grep -o \"${arr[i]} [^ ]*\" | awk '{print $2}'`\n        if [ -z \"$result\" ]; then\n            result=\"0\"\n        fi\n        new_line=\"$new_line,$result\"\n    }\n        echo $main_part >> main.txt\n    #cut all before \" Port\"\n   # second_part=`echo $main_part | sed 's/.*) Port //g'`\n        second_part=`echo $main_part | awk -F'.' '{print $3}'`\n        echo $second_part >> main.txt\n    #second port in line\n    port2_val=`echo $second_part | cut -d' ' -f3`\n\n    #add port2 value to line output\n    new_line=\"$new_line,$port2_val\"\n\n    for i in {0..10}\n    {\n        result=`echo $second_part | awk -v FS=\"([(]|[)])\" '{print $2}'  | sed 's/,/ /g' | grep -o \"${arr[i]} [^ ]*\" | awk '{print $2}'`\n        if [ -z \"$result\" ]; then\n            result=\"0\"\n        fi\n        new_line=\"$new_line,$result\"\n    }\n\n    #cut all before \" Port\"\n    #third_part=`echo $main_part | sed 's/*) Port //'`\n        third_part=`echo $main_part | awk -F'.' '{print $4}'`\n    #third port in line\n    port3_val=`echo $third_part | cut -d' ' -f3`\n\n    #add port3 value to line output\n    new_line=\"$new_line,$port3_val\"\n\n    for i in {0..10}\n    {\n        result=`echo $third_part | awk -v FS=\"([(]|[)])\" '{print $2}'  | sed 's/,/ /g' | grep -o \"${arr[i]} [^ ]*\" | awk '{print $2}'`\n        if [ -z \"$result\" ]; then\n            result=\"0\"\n        fi\n        new_line=\"$new_line,$result\"\n    }\n\n    #add line count\n    new_line=\"$new_line,$count_line\"\n\n    #increment line count\n    count_line=$((count_line+1))\n\n    #append content of new line to output file\n    echo $new_line >> \"$2\"\ndone\n\ncat \"$2\"\n\n", "\nYou want to do network traffic accounting per process. \nThere are number of applications that allow you to do that in real-time (i.e: nethogs), but the problem is keeping traffic counters over time. \nI would suggest you to do so using iptables, assuming you can clearly distinguish your processes using a network port.\nThis article is still OK for your use case: https://www.cyberciti.biz/faq/linux-configuring-ip-traffic-accounting/\nPS: This sort of questions is best in Server Fault\n", "\nThanks for asking.\nYour quest is a product scope. People are making living from it.\nSee here.\nThe problem involved few unrelated practices.\n\nGeolocate connection.\nMaintain lists of black-list and white-list sources.\nImplement list update policies.\nImplement logging and notification.\n\nTask 1 and 2 are served as web service (research google).\nMany commercial DRM solution also implement your request and maintain the functionality. \nI suggest to research the quest cost/effort before getting into technical design.\n", "\nThank you very much JUSHJUSH,\nI've written here my response because it was too long for the comment response.\nI've updated also the script with that FOR and it worked, but, it seems that the script doesn't obtain the right OUTPUT. \nI will try to explain below\nIf i have the following netstat -nltp output\ntcp        0      0 127.0.0.1:32552         0.0.0.0:*               LISTEN      151634/java\ntcp        0      0 10.77.66.33:8081       0.0.0.0:*               LISTEN      151634/java\ntcp        0      0 0.0.0.0:7070            0.0.0.0:*               LISTEN      151634/java\ntcp        0      0 0.0.0.0:9090            0.0.0.0:*               LISTEN      151634/java\ntcp        0      0 0.0.0.0:20100           0.0.0.0:*               LISTEN      151634/java\ntcp        0      0 0.0.0.0:20101           0.0.0.0:*               LISTEN      151634/java\ntcp        0      0 0.0.0.0:20102           0.0.0.0:*               LISTEN      151634/java\nand the CMD for PID=151634 is java -classpath /opt/application/nifi-1.6.0/./conf:/opt/application/nifi-1.6.0/./lib/jetty-schemas-3.1.jar: \nthe script gives the following OUTPUT:\nPORT PID CMD\n32552   151634  java -classpath /opt/application/nifi-1.6.0/./conf:/opt/application/nifi-1.6.0/./lib/jetty-schemas-3.1.jar:\n32552   151634  java -classpath /opt/application/nifi-1.6.0/./conf:/opt/application/nifi-1.6.0/./lib/jetty-schemas-3.1.jar: \n32552   151634  java -classpath /opt/application/nifi-1.6.0/./conf:/opt/application/nifi-1.6.0/./lib/jetty-schemas-3.1.jar: \n32552   151634  java -classpath /opt/application/nifi-1.6.0/./conf:/opt/application/nifi-1.6.0/./lib/jetty-schemas-3.1.jar: \n32552   151634  java -classpath /opt/application/nifi-1.6.0/./conf:/opt/application/nifi-1.6.0/./lib/jetty-schemas-3.1.jar: \n32552   151634  java -classpath /opt/application/nifi-1.6.0/./conf:/opt/application/nifi-1.6.0/./lib/jetty-schemas-3.1.jar: \n32552   151634  java -classpath /opt/application/nifi-1.6.0/./conf:/opt/application/nifi-1.6.0/./lib/jetty-schemas-3.1.jar:\nThe OUTPUT should have been\nPORT PID CMD\n32552 151634 CMD from above\n8081 151634 CMD from above\n7070 151634 CMD from above\n9090 151634 CMD from above\n20100 151634 CMD from above\n20101 151634 CMD from above\n20102 151634 CMD from above\nOr, another example:\nIf i have the following netstat -nltp output\ntcp        0      0 127.0.0.1:3030          0.0.0.0:*               LISTEN      88284/ruby\ntcp        0      0 127.0.0.1:3031          0.0.0.0:*               LISTEN      88284/ruby\nand the CMD for PID=88284 is /opt/sensu/embedded/bin/ruby /opt/sensu/bin/sensu-client -c /etc/sensu/config.json -d /etc/sensu/conf.d -e /etc/sensu/extensions -p /var/run/sensu/sensu-client.pid -l /var/log/sensu/sensu-client.log -L warn\nthe script gives the following OUTPUT:\nPORT PID CMD\n3030    88284   /opt/sensu/embedded/bin/ruby /opt/sensu/bin/sensu-client -c /etc/sensu/config.json -d /etc/sensu/conf.d -e /etc/sensu/extensions -p /var/run/sensu/sensu-client.pid -l /var/log/sensu/sensu-client.log -L warn\n3030    88284   /opt/sensu/embedded/bin/ruby /opt/sensu/bin/sensu-client -c /etc/sensu/config.json -d /etc/sensu/conf.d -e /etc/sensu/extensions -p /var/run/sensu/sensu-client.pid -l /var/log/sensu/sensu-client.log -L warn\nThe OUTPUT should have been\nPORT PID CMD\n3030 88284 CMD from above\n3031 88284 CMD from above\nThank you very much for your help and patience!\n"], "rejected": ["\nWith netstat you may identify the state of the socket, but in many cases there are no states in raw mode and usually no states used in UDP and UDPLite. You may try to display the listening state for incoming connections by running netstat with the following argument:\nnetstat --listening\n\nHowever, as far as I understood from your question it is better to use the tcpdump tool as mentioned in other comments.\n", "\nYou can use\nnetstat -apn | grep 172.18.0.6 | more\n\nto get also the sockets that are listening.\n", "\nYou can use\nnetstat -apn | grep 172.18.0.6 | more\n\nto get also the sockets that are listening.\n", "\nJust for reference here is the finished working script:\ndeclare -a arr=(\"LISTEN\" \"SYN_SENT\" \"SYN_RECV\" \"ESTABLISHED\" \"FIN-WAIT1\" \"FIN-WAIT2\" \"CLOSE_WAIT\" \"CLOSING\" \"LAST_ACK\" \"TIME_WAIT\" \"CLOSED\")\nIFS=$'\\n'     #line delimiter\nset -f        #Disable file name generation (globbing)\ncount_line=0  #line counter\n\n#empty your output file\ncp /dev/null \"$2\"\n\nfor i in $(cat \"$1\"); do\n\n    #test=\"2015-08-13 09:55:27 Port 8080 ( ESTABLISHED 7, FIN_WAIT2 1, LISTEN 1,) Port 5555 ( CLOSE_WAIT 1, ESTABLISHED 2,)\"\n    main_part=$i\n\n    new_line=\"\"\n\n    #extract first,second and fourth column with ' ' delimiter\n    date_val=`echo $main_part | cut -d' ' -f1`\n    time_val=`echo $main_part | cut -d' ' -f2`\n    port_val=`echo $main_part | cut -d' ' -f4`\n\n    #append these fields to new line output var\n    new_line=\"$date_val,$time_val,$port_val\"\n\n    for i in {0..10}\n    {\n        #here extract all that is between parenthesis and process it independently with replacing \",\" with ' ', looking for session state in arr defined in the beginning.\n        #  awk '{print $2}' => will finally print the second argument eg the value of the key found in arr\n        result=`echo $main_part | awk -v FS=\"([(]|[)])\" '{print $2}'  | sed 's/,/ /g' | grep -o \"${arr[i]} [^ ]*\" | awk '{print $2}'`\n        if [ -z \"$result\" ]; then\n            result=\"0\"\n        fi\n        new_line=\"$new_line,$result\"\n    }\n\n    #cut all before \" Port\"\n    second_part=`echo $main_part | sed 's/.*) Port //'`\n\n    #second port in line\n    port2_val=`echo $second_part | cut -d' ' -f1`\n\n    #add port2 value to line output\n    new_line=\"$new_line,$port2_val\"\n\n    for i in {0..10}\n    {\n        result=`echo $second_part | awk -v FS=\"([(]|[)])\" '{print $2}'  | sed 's/,/ /g' | grep -o \"${arr[i]} [^ ]*\" | awk '{print $2}'`\n        if [ -z \"$result\" ]; then\n            result=\"0\"\n        fi\n        new_line=\"$new_line,$result\"\n    }\n\n    #add line count\n    new_line=\"$new_line,$count_line\"\n\n    #increment line count\n    count_line=$((count_line+1))\n\n    #append content of new line to output file\n    echo $new_line >> \"$2\"\ndone\n\ncat \"$2\"\n\n", "\nJust for reference here is the finished working script:\ndeclare -a arr=(\"LISTEN\" \"SYN_SENT\" \"SYN_RECV\" \"ESTABLISHED\" \"FIN-WAIT1\" \"FIN-WAIT2\" \"CLOSE_WAIT\" \"CLOSING\" \"LAST_ACK\" \"TIME_WAIT\" \"CLOSED\")\nIFS=$'\\n'     #line delimiter\nset -f        #Disable file name generation (globbing)\ncount_line=0  #line counter\n\n#empty your output file\ncp /dev/null \"$2\"\n\nfor i in $(cat \"$1\"); do\n\n    #test=\"2015-08-13 09:55:27 Port 8080 ( ESTABLISHED 7, FIN_WAIT2 1, LISTEN 1,) Port 5555 ( CLOSE_WAIT 1, ESTABLISHED 2,)\"\n    main_part=$i\n\n    new_line=\"\"\n\n    #extract first,second and fourth column with ' ' delimiter\n    date_val=`echo $main_part | cut -d' ' -f1`\n    time_val=`echo $main_part | cut -d' ' -f2`\n    port_val=`echo $main_part | cut -d' ' -f4`\n\n    #append these fields to new line output var\n    new_line=\"$date_val,$time_val,$port_val\"\n\n    for i in {0..10}\n    {\n        #here extract all that is between parenthesis and process it independently with replacing \",\" with ' ', looking for session state in arr defined in the beginning.\n        #  awk '{print $2}' => will finally print the second argument eg the value of the key found in arr\n        result=`echo $main_part | awk -v FS=\"([(]|[)])\" '{print $2}'  | sed 's/,/ /g' | grep -o \"${arr[i]} [^ ]*\" | awk '{print $2}'`\n        if [ -z \"$result\" ]; then\n            result=\"0\"\n        fi\n        new_line=\"$new_line,$result\"\n    }\n\n    #cut all before \" Port\"\n    second_part=`echo $main_part | sed 's/.*) Port //'`\n\n    #second port in line\n    port2_val=`echo $second_part | cut -d' ' -f1`\n\n    #add port2 value to line output\n    new_line=\"$new_line,$port2_val\"\n\n    for i in {0..10}\n    {\n        result=`echo $second_part | awk -v FS=\"([(]|[)])\" '{print $2}'  | sed 's/,/ /g' | grep -o \"${arr[i]} [^ ]*\" | awk '{print $2}'`\n        if [ -z \"$result\" ]; then\n            result=\"0\"\n        fi\n        new_line=\"$new_line,$result\"\n    }\n\n    #add line count\n    new_line=\"$new_line,$count_line\"\n\n    #increment line count\n    count_line=$((count_line+1))\n\n    #append content of new line to output file\n    echo $new_line >> \"$2\"\ndone\n\ncat \"$2\"\n\n", "\nUse inner process counters for that:\ncat /proc/<PID>/net/netstat\n\n", "\nHere is an example written in bash,\n\n    #!/bin/bash\n    # shellcheck disable=SC2155\n    # Automatically ban IP from country\n    # Copyright (C) 2019 Lucas Ramage <[email\u00a0protected]>\n    # SPDX-License-Identifier: MIT\n    set -euo pipefail\n    IFS=$'\\n\\t'\n\n    # netstat output:\n    # Proto Recv-Q Send-Q Local Address Foreign Address State\n\n    get_ip_addr() {\n      # Awk splits the 5th column, Foreign Address, to get the IP\n      echo \"${1}\" | awk '{ split($5, a, \":\"); print a[1] }'\n    }\n\n    # whois output:\n    # OrgName:        Internet Assigned Numbers Authority\n    # OrgId:          IANA\n    # Address:        12025 Waterfront Drive\n    # Address:        Suite 300\n    # City:           Los Angeles\n    # StateProv:      CA\n    # PostalCode:     90292\n    # Country:        US <-- We want this one\n    # RegDate:\n    # Updated:        2012-08-31\n    # Ref:            https://rdap.arin.net/registry/entity/IANA\n\n    get_country() {\n      # Returns nothing if Country not set\n      whois \"${1}\" | awk '/Country/ { print $NF }'\n    }\n\n    check_country() {\n      # Implements a whitelist, instead of a blacklist\n      local COUNTRIES=\"US\"\n\n      # Iterate through whitelist\n      for country in $COUNTRIES; do\n        # Check entry to see if its in the whitelist\n        if [ \"${country}\" == \"${1}\" ]; then\n          echo 1 # true\n        fi\n      done\n    }\n\n    block_ip() {\n      # Remove the `echo` in order to apply command; must have proper privileges, i.e sudo\n      echo sudo iptables -A INPUT -s \"${1}\" -j \"${2}\"\n    }\n\n    main() {\n\n      # Established Connections\n      local ESTCON=$(netstat -an | grep ESTABLISHED)\n\n      for entry in $ESTCON; do\n        local ip=$(get_ip_addr \"${entry}\")\n        local country=$(get_country \"${ip}\")\n        local is_allowed=$(check_country \"${country}\")\n        local policy='DROP' # or REJECT\n\n        if [ ! \"${is_allowed}\" -eq \"1\" ]; then\n          block_ip \"${ip}\" \"${policy}\"\n        fi\n      done\n    }\n\n    main\n\n\nI'd personally run shellcheck on it, and test it further.\nAlso, you might want to look into fail2ban or something like that.\n", "\nOk, so, i've manage to make the script work with all the duplicate problems etc.\nBelow you can find the updated scripts in case anyone else needs.\nThank you! :)\nnetstat -ntlp | sed 1,2d > /tmp/output_netstat.txt\n\necho PORT$'\\t'PID$'\\t'NAME\nfor port in $(cat /tmp/output_netstat.txt | awk '{print $4 \" \" $7}' | sed -e 's/.*://' | awk '{print $1}' | uniq)\ndo\n    pid=$(cat /tmp/output_netstat.txt | grep -w \"$port\" | awk '{print $7}' | cut -d ' ' -f 7 | cut -d '/' -f 1 | uniq )\n    ps_name=$(cat /tmp/output_netstat.txt | awk '{print $4 \" \" $7}' | sed -e 's/.*://' | sed 's/\\// /g' | awk '{print $3}')\n    ps_name_outputed=$(ps -ef | grep \"$pid\" | grep \"$ps_name\" | grep -v grep |tr -s ' '| sed 's/^[^0-9]*//g' | head -1 | cut -f2- -d/)\n    echo  \"$port\"\" \"\"$pid\"\" \"\"$ps_name_outputed\"\ndone\n\nrm -rf /tmp/output_netstat.txt\n\n"]}