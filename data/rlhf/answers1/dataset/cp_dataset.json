{"prompt": ["I'm trying to use the cp command and force an overwrite.I have tried cp -rf /foo/* /bar, but I am still prompted to confirm each overwrite.", "I'm trying to use the cp command and force an overwrite.I have tried cp -rf /foo/* /bar, but I am still prompted to confirm each overwrite.", "I'm trying to use the cp command and force an overwrite.I have tried cp -rf /foo/* /bar, but I am still prompted to confirm each overwrite.", "I'm trying to use the cp command and force an overwrite.I have tried cp -rf /foo/* /bar, but I am still prompted to confirm each overwrite.", "I'm trying to use the cp command and force an overwrite.I have tried cp -rf /foo/* /bar, but I am still prompted to confirm each overwrite.", "I'm trying to use the cp command and force an overwrite.I have tried cp -rf /foo/* /bar, but I am still prompted to confirm each overwrite.", "I'm trying to use the cp command and force an overwrite.I have tried cp -rf /foo/* /bar, but I am still prompted to confirm each overwrite.", "I'm trying to use the cp command and force an overwrite.I have tried cp -rf /foo/* /bar, but I am still prompted to confirm each overwrite.", "I'm trying to use the cp command and force an overwrite.I have tried cp -rf /foo/* /bar, but I am still prompted to confirm each overwrite.", "I'm trying to use the cp command and force an overwrite.I have tried cp -rf /foo/* /bar, but I am still prompted to confirm each overwrite.", "I'm trying to use the cp command and force an overwrite.I have tried cp -rf /foo/* /bar, but I am still prompted to confirm each overwrite.", "I'm trying to use the cp command and force an overwrite.I have tried cp -rf /foo/* /bar, but I am still prompted to confirm each overwrite.", "I'm trying to use the cp command and force an overwrite.I have tried cp -rf /foo/* /bar, but I am still prompted to confirm each overwrite.", "I'm trying to use the cp command and force an overwrite.I have tried cp -rf /foo/* /bar, but I am still prompted to confirm each overwrite.", "I'm trying to use the cp command and force an overwrite.I have tried cp -rf /foo/* /bar, but I am still prompted to confirm each overwrite.", "I'm trying to use the cp command and force an overwrite.I have tried cp -rf /foo/* /bar, but I am still prompted to confirm each overwrite.", "I'm trying to use the cp command and force an overwrite.I have tried cp -rf /foo/* /bar, but I am still prompted to confirm each overwrite.", "I'm trying to use the cp command and force an overwrite.I have tried cp -rf /foo/* /bar, but I am still prompted to confirm each overwrite.", "There are 3 txt files called1.txt 2.txt 3.txt\nI want to batch copy with the name1.txt.cp 2.txt.cp 3.txt.cp\nusing the wildcard *.I entered the command cp *.txt *.txt.cp but it isn't working.cp : target *.txt.cp : is not a directory\nWhat is the problem?", "There are 3 txt files called1.txt 2.txt 3.txt\nI want to batch copy with the name1.txt.cp 2.txt.cp 3.txt.cp\nusing the wildcard *.I entered the command cp *.txt *.txt.cp but it isn't working.cp : target *.txt.cp : is not a directory\nWhat is the problem?", "I want a command (or probably an option to cp) that creates the destination directory if it does not exist.Example:cp -? file /path/to/copy/file/to/is/very/deep/there\n", "I want a command (or probably an option to cp) that creates the destination directory if it does not exist.Example:cp -? file /path/to/copy/file/to/is/very/deep/there\n", "I want a command (or probably an option to cp) that creates the destination directory if it does not exist.Example:cp -? file /path/to/copy/file/to/is/very/deep/there\n", "I want a command (or probably an option to cp) that creates the destination directory if it does not exist.Example:cp -? file /path/to/copy/file/to/is/very/deep/there\n", "I want a command (or probably an option to cp) that creates the destination directory if it does not exist.Example:cp -? file /path/to/copy/file/to/is/very/deep/there\n", "I want a command (or probably an option to cp) that creates the destination directory if it does not exist.Example:cp -? file /path/to/copy/file/to/is/very/deep/there\n", "I want a command (or probably an option to cp) that creates the destination directory if it does not exist.Example:cp -? file /path/to/copy/file/to/is/very/deep/there\n", "I want a command (or probably an option to cp) that creates the destination directory if it does not exist.Example:cp -? file /path/to/copy/file/to/is/very/deep/there\n", "I want a command (or probably an option to cp) that creates the destination directory if it does not exist.Example:cp -? file /path/to/copy/file/to/is/very/deep/there\n", "I want a command (or probably an option to cp) that creates the destination directory if it does not exist.Example:cp -? file /path/to/copy/file/to/is/very/deep/there\n", "I want a command (or probably an option to cp) that creates the destination directory if it does not exist.Example:cp -? file /path/to/copy/file/to/is/very/deep/there\n", "I want a command (or probably an option to cp) that creates the destination directory if it does not exist.Example:cp -? file /path/to/copy/file/to/is/very/deep/there\n", "I want a command (or probably an option to cp) that creates the destination directory if it does not exist.Example:cp -? file /path/to/copy/file/to/is/very/deep/there\n", "I want a command (or probably an option to cp) that creates the destination directory if it does not exist.Example:cp -? file /path/to/copy/file/to/is/very/deep/there\n", "I want a command (or probably an option to cp) that creates the destination directory if it does not exist.Example:cp -? file /path/to/copy/file/to/is/very/deep/there\n", "I want a command (or probably an option to cp) that creates the destination directory if it does not exist.Example:cp -? file /path/to/copy/file/to/is/very/deep/there\n", "I want a command (or probably an option to cp) that creates the destination directory if it does not exist.Example:cp -? file /path/to/copy/file/to/is/very/deep/there\n", "I want a command (or probably an option to cp) that creates the destination directory if it does not exist.Example:cp -? file /path/to/copy/file/to/is/very/deep/there\n", "I want a command (or probably an option to cp) that creates the destination directory if it does not exist.Example:cp -? file /path/to/copy/file/to/is/very/deep/there\n", "I want a command (or probably an option to cp) that creates the destination directory if it does not exist.Example:cp -? file /path/to/copy/file/to/is/very/deep/there\n", "I want a command (or probably an option to cp) that creates the destination directory if it does not exist.Example:cp -? file /path/to/copy/file/to/is/very/deep/there\n", "I want a command (or probably an option to cp) that creates the destination directory if it does not exist.Example:cp -? file /path/to/copy/file/to/is/very/deep/there\n", "I want a command (or probably an option to cp) that creates the destination directory if it does not exist.Example:cp -? file /path/to/copy/file/to/is/very/deep/there\n", "I want a command (or probably an option to cp) that creates the destination directory if it does not exist.Example:cp -? file /path/to/copy/file/to/is/very/deep/there\n", "I want a command (or probably an option to cp) that creates the destination directory if it does not exist.Example:cp -? file /path/to/copy/file/to/is/very/deep/there\n", "I want a command (or probably an option to cp) that creates the destination directory if it does not exist.Example:cp -? file /path/to/copy/file/to/is/very/deep/there\n", "I want a command (or probably an option to cp) that creates the destination directory if it does not exist.Example:cp -? file /path/to/copy/file/to/is/very/deep/there\n", "I want a command (or probably an option to cp) that creates the destination directory if it does not exist.Example:cp -? file /path/to/copy/file/to/is/very/deep/there\n", "Among the tons of cp questions I have not found anything about this difference in behaviour (tested on Ubuntu 18.04). Sorry for the lost post, but the setting is a bit complex.Case 1: This is the expected behaviourGiven the following folder source                     \n    file1.cpp\n    file2.cpp\nafter running this script #!/bin/bash\n cp -r source/ target/   \nI do get this result   source                     # same as above, plus a copy in \"target\"\n    file1.cpp\n    file2.cpp\n target  \n    file1.cpp\n    file2.cpp\nCase 2: Using the same script, source folder exists and is empty in the target folderHere there is one additional, empty folder \n     source\n        file1.cpp\n        file2.cpp\n     target\n        sourceand run the same script #!/bin/bash\n cp -r source/ target/     \nwhich gives me a different, undesired result source                     # same as above, plus a copy in \"target\"\n    file1.cpp\n    file2.cpp\n target  \n    source\n       file1.cpp\n       file2.cpp\nNormal Solution for Case1 and Case2 cp -r source/  target/       # works only for Case 1\n cp -r source/* target/       # works only for Case 2\nUsed in the wrong case, one will cause an error, the other yield the wrong result which can be very confusing. This means for each copy action I must check if the target folder exists and use a different command. That is very cumbersome but I am not aware of a more simple solution.Unresolved situation for Case2However, the problem I have is this one: When I use variables for the source and target my script looks like this #!/bin/bash\n SOURCE=\"source\"\n TARGET=\"target\"\n\n if [ -d \"$TARGET\" ]; then\n   cp -r $SOURCE $TARGET     \n else\n   cp -r $SOURCE/* $TARGET     # note \"$SOURCE/*\" would fail.\n fi\nand I have a $SOURCE path with spaces. SOURCE=\"source code\"Since I can not use quotations for the source variable, this causes two 'directory not found errors'.   How can I solve this for Case2?EDITTo clarify the problem a bit more. This SOURCE=\"source\" \ncp -r \"$SOURCE/*\" $TARGET\nfails with the error \"cannot stat source/: No such file or directory\". I think that means that bash can not replace the / with the file list and cp gets this as a file literal. A file or folder with the name \"source/*\" obviously does not exist. But maybe I am thinking too simple and what bash does is different.", "Among the tons of cp questions I have not found anything about this difference in behaviour (tested on Ubuntu 18.04). Sorry for the lost post, but the setting is a bit complex.Case 1: This is the expected behaviourGiven the following folder source                     \n    file1.cpp\n    file2.cpp\nafter running this script #!/bin/bash\n cp -r source/ target/   \nI do get this result   source                     # same as above, plus a copy in \"target\"\n    file1.cpp\n    file2.cpp\n target  \n    file1.cpp\n    file2.cpp\nCase 2: Using the same script, source folder exists and is empty in the target folderHere there is one additional, empty folder \n     source\n        file1.cpp\n        file2.cpp\n     target\n        sourceand run the same script #!/bin/bash\n cp -r source/ target/     \nwhich gives me a different, undesired result source                     # same as above, plus a copy in \"target\"\n    file1.cpp\n    file2.cpp\n target  \n    source\n       file1.cpp\n       file2.cpp\nNormal Solution for Case1 and Case2 cp -r source/  target/       # works only for Case 1\n cp -r source/* target/       # works only for Case 2\nUsed in the wrong case, one will cause an error, the other yield the wrong result which can be very confusing. This means for each copy action I must check if the target folder exists and use a different command. That is very cumbersome but I am not aware of a more simple solution.Unresolved situation for Case2However, the problem I have is this one: When I use variables for the source and target my script looks like this #!/bin/bash\n SOURCE=\"source\"\n TARGET=\"target\"\n\n if [ -d \"$TARGET\" ]; then\n   cp -r $SOURCE $TARGET     \n else\n   cp -r $SOURCE/* $TARGET     # note \"$SOURCE/*\" would fail.\n fi\nand I have a $SOURCE path with spaces. SOURCE=\"source code\"Since I can not use quotations for the source variable, this causes two 'directory not found errors'.   How can I solve this for Case2?EDITTo clarify the problem a bit more. This SOURCE=\"source\" \ncp -r \"$SOURCE/*\" $TARGET\nfails with the error \"cannot stat source/: No such file or directory\". I think that means that bash can not replace the / with the file list and cp gets this as a file literal. A file or folder with the name \"source/*\" obviously does not exist. But maybe I am thinking too simple and what bash does is different.", "Is there a one-line command/script to copy one file to many files on Linux?cp file1 file2 file3\ncopies the first two files into the third. Is there a way to copy the first file into the rest?", "Is there a one-line command/script to copy one file to many files on Linux?cp file1 file2 file3\ncopies the first two files into the third. Is there a way to copy the first file into the rest?", "Is there a one-line command/script to copy one file to many files on Linux?cp file1 file2 file3\ncopies the first two files into the third. Is there a way to copy the first file into the rest?", "Is there a one-line command/script to copy one file to many files on Linux?cp file1 file2 file3\ncopies the first two files into the third. Is there a way to copy the first file into the rest?", "Is there a one-line command/script to copy one file to many files on Linux?cp file1 file2 file3\ncopies the first two files into the third. Is there a way to copy the first file into the rest?", "Is there a one-line command/script to copy one file to many files on Linux?cp file1 file2 file3\ncopies the first two files into the third. Is there a way to copy the first file into the rest?", "Is there a one-line command/script to copy one file to many files on Linux?cp file1 file2 file3\ncopies the first two files into the third. Is there a way to copy the first file into the rest?", "Is there a one-line command/script to copy one file to many files on Linux?cp file1 file2 file3\ncopies the first two files into the third. Is there a way to copy the first file into the rest?", "Is there a one-line command/script to copy one file to many files on Linux?cp file1 file2 file3\ncopies the first two files into the third. Is there a way to copy the first file into the rest?", "Is there a one-line command/script to copy one file to many files on Linux?cp file1 file2 file3\ncopies the first two files into the third. Is there a way to copy the first file into the rest?", "Is there a one-line command/script to copy one file to many files on Linux?cp file1 file2 file3\ncopies the first two files into the third. Is there a way to copy the first file into the rest?", "Is there a one-line command/script to copy one file to many files on Linux?cp file1 file2 file3\ncopies the first two files into the third. Is there a way to copy the first file into the rest?", "I'm trying to write a Bash script that will overwrite an existing directory. I have a directory foo/ and I am trying to overwrite bar/ with it. But when I do this:cp -Rf foo/ bar/\na new bar/foo/ directory is created. I don't want that. There are two files in foo/; a and b. There are files with same names in bar/ as well. I want the foo/a and foo/b to replace bar/a and bar/b.", "I'm trying to write a Bash script that will overwrite an existing directory. I have a directory foo/ and I am trying to overwrite bar/ with it. But when I do this:cp -Rf foo/ bar/\na new bar/foo/ directory is created. I don't want that. There are two files in foo/; a and b. There are files with same names in bar/ as well. I want the foo/a and foo/b to replace bar/a and bar/b.", "I'm trying to write a Bash script that will overwrite an existing directory. I have a directory foo/ and I am trying to overwrite bar/ with it. But when I do this:cp -Rf foo/ bar/\na new bar/foo/ directory is created. I don't want that. There are two files in foo/; a and b. There are files with same names in bar/ as well. I want the foo/a and foo/b to replace bar/a and bar/b.", "I'm trying to write a Bash script that will overwrite an existing directory. I have a directory foo/ and I am trying to overwrite bar/ with it. But when I do this:cp -Rf foo/ bar/\na new bar/foo/ directory is created. I don't want that. There are two files in foo/; a and b. There are files with same names in bar/ as well. I want the foo/a and foo/b to replace bar/a and bar/b.", "I'm trying to write a Bash script that will overwrite an existing directory. I have a directory foo/ and I am trying to overwrite bar/ with it. But when I do this:cp -Rf foo/ bar/\na new bar/foo/ directory is created. I don't want that. There are two files in foo/; a and b. There are files with same names in bar/ as well. I want the foo/a and foo/b to replace bar/a and bar/b.", "I'm trying to write a Bash script that will overwrite an existing directory. I have a directory foo/ and I am trying to overwrite bar/ with it. But when I do this:cp -Rf foo/ bar/\na new bar/foo/ directory is created. I don't want that. There are two files in foo/; a and b. There are files with same names in bar/ as well. I want the foo/a and foo/b to replace bar/a and bar/b.", "I'm trying to write a Bash script that will overwrite an existing directory. I have a directory foo/ and I am trying to overwrite bar/ with it. But when I do this:cp -Rf foo/ bar/\na new bar/foo/ directory is created. I don't want that. There are two files in foo/; a and b. There are files with same names in bar/ as well. I want the foo/a and foo/b to replace bar/a and bar/b.", "I'm trying to write a Bash script that will overwrite an existing directory. I have a directory foo/ and I am trying to overwrite bar/ with it. But when I do this:cp -Rf foo/ bar/\na new bar/foo/ directory is created. I don't want that. There are two files in foo/; a and b. There are files with same names in bar/ as well. I want the foo/a and foo/b to replace bar/a and bar/b.", "I'm trying to write a Bash script that will overwrite an existing directory. I have a directory foo/ and I am trying to overwrite bar/ with it. But when I do this:cp -Rf foo/ bar/\na new bar/foo/ directory is created. I don't want that. There are two files in foo/; a and b. There are files with same names in bar/ as well. I want the foo/a and foo/b to replace bar/a and bar/b.", "I have a directory mnt/d/LIVI.Inside the directory, LIVI, I have sub-directories:mnt/d/LIVI/ak \nmnt/d/LIVI/ag \nmnt/d/LIVI/few \nmnt/d/LIVI/ww4 \nmnt/d/LIVI/ks5 I wanted to copy a file named tt.txt from mnt/d/LIVI/ak/tt.txt and paste to all the sub directories of LIVI, using Ubuntu terminal. How do i do it using a shell script file?I tried the following one, but it didn't work.I created a text file named mnt/d/LIVI/FOLDERS.txt, This listed all the sub directories names.And saved a script file in mnt/d/LIVI directory. The following is the script#!/bin/sh\n# -*- coding: utf-8-unix -*-\nROOTDIR=$(dirname $0 | xargs readlink -f)\nfor SIMDIR in cat FOLDERS.txt | xargs readlink -f ; do\n    cp mnt/d/LIVI/ak/tt.txt $SIMDIR\ndone\n#cd ..\ndate\n", "I have a list of file names contained within a text file (a.txt). I want to extract from a directory (b) the files listed in a.txt to a new directory (c). The syntax of the filenames in a.txt and b match. The files in a.txt are empty and the files in b contain the json message of interest.For example, the contents of a.txt look like:ML3DBHCN___005.json\nOCO2_L2_Standard___10r.json\nGPM_3IMERGM___06.json \nand b:b/ML3DBHCN___005.json\nb/OCO2_L2_Standard___10r.json\nb/GPM_3IMERGM___06.json \nDo i need to write a small .sh file that iterates through a.txt and extracts from b or can this be completed at once via command line?"], "chosen": ["\nThis is probably caused by cp being already aliased to something like cp -i. Calling cp directly should work:\n/bin/cp -rf /zzz/zzz/* /xxx/xxx\n\nAnother way to get around this is to use the yes command:\nyes | cp -rf /zzz/zzz/* /xxx/xxx\n\n", "\nYou can do yes | cp -rf xxx yyy, but my gutfeeling says that if you do it as root - your .bashrc or .profile has an alias of cp to cp -i, most modern systems (primarily RH-derivatives) do that to root profiles. \nYou can check existing aliases by running alias at the command prompt, or which cp to check aliases only for cp.\nIf you do have an alias defined, running unalias cp will abolish that for the current session, otherwise you can just remove it from your shell profile.\nYou can temporarily bypass an alias and use the non-aliased version of a command by prefixing it with \\, e.g. \\cp whatever\n", "\nAs some of the other answers have stated, you probably use an alias somewhere which maps cp to cp -i or something similar. You can run a command without any aliases by preceding it with a backslash. In your case, try\n\\cp -r /zzz/zzz/* /xxx/xxx\n\nThe backslash will temporarily disable any aliases you have called cp.\n", "\nYou probably have an alias somewhere, mapping cp to cp -i; because with the default settings, cp won't ask to overwrite. Check your .bashrc, your .profile etc.\nSee cp manpage: Only when -i parameter is specified will cp actually prompt before overwriting.\nYou can check this via the alias command:\n$ alias\nalias cp='cp -i'\nalias diff='diff -u'\n....\n\nTo undefine the alias, use:\n$ unalias cp\n\n", "\nAs other answers have stated, this could happend if cp is an alias of cp -i.\nYou can append a \\ before the cp command to use it without alias.\n\\cp -fR source target\n\n", "\nSo I run into this a lot because I keep cp aliased to cp -iv, and I found a neat trick. It turns out that while -i and -n both cancel previous overwrite directives, -f does not. However, if you use -nf it adds the ability to clear the -i. So:\ncp -f /foo/* /bar  <-- Prompt\ncp -nf /foo/* /bar <-- No Prompt\n\nPretty neat huh? /necropost\n", "\nBy default cp has aliase to cp -i. You can check it, type alias and you can see some like:\nalias cp='cp -i'\nalias l.='ls -d .* --color=auto'\nalias ll='ls -l --color=auto'\nalias ls='ls --color=auto'\nalias mv='mv -i'\nalias rm='rm -i'\n\nTo solve this problem just use /bin/cp /from /to command instead cp /from /to\n", "\nThe simplest way for me:\nyes | cp source destination\n\n", "\nyou can use this command as well:\ncp -ru /zzz/zzz/* /xxx/xxx\nit would update your existing file with the newer one though.\n", "\nI found this\n'cp' -rf * /data/danalonso_testing/target/\n\nSource: https://superuser.com/questions/358843/how-to-replace-all-the-contents-from-one-folder-with-another-one/358851\n", "\ncp is usually aliased like this\nalias cp='cp -i'   # i.e. ask questions of overwriting\n\nif you are sure that you want to do the overwrite then use this:\n/bin/cp <arguments here> src dest\n\n", "\ncp -u ...\ncp --update ...\n\nalso works.\n", "\nAnother way to call the command without the alias is to use the command builtin in bash.\ncommand cp -rf /zzz/zzz/*\n", "\n-n is \"not to overwrite\" but his question is totally opposite what you replied for. \nTo avoid this confirmation you can simply run the cp command wiht absolute path, it will avoid the alias.\n/bin/cp sourcefile destination\n", "\nIf you want to keep alias at the global level as is and just want to change for your script.\nJust use:\nalias cp=cp\nand then write your follow up commands.\n", "\nI simply used unalias to remove the \"cp -i\" alias, then do the copy, then set back the alias. :   \nunalias cp  \ncp -f foo foo.copy  \nalias cp=\"cp -i\"  \n\nNot the most beautiful code, but easy to set and efficient. I also check the alias is already set back with a simple   \nalias |grep cp\n\n", "\nIf this is a small text file, you may consider this way too:\ncat my.cnf > /etc/my.cnf\n\nNot sure about the efficiency or side effects for large or binary files.\n", "\nFor me, the simpler the better. This way does not show STDOUT:\nyes | cp -rf source destination >/dev/null 2>&1\n\n", "\nIf you are used to MS/Windown CMD shell, it is important to note that Unix system handle very differently the wild cards. MS/Windows has kept the MS/DOS rule that said that wild cards were not interpreted but were passed to the command. The command sees the wildcard characters and can handle the second * in the command as noting where the match from the first should go, making copy ab.* cd.* sensible.\nIn Unix (and derivatives like Linux) the shell is in charge of handling the wildcards and it replaces any word containing one with all the possible matches. The good news is that the command has not to care about that. But the downside is that if the current folder contains ab.txt ab.md5 cd.jpg, a command copy ab.* cd.* will be translated into copy ab.txt ab.md5 cd.jpg which is probably not want you would expect...\nThe underlying reason is Unix shells are much more versatile than the good old MS/DOS inherited CMD.EXE and do have simple to use for and if compound commands. Just look at @Halley Oliveira's answer for the syntax for your use case.\n", "\nAbout the easiest and robust way to do what you are attempting is to collect the files with find . -type f -name \"*.txt\" which will find all files ending in \".txt\" below the current directory. To limit to just the current directory add -maxdepth 1 before -type .... To ensure filenames with spaces or other strange characters are correctly handled add the -print0 option to ensure the filenames are nul-termianted. Putting that altogether, you could collect the files with:\nfind . -maxdepth 1 -type f -name \"*.txt\" -print0\n\nNow to process the files, copying them to add a .cp ending (extension) to the filename, you can use GNU xargs using the -0 option to handle the nul-terminated filenames and the -I '{}' replace-str option to process each filename  which will replace '{}' in the xargs command. Putting that together, you would have:\nxargs -0 -I '{}' cp -a '{}' '{}.cp'\n\nAbove you simply copy (cp -a) preserving attributes '{}' to '{}.cp' adding the .cp extension.\nPutting it altogether, you would simply pipe the find output to xargs, e.g.:\nfind . -maxdepth 1 -type f -name \"*.txt\" -print0 | xargs -0 -I '{}' cp -a '{}' '{}.cp'\n\nIf you want a full quick example, just create the files and then prove to yourself it works as intended, e.g.\n$ touch {1..3}.txt\n$ find . -maxdepth 1 -type f -name \"*.txt\" -print0 | xargs -0 -I '{}' cp -a '{}' '{}.cp'\n\nResulting files in the current directory:\n$ ls -al [1-3]*\n-rw-r--r-- 1 david david 0 Aug 24 19:07 1.txt\n-rw-r--r-- 1 david david 0 Aug 24 19:07 1.txt.cp\n-rw-r--r-- 1 david david 0 Aug 24 19:07 2.txt\n-rw-r--r-- 1 david david 0 Aug 24 19:07 2.txt.cp\n-rw-r--r-- 1 david david 0 Aug 24 19:07 3.txt\n-rw-r--r-- 1 david david 0 Aug 24 19:07 3.txt.cp\n\nLet me know if you have questions. There are many additional ways to tailor the find command to match just what you want to find using regular expressions instead of simple file-globbing if needed.\n", "\nmkdir -p \"$d\" && cp file \"$d\"\n\n(there's no such option for cp).\n", "\nIf both of the following are true:\n\nYou are using the GNU version of cp (and not, for instance, the Mac version), and\nYou are copying from some existing directory structure and you just need it recreated\n\nthen you can do this with the --parents flag of cp. From the info page (viewable at http://www.gnu.org/software/coreutils/manual/html_node/cp-invocation.html#cp-invocation or with info cp or man cp):\n\n--parents\n     Form the name of each destination file by appending to the target\n     directory a slash and the specified name of the source file.  The\n     last argument given to `cp' must be the name of an existing\n     directory.  For example, the command:\n\n          cp --parents a/b/c existing_dir\n\n     copies the file `a/b/c' to `existing_dir/a/b/c', creating any\n     missing intermediate directories.\n\n\nExample:\n/tmp $ mkdir foo\n/tmp $ mkdir foo/foo\n/tmp $ touch foo/foo/foo.txt\n/tmp $ mkdir bar\n/tmp $ cp --parents foo/foo/foo.txt bar\n/tmp $ ls bar/foo/foo\nfoo.txt\n\n", "\nShort Answer\nTo copy myfile.txt to /foo/bar/myfile.txt, use:\nmkdir -p /foo/bar && cp myfile.txt $_\n\nHow does this work?\nThere's a few components to this, so I'll cover all the syntax step by step.\nThe mkdir utility, as specified in the POSIX standard, makes directories. The -p argument, per the docs, will cause mkdir to\n\nCreate any missing intermediate pathname components\n\nmeaning that when calling mkdir -p /foo/bar, mkdir will create /foo and /foo/bar if /foo doesn't already exist. (Without -p, it will instead throw an error.\nThe && list operator, as documented in the POSIX standard (or the Bash manual if you prefer), has the effect that cp myfile.txt $_ only gets executed if mkdir -p /foo/bar executes successfully. This means the cp command won't try to execute if mkdir fails for one of the many reasons it might fail.\nFinally, the $_ we pass as the second argument to cp is a \"special parameter\" which can be handy for avoiding repeating long arguments (like file paths) without having to store them in a variable. Per the Bash manual, it:\n\nexpands to the last argument to the previous command\n\nIn this case, that's the /foo/bar we passed to mkdir. So the cp command expands to cp myfile.txt /foo/bar, which copies myfile.txt into the newly created /foo/bar directory.\nNote that $_ is not part of the POSIX standard, so theoretically a Unix variant might have a shell that doesn't support this construct. However, I don't know of any modern shells that don't support $_; certainly Bash, Dash, and zsh all do.\n\nA final note: the command I've given at the start of this answer assumes that your directory names don't have spaces in. If you're dealing with names with spaces, you'll need to quote them so that the different words aren't treated as different arguments to mkdir or cp. So your command would actually look like:\nmkdir -p \"/my directory/name with/spaces\" && cp \"my filename with spaces.txt\" \"$_\"\n\n", "\nSuch an old question, but maybe I can propose an alternative solution.\nYou can use the install programme to copy your file and create the destination path \"on the fly\".\ninstall -D file /path/to/copy/file/to/is/very/deep/there/file\n\n\nThere are some aspects to take in consideration, though:\n\nyou need to specify also the destination file name, not only the destination path\nthe destination file will be executable (at least, as far as I saw from my tests) \n\nYou can easily amend the #2 by adding the -m option to set permissions on the destination file (example: -m 664 will create the destination file with permissions rw-rw-r--, just like creating a new file with touch).\n\nAnd here it is the shameless link to the answer I was inspired by =)\n", "\nShell function that does what you want, calling it a \"bury\" copy because it digs a hole for the file to live in:\nbury_copy() { mkdir -p `dirname $2` && cp \"$1\" \"$2\"; }\n\n", "\nHere's one way to do it:\nmkdir -p `dirname /path/to/copy/file/to/is/very/deep/there` \\\n   && cp -r file /path/to/copy/file/to/is/very/deep/there\n\ndirname will give you the parent of the destination directory or file. mkdir -p `dirname ...` will then create that directory ensuring that when you call cp -r the correct base directory is in place.\nThe advantage of this over --parents is that it works for the case where the last element in the destination path is a filename.\nAnd it'll work on OS X.\n", "\nwith all my respect for answers above, I prefer to use rsync as follow:\n$  rsync -a directory_name /path_where_to_inject_your_directory/\n\nexample: \n$ rsync -a test /usr/local/lib/\n\n", "\nThis is very late but it may help a rookie somewhere. If you need to AUTO create folders rsync should be your best friend.\nrsync /path/to/sourcefile /path/to/tragetdir/thatdoestexist/\n\n", "\ninstall -D file -m 644 -t /path/to/copy/file/to/is/very/deep/there\n", "\nThis does it for me\ncp -vaR ./from ./to\n\n", "\nAs suggested above by help_asap and spongeman you can use the 'install' command to copy files to existing directories or create create new destination directories if they don't already exist.\nOption 1\ninstall -D filename some/deep/directory/filename\ncopies file to a new or existing directory and gives filename default 755 permissions\nOption 2\ninstall -D filename -m640 some/deep/directory/filename\nas per Option 1 but gives filename 640 permissions.\nOption 3\ninstall -D filename -m640 -t some/deep/directory/\nas per Option 2 but targets filename into target directory so filename does not need to be written in both source and target.\nOption 4\ninstall -D filena* -m640 -t some/deep/directory/\nas per Option 3 but uses a wildcard for multiple files.\nIt works nicely in Ubuntu and combines two steps (directory creation then file copy) into one single step.\n", "\nSimply add the following in your .bashrc, tweak if you need. Works in Ubuntu.\nmkcp() {\n    test -d \"$2\" || mkdir -p \"$2\"\n    cp -r \"$1\" \"$2\"\n}\n\nE.g\nIf you want to copy 'test' file to destination directory 'd'\nUse,\nmkcp test a/b/c/d\n\nmkcp will first check if destination directory exists or not, if not then make it and copy source file/directory.\n", "\nJust to resume and give a complete working solution, in one line.\nBe careful if you want to rename your file, you should include a way to provide a clean dir path to mkdir. $fdst can be file or dir.\nNext code should work in any case.\nfsrc=/tmp/myfile.unk\nfdst=/tmp/dir1/dir2/dir3/myfile.txt\nmkdir -p $(dirname ${fdst}) && cp -p ${fsrc} ${fdst}\n\nor bash specific\nfsrc=/tmp/myfile.unk\nfdst=/tmp/dir1/dir2/dir3/myfile.txt\nmkdir -p ${fdst%/*} && cp -p ${fsrc} ${fdst}\n\n", "\nSimply without creating script and with simple command ...\nmkdir -p /destination-folder/ && cp file-name /destination-folder/\n\n", "\nI wrote a support script for cp, called CP (note capital letters) that's intended to do exactly this. Script will check for errors in the path you've put in (except the last one which is the destination) and if all is well, it will do an mkdir -p step to create the destination path before starting the copy. At this point the regular cp utility takes over and any switches you use with CP (like -r, -p, -rpL gets piped directly to cp). Before you use my script, there are a few things you need to understand.\n\nall the info here can be accessed by doing CP --help. CP --help-all include's cp's switches.\nregular cp won't do the copy if it doesn't find the destination path. You don't have such a safety net for typos with CP. You're destination will be created, so if you misspell your destination as /usrr/share/icons or /usr/share/icon well that's what's going to be created. \nregular cp tends to model it's behavior on the existing path: cp /a/b /c/d will vary on whether d exists or not. if d is an existing  folder, cp will copy b into it, making /c/d/b. If d doesn't exist, b will be copied into c and renamed to d. If d exists but is a file and b is a file, it will be overwritten by b's copy. If c doesn't exist, cp doesn't do the copy and exits.\n\nCP doesn't have the luxury of taking cues from existing paths, so it has to have some very firm behavior patterns. CP assumes that the item you're copying is being dropped in the destination path and is not the destination itself (aka, a renamed copy of the source file/folder). Meaning: \n\n\"CP /a/b /c/d\" will result in /c/d/b if d is a folder        \n\"CP /a/b /c/b\" will result in /c/b/b if b in /c/b is a folder. \nIf both b and d are files: CP /a/b /c/d will result in /c/d (where d is a copy of b). Same for CP /a/b /c/b in the same circumstance.\n\nThis default CP behavior can be changed with the \"--rename\" switch. In this case, it's assumed that \n\n\"CP --rename /a/b /c/d\" is copying b into /c and renaming the copy to d.\n\nA few closing notes: Like with cp, CP can copy multiple items at a time with the last path being listed assumed to be the destination. It can also handle paths with spaces as long as you use quotation marks. \nCP will check the paths you put in and make sure they exist before doing the copy. In strict mode (available through --strict switch), all files/folders being copied must exist or no copy takes place. In relaxed mode (--relaxed), copy will continue if at least one of the items you listed exists. Relaxed mode is the default, you can change the mode temporarily via the switches or permanently by setting the variable easy_going at the beginning of the script.\nHere's how to install it:\nIn a non-root terminal, do:\nsudo echo > /usr/bin/CP; sudo chmod +x /usr/bin/CP; sudo touch /usr/bin/CP\ngedit admin:///usr/bin/CP \n\nIn gedit, paste CP utility and save:\n#!/bin/bash\n#Regular cp works with the assumption that the destination path exists and if it doesn't, it will verify that it's parent directory does.\n\n#eg: cp /a/b /c/d will give /c/d/b if folder path /c/d already exists but will give /c/d (where d is renamed copy of b) if /c/d doesn't exists but /c does.\n\n#CP works differently, provided that d in /c/d isn't an existing file, it assumes that you're copying item into a folder path called /c/d and will create it if it doesn't exist. so CP /a/b /c/d will always give /c/d/b unless d is an existing file. If you put the --rename switch, it will assume that you're copying into /c and renaming the singl item you're copying from b to d at the destination. Again, if /c doesn't exist, it will be created. So CP --rename /a/b /c/d will give a /c/d and if there already a folder called /c/d, contents of b will be merged into d. \n\n#cp+ $source $destination\n#mkdir -p /foo/bar && cp myfile \"$_\"\n\nerr=0 # error count\ni=0 #item counter, doesn't include destination (starts at 1, ex. item1, item2 etc)\nm=0 #cp switch counter (starts at 1, switch 1, switch2, etc)\nn=1 # argument counter (aka the arguments inputed into script, those include both switches and items, aka: $1 $2 $3 $4 $5)\ncount_s=0\ncount_i=0\neasy_going=true #determines how you deal with bad pathes in your copy, true will allow copy to continue provided one of the items being copied exists, false will exit script for one bad path. this setting can also be changed via the custom switches: --strict and --not-strict\nverbal=\"-v\"\n\n\n  help=\"===============================================================================\\\n    \\n         CREATIVE COPY SCRIPT (CP) -- written by thebunnyrules\\\n    \\n===============================================================================\\n\n    \\n This script (CP, note capital letters) is intended to supplement \\\n    \\n your system's regular cp command (note uncapped letters). \\n\n    \\n Script's function is to check if the destination path exists \\\n    \\n before starting the copy. If it doesn't it will be created.\\n    \n    \\n To make this happen, CP assumes that the item you're copying is \\\n    \\n being dropped in the destination path and is not the destination\\\n    \\n itself (aka, a renamed copy of the source file/folder). Meaning:\\n \n    \\n * \\\"CP /a/b /c/d\\\" will result in /c/d/b \\\n    \\n * even if you write \\\"CP /a/b /c/b\\\", CP will create the path /a/b, \\\n    \\n   resulting in /c/b/b. \\n\n    \\n Of course, if /c/b or /c/d are existing files and /a/b is also a\\\n    \\n file, the existing destination file will simply be overwritten. \\\n    \\n This behavior can be changed with the \\\"--rename\\\" switch. In this\\\n    \\n case, it's assumed that \\\"CP --rename /a/b /c/d\\\" is copying b into /c  \\\n    \\n and renaming the copy to d.\\n\n    \\n===============================================================================\\\n    \\n        CP specific help: Switches and their Usages \\\n    \\n===============================================================================\\n\n    \\\n    \\n  --rename\\tSee above. Ignored if copying more than one item. \\n\n    \\n  --quiet\\tCP is verbose by default. This quiets it.\\n\n    \\n  --strict\\tIf one+ of your files was not found, CP exits if\\\n    \\n\\t\\tyou use --rename switch with multiple items, CP \\\n    \\n\\t\\texits.\\n\n    \\n  --relaxed\\tIgnores bad paths unless they're all bad but warns\\\n    \\n\\t\\tyou about them. Ignores in-appropriate rename switch\\\n    \\n\\t\\twithout exiting. This is default behavior. You can \\\n    \\n\\t\\tmake strict the default behavior by editing the \\\n    \\n\\t\\tCP script and setting: \\n\n    \\n\\t\\teasy_going=false.\\n\n    \\n  --help-all\\tShows help specific to cp (in addition to CP).\"\n\ncp_hlp=\"\\n\\nRegular cp command's switches will still work when using CP.\\\n    \\nHere is the help out of the original cp command... \\\n    \\n\\n===============================================================================\\\n    \\n          cp specific help: \\\n    \\n===============================================================================\\n\"\n\noutro1=\"\\n******************************************************************************\\\n    \\n******************************************************************************\\\n    \\n******************************************************************************\\\n    \\n        USE THIS SCRIPT WITH CARE, TYPOS WILL GIVE YOU PROBLEMS...\\\n    \\n******************************************************************************\\\n    \\n******************************* HIT q TO EXIT ********************************\\\n    \\n******************************************************************************\"\n\n\n#count and classify arguments that were inputed into script, output help message if needed\nwhile true; do\n    eval input=\"\\$$n\"\n    in_=${input::1}\n\n    if [ -z \"$input\" -a $n = 1 ]; then input=\"--help\"; fi \n\n    if [ \"$input\" = \"-h\" -o \"$input\" = \"--help\" -o \"$input\" = \"-?\" -o \"$input\" = \"--help-all\" ]; then\n        if [ \"$input\" = \"--help-all\" ]; then \n            echo -e \"$help\"$cp_hlp > /tmp/cp.hlp \n            cp --help >> /tmp/cp.hlp\n            echo -e \"$outro1\" >> /tmp/cp.hlp\n            cat /tmp/cp.hlp|less\n            cat /tmp/cp.hlp\n            rm /tmp/cp.hlp\n        else\n            echo -e \"$help\" \"$outro1\"|less\n            echo -e \"$help\" \"$outro1\"\n        fi\n        exit\n    fi\n\n    if [ -z \"$input\" ]; then\n        count_i=$(expr $count_i - 1 ) # remember, last item is destination and it's not included in cound\n        break \n    elif [ \"$in_\" = \"-\" ]; then\n        count_s=$(expr $count_s + 1 )\n    else\n        count_i=$(expr $count_i + 1 )\n    fi\n    n=$(expr $n + 1)\ndone\n\n#error condition: no items to copy or no destination\n    if [ $count_i -lt 0 ]; then \n            echo \"Error: You haven't listed any items for copying. Exiting.\" # you didn't put any items for copying\n    elif [ $count_i -lt 1 ]; then\n            echo \"Error: Copying usually involves a destination. Exiting.\" # you put one item and no destination\n    fi\n\n#reset the counter and grab content of arguments, aka: switches and item paths\nn=1\nwhile true; do\n        eval input=\"\\$$n\" #input=$1,$2,$3,etc...\n        in_=${input::1} #first letter of $input\n\n        if [ \"$in_\" = \"-\" ]; then\n            if [ \"$input\" = \"--rename\" ]; then \n                rename=true #my custom switches\n            elif [ \"$input\" = \"--strict\" ]; then \n                easy_going=false #exit script if even one of the non-destinations item is not found\n            elif [ \"$input\" = \"--relaxed\" ]; then \n                easy_going=true #continue script if at least one of the non-destination items is found\n            elif [ \"$input\" = \"--quiet\" ]; then \n                verbal=\"\"\n            else\n                #m=$(expr $m + 1);eval switch$m=\"$input\" #input is a switch, if it's not one of the above, assume it belongs to cp.\n                switch_list=\"$switch_list \\\"$input\\\"\"\n            fi                                  \n        elif ! [ -z \"$input\" ]; then #if it's not a switch and input is not empty, it's a path\n                i=$(expr $i + 1)\n                if [ ! -f \"$input\" -a ! -d \"$input\" -a \"$i\" -le \"$count_i\" ]; then \n                    err=$(expr $err + 1 ); error_list=\"$error_list\\npath does not exit: \\\"b\\\"\"\n                else\n                    if [ \"$i\" -le \"$count_i\" ]; then \n                        eval item$i=\"$input\" \n                        item_list=\"$item_list \\\"$input\\\"\"\n                    else\n                        destination=\"$input\" #destination is last items entered\n                    fi\n                fi\n        else\n            i=0\n            m=0\n            n=1                     \n            break\n        fi      \n        n=$(expr $n + 1)\ndone\n\n#error condition: some or all item(s) being copied don't exist. easy_going: continue if at least one item exists, warn about rest, not easy_going: exit.\n#echo \"err=$err count_i=$count_i\"\nif [ \"$easy_going\" != true -a $err -gt 0 -a $err != $count_i ]; then \n    echo \"Some of the paths you entered are incorrect. Script is running in strict mode and will therefore exit.\"\n    echo -e \"Bad Paths: $err $error_list\"\n    exit\nfi\n\nif [ $err = $count_i ]; then\n    echo \"ALL THE PATHS you have entered are incorrect! Exiting.\"\n    echo -e \"Bad Paths: $err $error_list\"\nfi\n\n#one item to one destination:\n#------------------------------\n#assumes that destination is folder, it does't exist, it will create it. (so copying /a/b/c/d/firefox to /e/f/firefox will result in /e/f/firefox/firefox\n#if -rename switch is given, will assume that the top element of destination path is the new name for the the item being given.\n\n#multi-item to single destination:\n#------------------------------\n#assumes destination is a folder, gives error if it exists and it's a file. -rename switch will be ignored.\n\n#ERROR CONDITIONS: \n# - multiple items being sent to a destination and it's a file.\n# - if -rename switch was given and multiple items are being copied, rename switch will be ignored (easy_going). if not easy_going, exit.\n# - rename option but source is folder, destination is file, exit.\n# - rename option but source is file and destination is folder. easy_going: option ignored.\n\nif [ -f \"$destination\" ]; then\n    if [ $count_i -gt 1 ]; then \n        echo \"Error: You've selected a single file as a destination and are copying multiple items to it. Exiting.\"; exit\n    elif [ -d \"$item1\" ]; then\n        echo \"Error: Your destination is a file but your source is a folder. Exiting.\"; exit\n    fi\nfi\nif [ \"$rename\" = true ]; then\n    if [ $count_i -gt 1 ]; then\n        if [ $easy_going = true ]; then\n            echo \"Warning: you choose the rename option but are copying multiple items. Ignoring Rename option. Continuing.\"\n        else\n            echo \"Error: you choose the rename option but are copying multiple items. Script running in strict mode. Exiting.\"; exit\n        fi\n    elif [ -d \"$destination\" -a -f \"$item1\" ]; then\n        echo -n \"Warning: you choose the rename option but source is a file and destination is a folder with the same name. \"\n        if [ $easy_going = true ]; then\n            echo \"Ignoring Rename option. Continuing.\"\n        else\n            echo \"Script running in strict mode. Exiting.\"; exit\n        fi\n    else\n        dest_jr=$(dirname \"$destination\")\n        if [ -d \"$destination\" ]; then item_list=\"$item1/*\";fi\n        mkdir -p \"$dest_jr\"\n    fi\nelse\n    mkdir -p \"$destination\"\nfi\n\neval cp $switch_list $verbal $item_list \"$destination\"\n\ncp_err=\"$?\"\nif [ \"$cp_err\" != 0 ]; then \n    echo -e \"Something went wrong with the copy operation. \\nExit Status: $cp_err\"\nelse \n    echo \"Copy operation exited with no errors.\"\nfi\n\nexit\n\n", "\ncp has multiple usages:\n$ cp --help\nUsage: cp [OPTION]... [-T] SOURCE DEST\n  or:  cp [OPTION]... SOURCE... DIRECTORY\n  or:  cp [OPTION]... -t DIRECTORY SOURCE...\nCopy SOURCE to DEST, or multiple SOURCE(s) to DIRECTORY.\n\n@AndyRoss's answer works for the\ncp SOURCE DEST\n\nstyle of cp, but does the wrong thing if you use the\ncp SOURCE... DIRECTORY/\n\nstyle of cp.\nI think that \"DEST\" is ambiguous without a trailing slash in this usage (i.e. where the target directory doesn't yet exist), which is perhaps why cp has never added an option for this.\nSo here's my version of this function which enforces a trailing slash on the dest dir:\ncp-p() {\n  last=${@: -1}\n\n  if [[ $# -ge 2 && \"$last\" == */ ]] ; then\n    # cp SOURCE... DEST/\n    mkdir -p \"$last\" && cp \"$@\"\n  else\n    echo \"cp-p: (copy, creating parent dirs)\"\n    echo \"cp-p: Usage: cp-p SOURCE... DEST/\"\n  fi\n}\n\n", "\nJust had the same issue. My approach was to just tar the files into an archive like so: \ntar cf your_archive.tar file1 /path/to/file2 path/to/even/deeper/file3\ntar automatically stores the files in the appropriate structure within the archive. If you run \ntar xf your_archive.tar \nthe files are extracted into the desired directory structure.\n", "\ni strongly suggest ditto.\njust works.\nditto my/location/poop.txt this/doesnt/exist/yet/poop.txt\n", "\nCopy from source to an non existing path\nmkdir \u2013p /destination && cp \u2013r /source/ $_\n\nNOTE: this command copies all the files\ncp \u2013r for copying all folders and its content\n$_ work as destination which is created in last command\n", "\nOneliner to create a small script that can be used as subcommand, in find for instance:\nset +H; echo -e \"#!/bin/sh\\nmkdir -p \\$(dirname \\\"\\$2\\\"); cp \\\"\\$1\\\" \\\"$2\\\"\\;\" > ~/local/bin/cpmkdir; chmod +x ~/local/bin/cpmkdir\nYou can then use it like:\nfind -name files_you_re_lookin_for.* -exec cpmkdir {} ../extracted_copy/{} \\;\n", "\nrsync file /path/to/copy/file/to/is/very/deep/there\n\nThis might work, if you have the right kind of rsync.\n", "\nYou can use find with Perl. Command will be like this:\nfind file | perl -lne '$t = \"/path/to/copy/file/to/is/very/deep/there/\"; /^(.+)\\/.+$/; `mkdir -p $t$1` unless(-d \"$t$1\"); `cp $_ $t$_` unless(-f \"$t$_\");'\n\nThis command will create directory $t if it doesn't exist. And than copy file into $t only unless file exists inside $t.\n", "\nThis works on GNU /bin/bash version 3.2 on MacOS (tested on both Catalina and Big Sur)\ncp -Rv <existing-source-folder>/   <non-existing-2becreated-destination-folder>\n\nthe \"v\" option is for verbose.\nAnd I think of the \"-R\" option as \"Recursive\".\nman's full description of -R is:\n\nIf source_file designates a directory, cp copies the directory and the entire subtree connected at that point.  If the source_file ends in a /, the contents of the directory are copied rather than the directory itself.  This option also causes symbolic links to be copied, rather than indirected through, and for cp to create special files rather than copying them as normal files.  Created directories have the same mode as the corresponding source directory, unmodified by the process' umask.\nIn -R mode, cp will continue copying even if errors are detected.\nNote that cp copies hard-linked files as separate files.  If you need to preserve hard links, consider using tar(1), cpio(1), or pax(1) instead.\n\nIn the example below, I'm using a \"/\" at the end of existingfolder so that it copies all the contents of existingfolder (and not the folder itself) into newfolder:\ncp -Rv existingfolder/  newfolder\n\nTry it.\n", "\nMany of the other solutions don't work on files or folders which need escaping.  Here is a solution which works for files and folders, and escapes spaces and other special characters.  Tested in a busybox ash shell which doesn't have access to some of the fancier options.\nexport file=\"annoying folder/bar.txt\"\nexport new_parent=\"/tmp/\"\n\n# Creates /tmp/annoying folder/\nmkdir -p \"$(dirname \"$new_folder/$file\")\"\n\n# Copies file to /tmp/annoying folder/bar.txt\ncp -r \"$file\" \"$new_folder/$file\"\n\nThis should also work if you omit bar.txt if you need the recursive copy of a whole folder.\n", "\nLet's say you are doing something like\n\ncp file1.txt A/B/C/D/file.txt\n\nwhere A/B/C/D are directories which do not exist yet\nA possible solution is as follows\nDIR=$(dirname A/B/C/D/file.txt)\n# DIR= \"A/B/C/D\"\nmkdir -p $DIR\ncp file1.txt A/B/C/D/file.txt\n\nhope that helps!\n", "\nOnly for macOS\nrsync -R <source file path> destination_folder\n\nFor macOS --parents option of cp doesn't work\n", "\n(If my answer doesn't get blocked here...) couldn't this help in rsync:\nrsync --mkpath sourcedir/ destdir\n\nThe destdir is created if non-existent.\n", "\nCopy files from ./assets/ to other dir with current date\nrsync -avd ./assets/ ~/backup/project_x/assets/$(date '+%Y-%m-%d')\n\n-a                          Copy files from sub-dir of source dir\n-d, --dirs                  Also copy directories\n-u, --update                skip files that are newer on the receiver\n    --inplace               update destination files in-place\n    --append                append data onto shorter files\n-l, --links                 copy symlinks as symlinks\n\nMore Information:\nrsync [Options] [Source] [Destination]\n\nCopy content of x to y directory x/a.txt y/a.txt :\nrsync -av x/ y\n\nCopy a.txt and b.txt only from x to y dir :\nrsync -av 'x/a.txt x/b.txt' y\n\nLocal to remote :\nrsync [OPTION]... SRC [SRC]... rsync://[USER@]HOST[:PORT]/DEST\n\nRemote to local :\nrsync [OPTION]... rsync://[USER@]HOST[:PORT]/SRC [DEST]\n\nIgnore from a file :\nrsync -avd --delete --exclude-from=.resyncignore\n\n\n\nman rsync - To list all the available options for rsync\nman date - for more information on other date format\n\n\n", "\nMaybe us CP for individual files and wse rsync for directories ?\nrsync -vazh /source /destination\n\n(includes 'source' dir)\nrsync -vazh /source/ /destination\n\n(does not include 'source' dir)\n", "\n#!/bin/bash\ncp -r --copy-contents source/ target/\n\n--copy-contents means copy only the content of source\nfor understand better that happend in your case test this script: \n#!/bin/bash\npwd\n\nyou can do some like that if this pwd  write different places:\n#!/bin/bash\ncd SOURCE_PARENT\ncp -r --copy-contents source/ target/\n\nif you have spaces in the target or source name  have this in mind\ncp [OPTION]... SOURCE... DIRECTORY\ntarget name <= \"target realTarget\"\ncp -r source target realTarget\n\ncp -r source target realTarget  believe that  you want copy source & target in realTarget it don't understand that \"target realTarget\" is a full name if you need copy it you have to use the double quotation marks in the comandad\ncp -r source \"target realTarget\"\n\ncp -r source \"target realTarget\" now \"target realTarget\" is taken as folder name\nwith source happend the same use the double quotation marks and you will solve the problem \n->with your extra: (escape the quotes using \\) \nSOURCE=\"\\\"source realsource\\\"\" \ncp -rT --copy-contents $SOURCE $TARGET\n\n-T, --no-target-directory\ntreat DEST as a normal file\n", "\n\njust for fun, if you need a big list of files:\ntee <sourcefile.jpg targetfiles{01-50}.jpg >/dev/null- Kelvin Feb 12 at 19:52\n\nBut there's a little typo. Should be:\n\ntee <sourcefile.jpg targetfiles{01..50}.jpg >/dev/null\n\nAnd as mentioned above, that doesn't copy permissions.\n", "\nDoes\ncp file1 file2 ; cp file1 file3\n\ncount as a \"one-line command/script\"? How about\nfor file in file2 file3 ; do cp file1 \"$file\" ; done\n\n?\nOr, for a slightly looser sense of \"copy\":\ntee <file1 file2 file3 >/dev/null\n\n", "\nYou can improve/simplify the for approach (answered by @ruakh) of copying by using ranges from bash brace expansion:\nfor f in file{1..10}; do cp file $f; done\n\nThis copies file into file1, file2, ..., file10.\nResource to check:\n\nhttp://wiki.bash-hackers.org/syntax/expansion/brace#ranges\n\n", "\nfor FILE in \"file2\" \"file3\"; do cp file1 $FILE; done\n\n", "\n(no loops used)\nTo copy the content of one file (fileA.txt) to many files (fileB.txt, fileC.txt, fileD.txt) in Linux,\nuse the following combination cat and tee commands:\ncat fileA.txt | tee fileB.txt fileC.txt fileD.txt >/dev/null\n\n\napplicable to any file extensions\nonly file names and extensions change, everything else remains same.\n\n", "\nYou can use shift:\nfile=$1\nshift\nfor dest in \"$@\" ; do\n    cp -r $file $dest\ndone\n\n", "\ncat file1 | tee file2 | tee file3 | tee file4 | tee file5 >/dev/null\n", "\nUse something like the following. It works on zsh.\n\ncat file > firstCopy > secondCopy > thirdCopy\n\nor\n\ncat file > {1..100} - for filenames with numbers.\n\nIt's good for small files.\nYou should use the cp script mentioned earlier for larger files.\n", "\nI'd recommend creating a general use script and a function (empty-files), based on the script, to empty any number of target files.\nName the script copy-from-one-to-many and put it in your PATH.\n#!/bin/bash -e\n#  _ _____     \n# | |___ /_  __  \n# | | |_ \\ \\/ /  Lex Sheehan (l3x)\n# | |___) >  <   https://github.com/l3x\n# |_|____/_/\\_\\  \n#\n# Copy the contents of one file to many other files.\n\nsource=$1\nshift\nfor dest in \"$@\"; do\n    cp $source $dest\ndone\n\nexit\n\nNOTES\nThe shift above removes the first element (the source file path) from the list of arguments (\"$@\").\nExamples of how to empty many files:\nCreate file1, file2, file3, file4 and file5 with content:\nfor f in file{1..5}; do echo $f > \"$f\"; done\n\nEmpty many files:\ncopy-from-one-to-many /dev/null file1 file2 file3 file4 file5\n\nEmpty many files easier:\n# Create files with content again\nfor f in file{1..5}; do echo $f > \"$f\"; done \n\ncopy-from-one-to-many /dev/null file{1..5}\n\nCreate empty_files function based on copy-from-one-to-many\nfunction empty-files()\n{\n    copy-from-one-to-many /dev/null \"$@\"\n}\n\nExample usage\n# Create files with content again\nfor f in file{1..5}; do echo $f > \"$f\"; done \n# Show contents of one of the files\necho -e \"file3:\\n $(cat file3)\"\n\nempty_files file{1..5}\n# Show that the selected file no longer has contents\necho -e \"file3:\\n $(cat file3)\"\n\n\nDon't just steal code. Improve it; Document it with examples and share it. - l3x\n\n\nHere's a version that will preface each cp command with sudo:\n#!/bin/bash -e\n# Filename: copy-from-one-to-may\n#  _ _____     \n# | |___ /_  __  \n# | | |_ \\ \\/ /  Lex Sheehan (l3x)\n# | |___) >  <   https://github.com/l3x\n# |_|____/_/\\_\\  \n#\n# Copy the contents of one file to many other files.\n# Pass --sudo if you want each cp to be perfomed with sudo\n# Ex: copy-from-one-to-many $(mktemp) /tmp/a /tmp/b /tmp/c --sudo\n\nif [[ \"$*\" == *--sudo* ]]; then\n    maybe_use_sudo=sudo\nfi\n\nsource=$1\nshift\nfor dest in \"$@\"; do\n    if [ $dest != '--sudo' ]; then\n      $maybe_use_sudo cp $source $dest\n    fi\ndone\n\nexit\n\n", "\nYou can use standard scripting commands for that instead:\nBash:\n for i in file2 file3 ; do cp file1 $i ; done\n\n", "\nThe simplest/quickest solution I can think of is a for loop:\nfor target in file2 file3 do; cp file1 \"$target\"; done\n\nA dirty hack would be the following (I strongly advise against it, and only works in bash anyway):\neval 'cp file1 '{file2,file3}';'\n\n", "\nGo with the fastest cp operations\nseq 1 10 | xargs -P 0 -I xxx cp file file-xxx\n\nit means\n\nseq 1 10 count from 1 to 10\n| pipe it xargs\n-P 0 do it in parallel - as many as needed\n-I xxx name of each input xargs receives\ncp file file-xxx means copy file to file-1, file-2, etc\n\nand if name of files are different here is the other solutions.\nFirst have the list of files which are going to be created. e.g.\none\ntwo\nthree\nfour\nfive\n\nSecond save this list on disk and read the list with xargs just like before but without using seq.\nxargs -P 0 -I xxx cp file xxx  < list\n\nwhich means 5 copy operations in parallel:\ncp file one  \ncp file two  \ncp file three  \ncp file four  \ncp file five  \n\nand for xargs here is the behind the scene (5 forks)\n 3833 pts/0    Ss     0:00 bash\n15954 pts/0           0:00  \\_ xargs -P 0 -I xxx cp file xxx < list\n15955 pts/0           0:00      \\_ cp file one\n15956 pts/0           0:00      \\_ cp file two\n15957 pts/0           0:00      \\_ cp file three\n15958 pts/0           0:00      \\_ cp file four\n15959 pts/0           0:00      \\_ cp file five\n\n", "\nYou can do this using -T option in cp.\nSee Man page for cp.\n-T, --no-target-directory\n    treat DEST as a normal file\n\nSo as per your example, following is the file structure.\n$ tree test\ntest\n|-- bar\n|   |-- a\n|   `-- b\n`-- foo\n    |-- a\n    `-- b\n2 directories, 4 files\n\nYou can see the clear difference when you use -v for Verbose.\nWhen you use just -R option.\n$ cp -Rv foo/ bar/\n`foo/' -> `bar/foo'\n`foo/b' -> `bar/foo/b'\n`foo/a' -> `bar/foo/a'\n $ tree\n |-- bar\n |   |-- a\n |   |-- b\n |   `-- foo\n |       |-- a\n |       `-- b\n `-- foo\n     |-- a\n     `-- b\n3 directories, 6 files\n\nWhen you use the option -T it overwrites the contents, treating the destination like a normal file and not directory.\n$ cp -TRv foo/ bar/\n`foo/b' -> `bar/b'\n`foo/a' -> `bar/a'\n\n$ tree\n|-- bar\n|   |-- a\n|   `-- b\n`-- foo\n    |-- a\n    `-- b\n2 directories, 4 files\n\nThis should solve your problem.\n", "\nIf you want to ensure bar/ ends up identical to foo/, use rsync instead:\nrsync -a --delete foo/ bar/\n\nIf just a few things have changed, this will execute much faster than removing and re-copying the whole directory.\n\n-a is 'archive mode', which copies faithfully files in foo/ to bar/\n--delete removes extra files not in foo/ from bar/ as well, ensuring bar/ ends up identical\nIf you want to see what it's doing, add -vh for verbose and human-readable\nNote: the slash after foo is required, otherwise rsync will copy foo/ to bar/foo/ rather than overwriting bar/ itself.\n\n\n(Slashes after directories in rsync are confusing; if you're interested, here's the scoop. They tell rsync to refer to the contents of the directory, rather than the directory itself. So to overwrite from the contents of foo/ onto the contents of bar/, we use a slash on both. It's confusing because it won't work as expected with a slash on neither, though; rsync sneakily always interprets the destination path as though it has a slash, even though it honors an absence of a slash on the source path. So we need a slash on the source path to make it match the auto-added slash on the destination path, if we want to copy the contents of foo/ into bar/, rather than the directory foo/ itself landing into bar/ as bar/foo.)\n\n\nrsync is very powerful and useful, if you're curious look around for what else it can do (such as copying over ssh).\n", "\nDo it in two steps.\nrm -r bar/\ncp -r foo/ bar/\n\n", "\nUse this cp command:\ncp -Rf foo/* bar/\n\n", "\nThe following command ensures dotfiles (hidden files) are included in the copy:\n$ cp -Rf foo/. bar\n\n", "\nVery similar to @Jonathan Wheeler:\nIf you do not want to remember, but not rewrite bar:\nrm -r bar/\ncp -r foo/ !$\n\n!$ displays the last argument of your previous command.\n", "\nthis should solve your problem. \n\\cp -rf foo/* bar/\n\n", "\nIn case you're in Git Bash for Windows:\nrobocopy path/to/source path/to/target -MIR\n-MIR means mirror, it'll result in two identical folders. Existing files will be skipped, extra files will be deleted.\n", "\nThe operation you defined is a \"merge\" and you cannot do that with cp. However, if you are not looking for merging and ok to lose the folder bar then you can simply rm -rf bar to delete the folder and then mv foo bar to rename it. This will not take any time as both operations are done by file pointers, not file contents.\n", "\nYou may try this bash script\n#!/bin/bash\n\ncd \"${0%/*}\" || exit\nfor dir in */; do\n    if [[ $dir != 'ak/' ]]; then\n        cp ak/tt.txt \"$dir\"\n    fi\ndone\n\nThe script must reside under the diectory mnt/d/LIVI\n", "\nIf you want to move from b to c the files named in a.txt (and they don't have spaces or wildcards):\n(cd /path/to/b && mv $(< /path/to/a.txt) /path/to/c/)\n\n"], "rejected": ["\nIt is not cp -i. If you do not want to be asked for confirmation,\nit is cp -n; for example:\ncp -n src dest\n\nOr in case of directories/folders is:\ncp -nr src_dir dest_dir\n\n", "\nIt is not cp -i. If you do not want to be asked for confirmation,\nit is cp -n; for example:\ncp -n src dest\n\nOr in case of directories/folders is:\ncp -nr src_dir dest_dir\n\n", "\nIt is not cp -i. If you do not want to be asked for confirmation,\nit is cp -n; for example:\ncp -n src dest\n\nOr in case of directories/folders is:\ncp -nr src_dir dest_dir\n\n", "\nIt is not cp -i. If you do not want to be asked for confirmation,\nit is cp -n; for example:\ncp -n src dest\n\nOr in case of directories/folders is:\ncp -nr src_dir dest_dir\n\n", "\nIt is not cp -i. If you do not want to be asked for confirmation,\nit is cp -n; for example:\ncp -n src dest\n\nOr in case of directories/folders is:\ncp -nr src_dir dest_dir\n\n", "\nIt is not cp -i. If you do not want to be asked for confirmation,\nit is cp -n; for example:\ncp -n src dest\n\nOr in case of directories/folders is:\ncp -nr src_dir dest_dir\n\n", "\nIt is not cp -i. If you do not want to be asked for confirmation,\nit is cp -n; for example:\ncp -n src dest\n\nOr in case of directories/folders is:\ncp -nr src_dir dest_dir\n\n", "\nIt is not cp -i. If you do not want to be asked for confirmation,\nit is cp -n; for example:\ncp -n src dest\n\nOr in case of directories/folders is:\ncp -nr src_dir dest_dir\n\n", "\nIt is not cp -i. If you do not want to be asked for confirmation,\nit is cp -n; for example:\ncp -n src dest\n\nOr in case of directories/folders is:\ncp -nr src_dir dest_dir\n\n", "\nIt is not cp -i. If you do not want to be asked for confirmation,\nit is cp -n; for example:\ncp -n src dest\n\nOr in case of directories/folders is:\ncp -nr src_dir dest_dir\n\n", "\nIt is not cp -i. If you do not want to be asked for confirmation,\nit is cp -n; for example:\ncp -n src dest\n\nOr in case of directories/folders is:\ncp -nr src_dir dest_dir\n\n", "\nIt is not cp -i. If you do not want to be asked for confirmation,\nit is cp -n; for example:\ncp -n src dest\n\nOr in case of directories/folders is:\ncp -nr src_dir dest_dir\n\n", "\nIt is not cp -i. If you do not want to be asked for confirmation,\nit is cp -n; for example:\ncp -n src dest\n\nOr in case of directories/folders is:\ncp -nr src_dir dest_dir\n\n", "\nIt is not cp -i. If you do not want to be asked for confirmation,\nit is cp -n; for example:\ncp -n src dest\n\nOr in case of directories/folders is:\ncp -nr src_dir dest_dir\n\n", "\nIt is not cp -i. If you do not want to be asked for confirmation,\nit is cp -n; for example:\ncp -n src dest\n\nOr in case of directories/folders is:\ncp -nr src_dir dest_dir\n\n", "\nIt is not cp -i. If you do not want to be asked for confirmation,\nit is cp -n; for example:\ncp -n src dest\n\nOr in case of directories/folders is:\ncp -nr src_dir dest_dir\n\n", "\nIt is not cp -i. If you do not want to be asked for confirmation,\nit is cp -n; for example:\ncp -n src dest\n\nOr in case of directories/folders is:\ncp -nr src_dir dest_dir\n\n", "\nIt is not cp -i. If you do not want to be asked for confirmation,\nit is cp -n; for example:\ncp -n src dest\n\nOr in case of directories/folders is:\ncp -nr src_dir dest_dir\n\n", "\nUse: for i in *.txt; do cp \"$i\" \"$i.cp\"; done\nExample:\n$ ls -l *.txt\n-rw-r--r-- 1 halley halley 20 out 27 08:14 1.txt\n-rw-r--r-- 1 halley halley 25 out 27 08:14 2.txt\n-rw-r--r-- 1 halley halley 33 out 27 08:15 3.txt\n$ ls -l *.cp\nls: could not access '*.cp': File or directory does not exist\n$ for i in *.txt; do cp \"$i\" \"$i.cp\"; done\n$ ls -l *.cp\n-rw-r--r-- 1 halley halley 20 out 27 08:32 1.txt.cp\n-rw-r--r-- 1 halley halley 25 out 27 08:32 2.txt.cp\n-rw-r--r-- 1 halley halley 33 out 27 08:32 3.txt.cp\n$ for i in *.txt; do diff \"$i\" \"$i.cp\"; done\n$ \n\n", "\nUse: for i in *.txt; do cp \"$i\" \"$i.cp\"; done\nExample:\n$ ls -l *.txt\n-rw-r--r-- 1 halley halley 20 out 27 08:14 1.txt\n-rw-r--r-- 1 halley halley 25 out 27 08:14 2.txt\n-rw-r--r-- 1 halley halley 33 out 27 08:15 3.txt\n$ ls -l *.cp\nls: could not access '*.cp': File or directory does not exist\n$ for i in *.txt; do cp \"$i\" \"$i.cp\"; done\n$ ls -l *.cp\n-rw-r--r-- 1 halley halley 20 out 27 08:32 1.txt.cp\n-rw-r--r-- 1 halley halley 25 out 27 08:32 2.txt.cp\n-rw-r--r-- 1 halley halley 33 out 27 08:32 3.txt.cp\n$ for i in *.txt; do diff \"$i\" \"$i.cp\"; done\n$ \n\n", "\nSimple\ncp -a * /path/to/dst/\n\nshould do the trick.\n", "\nSimple\ncp -a * /path/to/dst/\n\nshould do the trick.\n", "\nSimple\ncp -a * /path/to/dst/\n\nshould do the trick.\n", "\nSimple\ncp -a * /path/to/dst/\n\nshould do the trick.\n", "\nSimple\ncp -a * /path/to/dst/\n\nshould do the trick.\n", "\nSimple\ncp -a * /path/to/dst/\n\nshould do the trick.\n", "\nSimple\ncp -a * /path/to/dst/\n\nshould do the trick.\n", "\nSimple\ncp -a * /path/to/dst/\n\nshould do the trick.\n", "\nSimple\ncp -a * /path/to/dst/\n\nshould do the trick.\n", "\nSimple\ncp -a * /path/to/dst/\n\nshould do the trick.\n", "\nSimple\ncp -a * /path/to/dst/\n\nshould do the trick.\n", "\nSimple\ncp -a * /path/to/dst/\n\nshould do the trick.\n", "\nSimple\ncp -a * /path/to/dst/\n\nshould do the trick.\n", "\nSimple\ncp -a * /path/to/dst/\n\nshould do the trick.\n", "\nSimple\ncp -a * /path/to/dst/\n\nshould do the trick.\n", "\nSimple\ncp -a * /path/to/dst/\n\nshould do the trick.\n", "\nSimple\ncp -a * /path/to/dst/\n\nshould do the trick.\n", "\nSimple\ncp -a * /path/to/dst/\n\nshould do the trick.\n", "\nSimple\ncp -a * /path/to/dst/\n\nshould do the trick.\n", "\nSimple\ncp -a * /path/to/dst/\n\nshould do the trick.\n", "\nSimple\ncp -a * /path/to/dst/\n\nshould do the trick.\n", "\nSimple\ncp -a * /path/to/dst/\n\nshould do the trick.\n", "\nSimple\ncp -a * /path/to/dst/\n\nshould do the trick.\n", "\nSimple\ncp -a * /path/to/dst/\n\nshould do the trick.\n", "\nSimple\ncp -a * /path/to/dst/\n\nshould do the trick.\n", "\nSimple\ncp -a * /path/to/dst/\n\nshould do the trick.\n", "\nSimple\ncp -a * /path/to/dst/\n\nshould do the trick.\n", "\nSimple\ncp -a * /path/to/dst/\n\nshould do the trick.\n", "\nAlthough your main issue concerns the cp command there is also something I would like to say about your try. So lets get it step by step.\nIssue 1: cp behaviour\nThe cp command behaves differently when the target folder contains a folder with the same name than the source folder. This behaviour is intended but can be avoided using the -T option according to man. \nHere you can find an extended explanation of the -T option. \nThus, you can just execute:\ncp -rT source/ target/\n\nIssue 2: Paths containing spaces\nIn your try you mention issues when handling paths using spaces. Although with the previous solution you don't need a custom script, I want to highlight that variables with paths containing spaces require all accesses to be double-quoted. The variable content must be double-quoted, not the star (since you want the globstar to expand, not to be taken literally). Hence, your previous script would look like this:\n#!/bin/bash\n\nSOURCE=${1:-\"source\"}\nTARGET=${2:-\"target\"}\n\nif [ -d \"$TARGET\" ]; then\n  cp -r \"$SOURCE\" \"$TARGET\"     \nelse\n  cp -r \"$SOURCE\"/* \"$TARGET\"    # note \"$SOURCE/*\" would fail.\nfi\n\n", "\nAlthough your main issue concerns the cp command there is also something I would like to say about your try. So lets get it step by step.\nIssue 1: cp behaviour\nThe cp command behaves differently when the target folder contains a folder with the same name than the source folder. This behaviour is intended but can be avoided using the -T option according to man. \nHere you can find an extended explanation of the -T option. \nThus, you can just execute:\ncp -rT source/ target/\n\nIssue 2: Paths containing spaces\nIn your try you mention issues when handling paths using spaces. Although with the previous solution you don't need a custom script, I want to highlight that variables with paths containing spaces require all accesses to be double-quoted. The variable content must be double-quoted, not the star (since you want the globstar to expand, not to be taken literally). Hence, your previous script would look like this:\n#!/bin/bash\n\nSOURCE=${1:-\"source\"}\nTARGET=${2:-\"target\"}\n\nif [ -d \"$TARGET\" ]; then\n  cp -r \"$SOURCE\" \"$TARGET\"     \nelse\n  cp -r \"$SOURCE\"/* \"$TARGET\"    # note \"$SOURCE/*\" would fail.\nfi\n\n", "\nI don't know how correct this is but i have used something like this\necho ./file1.txt ./file2.txt ./file3.txt | xargs -n 1 cp file.txt\n\nWhere echo ./file1.txt ... is destination of a file and use it to feed xargs with one \"destination\" by one. Therefore command xargs -n 1. And lastly cp file.txt, which is self explanatory i think :)\n", "\nI don't know how correct this is but i have used something like this\necho ./file1.txt ./file2.txt ./file3.txt | xargs -n 1 cp file.txt\n\nWhere echo ./file1.txt ... is destination of a file and use it to feed xargs with one \"destination\" by one. Therefore command xargs -n 1. And lastly cp file.txt, which is self explanatory i think :)\n", "\nI don't know how correct this is but i have used something like this\necho ./file1.txt ./file2.txt ./file3.txt | xargs -n 1 cp file.txt\n\nWhere echo ./file1.txt ... is destination of a file and use it to feed xargs with one \"destination\" by one. Therefore command xargs -n 1. And lastly cp file.txt, which is self explanatory i think :)\n", "\nI don't know how correct this is but i have used something like this\necho ./file1.txt ./file2.txt ./file3.txt | xargs -n 1 cp file.txt\n\nWhere echo ./file1.txt ... is destination of a file and use it to feed xargs with one \"destination\" by one. Therefore command xargs -n 1. And lastly cp file.txt, which is self explanatory i think :)\n", "\nI don't know how correct this is but i have used something like this\necho ./file1.txt ./file2.txt ./file3.txt | xargs -n 1 cp file.txt\n\nWhere echo ./file1.txt ... is destination of a file and use it to feed xargs with one \"destination\" by one. Therefore command xargs -n 1. And lastly cp file.txt, which is self explanatory i think :)\n", "\nI don't know how correct this is but i have used something like this\necho ./file1.txt ./file2.txt ./file3.txt | xargs -n 1 cp file.txt\n\nWhere echo ./file1.txt ... is destination of a file and use it to feed xargs with one \"destination\" by one. Therefore command xargs -n 1. And lastly cp file.txt, which is self explanatory i think :)\n", "\nI don't know how correct this is but i have used something like this\necho ./file1.txt ./file2.txt ./file3.txt | xargs -n 1 cp file.txt\n\nWhere echo ./file1.txt ... is destination of a file and use it to feed xargs with one \"destination\" by one. Therefore command xargs -n 1. And lastly cp file.txt, which is self explanatory i think :)\n", "\nI don't know how correct this is but i have used something like this\necho ./file1.txt ./file2.txt ./file3.txt | xargs -n 1 cp file.txt\n\nWhere echo ./file1.txt ... is destination of a file and use it to feed xargs with one \"destination\" by one. Therefore command xargs -n 1. And lastly cp file.txt, which is self explanatory i think :)\n", "\nI don't know how correct this is but i have used something like this\necho ./file1.txt ./file2.txt ./file3.txt | xargs -n 1 cp file.txt\n\nWhere echo ./file1.txt ... is destination of a file and use it to feed xargs with one \"destination\" by one. Therefore command xargs -n 1. And lastly cp file.txt, which is self explanatory i think :)\n", "\nI don't know how correct this is but i have used something like this\necho ./file1.txt ./file2.txt ./file3.txt | xargs -n 1 cp file.txt\n\nWhere echo ./file1.txt ... is destination of a file and use it to feed xargs with one \"destination\" by one. Therefore command xargs -n 1. And lastly cp file.txt, which is self explanatory i think :)\n", "\nI don't know how correct this is but i have used something like this\necho ./file1.txt ./file2.txt ./file3.txt | xargs -n 1 cp file.txt\n\nWhere echo ./file1.txt ... is destination of a file and use it to feed xargs with one \"destination\" by one. Therefore command xargs -n 1. And lastly cp file.txt, which is self explanatory i think :)\n", "\nI don't know how correct this is but i have used something like this\necho ./file1.txt ./file2.txt ./file3.txt | xargs -n 1 cp file.txt\n\nWhere echo ./file1.txt ... is destination of a file and use it to feed xargs with one \"destination\" by one. Therefore command xargs -n 1. And lastly cp file.txt, which is self explanatory i think :)\n", "\nTry to use this command:\ncp -Rf foo/* bar/\n\n", "\nTry to use this command:\ncp -Rf foo/* bar/\n\n", "\nTry to use this command:\ncp -Rf foo/* bar/\n\n", "\nTry to use this command:\ncp -Rf foo/* bar/\n\n", "\nTry to use this command:\ncp -Rf foo/* bar/\n\n", "\nTry to use this command:\ncp -Rf foo/* bar/\n\n", "\nTry to use this command:\ncp -Rf foo/* bar/\n\n", "\nTry to use this command:\ncp -Rf foo/* bar/\n\n", "\nTry to use this command:\ncp -Rf foo/* bar/\n\n", "\nDon't read lines with for.\n(If you really wanted to, the syntax for that would look like\nfor dir in $(cat FOLDERS.txt); do\n    ...\n\nbut really, don't. The link above explains why in more detail.)\nI don't see why you want to run readlink on the directories at all?\ncd \"$(dirname \"$0\")\"\nwhile read -r dir; do\n    cp ak/tt.txt \"$dir\"\ndone <FOLDERS.txt\n\nNote also Correct Bash and shell script variable capitalization\n", "\nIf you know the filenames don't contain whitespace or wildcard characters, you can do it as a simple one-liner:\ncp $(<a.txt) b/\n\nIf they can contain special characters, you can read them into an array:\nreadarray files <a.txt\ncp \"${files[@]}\" b/\n\n"]}