{"prompt": ["Following the Linux from Scratch book I have managed to build a toolchain for an ARM on \nan ARM. This is till chapter 6 of the book, and on the ARM board itself I could go on further with no problems.\nMy question is if I can use the prepared environment to continue building the soft from chapter 6 on my x86_64 Fedora 16 laptop?\nI thought that while I have all the binaries set up I could just copy them to laptop, chroot inside and feel myself as on the ARM board, but using the command from the book gives no result: `# chroot \"$LFS\" /tools/bin/env -i  HOME=/root TERM=\"$TERM\" PS1='\\u:\\w\\$ \n  PATH=/bin:/usr/bin:/sbin:/usr/sbin:/tools/bin /tools/bin/bash --login +h\n      chroot: failed to run command `/tools/bin/env': No such file or directory`\nThe binary is there, but it doesn't belong to this system: `# ldd /tools/bin/env \n      not a dynamic executable`\nThe binary is compiled as per the book:\n     # readelf -l /tools/bin/env | grep interpreter\n          [Requesting program interpreter: /tools/lib/ld-linux.so.3]So I wonder if there is a way, like using proper environment variables for CC LD READELF, to continue building for ARM using these tools on x86_64 host.Thank you.", "Following the Linux from Scratch book I have managed to build a toolchain for an ARM on \nan ARM. This is till chapter 6 of the book, and on the ARM board itself I could go on further with no problems.\nMy question is if I can use the prepared environment to continue building the soft from chapter 6 on my x86_64 Fedora 16 laptop?\nI thought that while I have all the binaries set up I could just copy them to laptop, chroot inside and feel myself as on the ARM board, but using the command from the book gives no result: `# chroot \"$LFS\" /tools/bin/env -i  HOME=/root TERM=\"$TERM\" PS1='\\u:\\w\\$ \n  PATH=/bin:/usr/bin:/sbin:/usr/sbin:/tools/bin /tools/bin/bash --login +h\n      chroot: failed to run command `/tools/bin/env': No such file or directory`\nThe binary is there, but it doesn't belong to this system: `# ldd /tools/bin/env \n      not a dynamic executable`\nThe binary is compiled as per the book:\n     # readelf -l /tools/bin/env | grep interpreter\n          [Requesting program interpreter: /tools/lib/ld-linux.so.3]So I wonder if there is a way, like using proper environment variables for CC LD READELF, to continue building for ARM using these tools on x86_64 host.Thank you.", "I am trying to make a chroot'ed, sandboxed build-environement, which creates itself from a Git checkout before proceeding with building the application. One of the requirements is that the developers doing the git checkout and invoking the build should not need admin privileges on the host machine.unshare -r chroot  works fine - except there is no /proc which again means a lot of standeard stuff wont work.\nVarious methods to create /proc I have found with mount require sudo rights.Docker does this but the developers have to be in the \"docker\" group which effectively gives them uncontrolled root access - then rather give them sudo rights.I have found the \"proot\" which does some kind of emulation to do this. This, however, has some performance penalties. ", "I have a chroot environment where i am getting folder conflicts when I am running the below command./usr/bin/yum --verbose --assumeyes --installroot /home/prateek/project/.ova_work_dir/mnt/dst_root --config=/home/prateek/project/.ova_work_dir/mnt/dst_root/etc/yum.repos.d/project-upgrade.repo --obsoletes groupupdate '*' project\nBelow is the error Running transaction test\n\n    Transaction check error:\n      file /usr from install of messagebus_c-1.0.0-0.x86_64 conflicts with file from package filesystem-3.2-20.el7.x86_64\nI have below two questions to ask:1) Why i am getting folder conflict when yum is running transaction test as I have seen file conflicts but not folder conflicts.2) How would I resolve this folder conflicts.", "I have a chroot environment where i am getting folder conflicts when I am running the below command./usr/bin/yum --verbose --assumeyes --installroot /home/prateek/project/.ova_work_dir/mnt/dst_root --config=/home/prateek/project/.ova_work_dir/mnt/dst_root/etc/yum.repos.d/project-upgrade.repo --obsoletes groupupdate '*' project\nBelow is the error Running transaction test\n\n    Transaction check error:\n      file /usr from install of messagebus_c-1.0.0-0.x86_64 conflicts with file from package filesystem-3.2-20.el7.x86_64\nI have below two questions to ask:1) Why i am getting folder conflict when yum is running transaction test as I have seen file conflicts but not folder conflicts.2) How would I resolve this folder conflicts."], "chosen": ["\nYes, you certainly can chroot into an ARM rootfs on an x86 box.\nBasically, like this:\n$ sudo chroot /path/to/arm/rootfs /bin/sh\nsh-4.3# ls --version 2>&1 | head\n/bin/ls: unrecognized option '--version'\nBusyBox v1.22.1 (2017-03-02 15:41:43 CST) multi-call binary.\n\nUsage: ls [-1AaCxdLHRFplinsehrSXvctu] [-w WIDTH] [FILE]...\n\nList directory contents\n\n    -1  One column output\n    -a  Include entries which start with .\n    -A  Like -a, but exclude . and ..\nsh-4.3# ls\nbin       css       dev       home      media     proc      sbin      usr       wav\nboot      data      etc       lib       mnt       qemu-arm  sys       var\n\nMy rootfs is for a small embedded device, so everything is BusyBox-based.\nHow is this working? Firstly, I have the binfmt-misc support running in the kernel. I didn't have to do anything; it came with Ubuntu 18.  When the kernel sees an ARM binary, it hands it off to the registered interpreter  /usr/bin/qemu-arm-static.\nA static executable by that name is found inside my rootfs:\nsh-4.3# ls /usr/bin/q*\n/usr/bin/qemu-arm-static\n\nI got it from a Ubuntu package. I installed:\n$ apt-get install qemu-user-static\n\nand then copied /usr/bin/qemu-arm-static into the usr/bin subdirectory of the rootfs tree.\nThat's it; now I can chroot into that rootfs without even mentioning QEMU on the chroot command line.\n", "\nNope. You can't run ARM binaries on x86, so you can't enter its chroot. No amount of environment variables will change that.\nYou might be able to continue the process by creating a filesystem image for the target and running it under an emulator (e.g, qemu-system-arm), but that's quite a different thing.\n", "\nYou also need a mount namespace which will give you the ability to perform recursive bind mounts (and plain bind mount where there are no child mounts). pivot_root and the ability to mount tmpfs, so use unshare -rm.\nWith a pid namesapce you can also mount fresh instances of procfs.\n", "\nThe messagebus_c RPM specfile needs to be edited to not \"own\" /usr but instead all the files in it, e.g. /usr/*.\n", "\nCan you try this ?\n/usr/bin/yum --verbose --assumeyes --installroot=/home/prateek/project/.ova_work_dir/mnt/dst_root --config=/home/prateek/project/.ova_work_dir/mnt/dst_root/etc/yum.repos.d/project-upgrade.repo --obsoletes groupupdate '*' project\n\nissue was \nmissing equal to sign --installroot /home\nexpected like this    --installroot=/home\n"], "rejected": ["\nNo you cannot, at least not using chroot. What you have in your hands is a toolchain with an ARM target for an ARM host. Binaries are directly executable only on architectures compatible with their host architecture - and x86_64 is not ARM-compatible.\nThat said, you might be able to use an emulated environment. qemu, for example, offers two emulation modes for ARM: qemu-system-arm that emulates a whole ARM-based system and qemu-arm that uses ARM-native libraries to provide a thinner emulation layer for running ARM Linux executables on non-ARM hosts.\n", "\nNo you cannot, at least not using chroot. What you have in your hands is a toolchain with an ARM target for an ARM host. Binaries are directly executable only on architectures compatible with their host architecture - and x86_64 is not ARM-compatible.\nThat said, you might be able to use an emulated environment. qemu, for example, offers two emulation modes for ARM: qemu-system-arm that emulates a whole ARM-based system and qemu-arm that uses ARM-native libraries to provide a thinner emulation layer for running ARM Linux executables on non-ARM hosts.\n", "\nI ended up using bubblewrap (bwrap). For a few things using ttys, I had to let it run with pseudo uid 0 to work.\nIf I should do it now I would use podman I think.\n", "\nThis can happen when messagebus_c spec file has:\n%install\ntouch %{buildroot}/usr\n\n%files\n/usr\n\nI.e. here the /usr is a file. While filesystem provides it as a directory. You cannot have both. A directory cannot be a file. And vice versa.\n", "\nThis can happen when messagebus_c spec file has:\n%install\ntouch %{buildroot}/usr\n\n%files\n/usr\n\nI.e. here the /usr is a file. While filesystem provides it as a directory. You cannot have both. A directory cannot be a file. And vice versa.\n"]}