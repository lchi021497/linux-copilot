{"prompt": ["The path structure of the files on my server is similar to that shown below,/home/sun/sdir1/mp4/file.mp4\n/home/sun/collection/sdir2/mp4/file.mp4I would like to move the files of \"mp4\"  into one level up(into sdir1 and sdir2 respectively)So the output should be,/home/sun/sdir1/file.mp4\n/home/sun/collection/sdir2/file.mp4\nI have no idea to do this, so not tried yet anything...\n", "The path structure of the files on my server is similar to that shown below,/home/sun/sdir1/mp4/file.mp4\n/home/sun/collection/sdir2/mp4/file.mp4I would like to move the files of \"mp4\"  into one level up(into sdir1 and sdir2 respectively)So the output should be,/home/sun/sdir1/file.mp4\n/home/sun/collection/sdir2/file.mp4\nI have no idea to do this, so not tried yet anything...\n", "The path structure of the files on my server is similar to that shown below,/home/sun/sdir1/mp4/file.mp4\n/home/sun/collection/sdir2/mp4/file.mp4I would like to move the files of \"mp4\"  into one level up(into sdir1 and sdir2 respectively)So the output should be,/home/sun/sdir1/file.mp4\n/home/sun/collection/sdir2/file.mp4\nI have no idea to do this, so not tried yet anything...\n", "I'm facing this simple task but, I'm also wondering about what's the easiest and short way to do it.My proposal is move a given number of random files from a directory to another. This task is part of the creation of two datasets I need for machine learning: a training set and a testing set. My goal is move away 10% of the file from a directory in order to get the dataset against which I could test my categorizer, and obtain a training set from the source directory.So, what's the most compact typing for this \"move n random files\" task?", "I'm facing this simple task but, I'm also wondering about what's the easiest and short way to do it.My proposal is move a given number of random files from a directory to another. This task is part of the creation of two datasets I need for machine learning: a training set and a testing set. My goal is move away 10% of the file from a directory in order to get the dataset against which I could test my categorizer, and obtain a training set from the source directory.So, what's the most compact typing for this \"move n random files\" task?", "I'm facing this simple task but, I'm also wondering about what's the easiest and short way to do it.My proposal is move a given number of random files from a directory to another. This task is part of the creation of two datasets I need for machine learning: a training set and a testing set. My goal is move away 10% of the file from a directory in order to get the dataset against which I could test my categorizer, and obtain a training set from the source directory.So, what's the most compact typing for this \"move n random files\" task?", "I'm facing this simple task but, I'm also wondering about what's the easiest and short way to do it.My proposal is move a given number of random files from a directory to another. This task is part of the creation of two datasets I need for machine learning: a training set and a testing set. My goal is move away 10% of the file from a directory in order to get the dataset against which I could test my categorizer, and obtain a training set from the source directory.So, what's the most compact typing for this \"move n random files\" task?", "I'm facing this simple task but, I'm also wondering about what's the easiest and short way to do it.My proposal is move a given number of random files from a directory to another. This task is part of the creation of two datasets I need for machine learning: a training set and a testing set. My goal is move away 10% of the file from a directory in order to get the dataset against which I could test my categorizer, and obtain a training set from the source directory.So, what's the most compact typing for this \"move n random files\" task?", "I'm facing this simple task but, I'm also wondering about what's the easiest and short way to do it.My proposal is move a given number of random files from a directory to another. This task is part of the creation of two datasets I need for machine learning: a training set and a testing set. My goal is move away 10% of the file from a directory in order to get the dataset against which I could test my categorizer, and obtain a training set from the source directory.So, what's the most compact typing for this \"move n random files\" task?", "I'm facing this simple task but, I'm also wondering about what's the easiest and short way to do it.My proposal is move a given number of random files from a directory to another. This task is part of the creation of two datasets I need for machine learning: a training set and a testing set. My goal is move away 10% of the file from a directory in order to get the dataset against which I could test my categorizer, and obtain a training set from the source directory.So, what's the most compact typing for this \"move n random files\" task?", "So, if I'm in my home directory and I want to move foo.c to ~/bar/baz/foo.c , but those directories don't exist, is there some way to have those directories automatically created, so that you would only have to typemv foo.c ~/bar/baz/ \nand everything would work out? It seems like you could alias mv to a simple bash script that would check if those directories existed and if not would call mkdir and then mv, but I thought I'd check to see if anyone had a better idea.", "So, if I'm in my home directory and I want to move foo.c to ~/bar/baz/foo.c , but those directories don't exist, is there some way to have those directories automatically created, so that you would only have to typemv foo.c ~/bar/baz/ \nand everything would work out? It seems like you could alias mv to a simple bash script that would check if those directories existed and if not would call mkdir and then mv, but I thought I'd check to see if anyone had a better idea.", "So, if I'm in my home directory and I want to move foo.c to ~/bar/baz/foo.c , but those directories don't exist, is there some way to have those directories automatically created, so that you would only have to typemv foo.c ~/bar/baz/ \nand everything would work out? It seems like you could alias mv to a simple bash script that would check if those directories existed and if not would call mkdir and then mv, but I thought I'd check to see if anyone had a better idea.", "So, if I'm in my home directory and I want to move foo.c to ~/bar/baz/foo.c , but those directories don't exist, is there some way to have those directories automatically created, so that you would only have to typemv foo.c ~/bar/baz/ \nand everything would work out? It seems like you could alias mv to a simple bash script that would check if those directories existed and if not would call mkdir and then mv, but I thought I'd check to see if anyone had a better idea.", "So, if I'm in my home directory and I want to move foo.c to ~/bar/baz/foo.c , but those directories don't exist, is there some way to have those directories automatically created, so that you would only have to typemv foo.c ~/bar/baz/ \nand everything would work out? It seems like you could alias mv to a simple bash script that would check if those directories existed and if not would call mkdir and then mv, but I thought I'd check to see if anyone had a better idea.", "So, if I'm in my home directory and I want to move foo.c to ~/bar/baz/foo.c , but those directories don't exist, is there some way to have those directories automatically created, so that you would only have to typemv foo.c ~/bar/baz/ \nand everything would work out? It seems like you could alias mv to a simple bash script that would check if those directories existed and if not would call mkdir and then mv, but I thought I'd check to see if anyone had a better idea.", "So, if I'm in my home directory and I want to move foo.c to ~/bar/baz/foo.c , but those directories don't exist, is there some way to have those directories automatically created, so that you would only have to typemv foo.c ~/bar/baz/ \nand everything would work out? It seems like you could alias mv to a simple bash script that would check if those directories existed and if not would call mkdir and then mv, but I thought I'd check to see if anyone had a better idea.", "So, if I'm in my home directory and I want to move foo.c to ~/bar/baz/foo.c , but those directories don't exist, is there some way to have those directories automatically created, so that you would only have to typemv foo.c ~/bar/baz/ \nand everything would work out? It seems like you could alias mv to a simple bash script that would check if those directories existed and if not would call mkdir and then mv, but I thought I'd check to see if anyone had a better idea.", "So, if I'm in my home directory and I want to move foo.c to ~/bar/baz/foo.c , but those directories don't exist, is there some way to have those directories automatically created, so that you would only have to typemv foo.c ~/bar/baz/ \nand everything would work out? It seems like you could alias mv to a simple bash script that would check if those directories existed and if not would call mkdir and then mv, but I thought I'd check to see if anyone had a better idea.", "So, if I'm in my home directory and I want to move foo.c to ~/bar/baz/foo.c , but those directories don't exist, is there some way to have those directories automatically created, so that you would only have to typemv foo.c ~/bar/baz/ \nand everything would work out? It seems like you could alias mv to a simple bash script that would check if those directories existed and if not would call mkdir and then mv, but I thought I'd check to see if anyone had a better idea.", "So, if I'm in my home directory and I want to move foo.c to ~/bar/baz/foo.c , but those directories don't exist, is there some way to have those directories automatically created, so that you would only have to typemv foo.c ~/bar/baz/ \nand everything would work out? It seems like you could alias mv to a simple bash script that would check if those directories existed and if not would call mkdir and then mv, but I thought I'd check to see if anyone had a better idea.", "So, if I'm in my home directory and I want to move foo.c to ~/bar/baz/foo.c , but those directories don't exist, is there some way to have those directories automatically created, so that you would only have to typemv foo.c ~/bar/baz/ \nand everything would work out? It seems like you could alias mv to a simple bash script that would check if those directories existed and if not would call mkdir and then mv, but I thought I'd check to see if anyone had a better idea.", "So, if I'm in my home directory and I want to move foo.c to ~/bar/baz/foo.c , but those directories don't exist, is there some way to have those directories automatically created, so that you would only have to typemv foo.c ~/bar/baz/ \nand everything would work out? It seems like you could alias mv to a simple bash script that would check if those directories existed and if not would call mkdir and then mv, but I thought I'd check to see if anyone had a better idea.", "So, if I'm in my home directory and I want to move foo.c to ~/bar/baz/foo.c , but those directories don't exist, is there some way to have those directories automatically created, so that you would only have to typemv foo.c ~/bar/baz/ \nand everything would work out? It seems like you could alias mv to a simple bash script that would check if those directories existed and if not would call mkdir and then mv, but I thought I'd check to see if anyone had a better idea.", "So, if I'm in my home directory and I want to move foo.c to ~/bar/baz/foo.c , but those directories don't exist, is there some way to have those directories automatically created, so that you would only have to typemv foo.c ~/bar/baz/ \nand everything would work out? It seems like you could alias mv to a simple bash script that would check if those directories existed and if not would call mkdir and then mv, but I thought I'd check to see if anyone had a better idea.", "So, if I'm in my home directory and I want to move foo.c to ~/bar/baz/foo.c , but those directories don't exist, is there some way to have those directories automatically created, so that you would only have to typemv foo.c ~/bar/baz/ \nand everything would work out? It seems like you could alias mv to a simple bash script that would check if those directories existed and if not would call mkdir and then mv, but I thought I'd check to see if anyone had a better idea.", "So, if I'm in my home directory and I want to move foo.c to ~/bar/baz/foo.c , but those directories don't exist, is there some way to have those directories automatically created, so that you would only have to typemv foo.c ~/bar/baz/ \nand everything would work out? It seems like you could alias mv to a simple bash script that would check if those directories existed and if not would call mkdir and then mv, but I thought I'd check to see if anyone had a better idea.", "So, if I'm in my home directory and I want to move foo.c to ~/bar/baz/foo.c , but those directories don't exist, is there some way to have those directories automatically created, so that you would only have to typemv foo.c ~/bar/baz/ \nand everything would work out? It seems like you could alias mv to a simple bash script that would check if those directories existed and if not would call mkdir and then mv, but I thought I'd check to see if anyone had a better idea.", "So, if I'm in my home directory and I want to move foo.c to ~/bar/baz/foo.c , but those directories don't exist, is there some way to have those directories automatically created, so that you would only have to typemv foo.c ~/bar/baz/ \nand everything would work out? It seems like you could alias mv to a simple bash script that would check if those directories existed and if not would call mkdir and then mv, but I thought I'd check to see if anyone had a better idea.", "So, if I'm in my home directory and I want to move foo.c to ~/bar/baz/foo.c , but those directories don't exist, is there some way to have those directories automatically created, so that you would only have to typemv foo.c ~/bar/baz/ \nand everything would work out? It seems like you could alias mv to a simple bash script that would check if those directories existed and if not would call mkdir and then mv, but I thought I'd check to see if anyone had a better idea.", "I'm trying to replace special characters with underscores (_) in the filenames of a directory and its subdirectories.I have a folder named \"folder1\" that contains the following files:-rw-r--r--  1 macair  staff    0 Apr 13 16:19 #ababa.txt\n-rw-r--r--  1 macair  staff    0 Apr 13 12:51 @babba.txt\ndrwxr-xr-x  3 macair  staff   96 Apr 24 15:55 Folder2\n-rwxr-xr-x  1 macair  staff  379 Apr 25 11:17 myScript\n-rw-r--r--  1 macair  staff    0 Apr 13 16:19 test1.txt\nand inside \"folder2\", I have the following file:-rw-r--r--  1 macair  staff  0 Apr 24 15:55 #cdcda.txt\nI tried running a script to change the filenames, but the changes are only being reflected in \"folder1\" and not in \"folder2\".Here's the script I used:#!/bin/bash\n\n#find . -type f -exec  grep -i \"[^0-9a-z/.\\/-\\_]\" {} \\;\n\nfor FILE in $(find . -type f -exec basename {} \\; | grep -i \"[^0-9a-z\\.\\/_\\-]\")\ndo\n   echo $FILE\n   mv \"$FILE\" \"${FILE/[!0-9a-zA-Z.-]/_}\"\n   \ndone\n\necho Done!!\nbut I received the following error:\nmv: rename #cdcda.txt to _cdcda.txt: No such file or directory\nAs a beginner in Linux, I would appreciate any help or suggestions to improve the code above.", "How I can select all files in a directory and move them to another folder?i have such directory: folder1/folder2/ [many different files here]mv folder1 file3 - in this case only one file3 is moving in folder1But i want to select all files in folder 2.I try to print:\n/..\n./*\n-whis -ls\n-other ways whis *\n", "I want a script that is able to read the content of a text file which contains folder names and moves the folders from their directory to a specific folder. Here is my script:     #!/bin/bash\n     for i in $(cat /folder/collected/folders.txt)\n      do\n       mv /fromfilelocation/$i /folder/Collected/\n      done\nThis script is partly working as it copies only the last folder in the text file, as for the other folders it gives the error \"not possible: data or directory not found\" But the folder is there and according to the error the folder directory is correctly displayed.What should I do in order to make it work correctly ??", "I have a bunch of files with this naming convention:file01_2018-10-05_123456.pdf\nfile01_2018-10-06_443352.pdf\nfile02_2019-09-20_222222.pdf\nfile02_2019-01-27_246821.pdf\nfile03_2017-11-22_654321.pdf\nfile03_2017-04-14_987654.pdf\nI have a script that finds the most recent of each file number (file01-file03) and renames it to T3031, T3032, T3033, cuts off everything after the first 6 chars and appends the file's last-modified date. They end up looking like this (which is exactly what I want):T3031-2018Oct06.pdf\nT3032-2019Sep20.pdf\nT3033-2017Nov22.pdf\nIt's just that the script seems long and ugly to me (there are 17 loops for file01-file17). I'm hoping someone has a more elegant solution.Here's part of what I have:for F in $(ls -t | grep file01 | head -1)\ndo\n    RUNDATE=\"$(date -r $F +%Y%b%d)\"\n    a=\"$(echo $F | head -c6)\"\n    b=\"$(echo \"$a\" | sed 's/file01/T3031/')\"\n    mv \"$F\" \"${b}-${RUNDATE}.pdf\" 2> /dev/null\ndone\n\nfor F in $(ls -t | grep file02 | head -1)\ndo\n    RUNDATE=\"$(date -r $F +%Y%b%d)\"\n    a=\"$(echo $F | head -c6)\"\n    b=\"$(echo \"$a\" | sed 's/file02/T3032/')\"\n    mv \"$F\" \"${b}-${RUNDATE}.pdf\" 2> /dev/null\ndone\n\nfor F in $(ls -t | grep file03 | head -1)\ndo\n    RUNDATE=\"$(date -r $F +%Y%b%d)\"\n    a=\"$(echo $F | head -c6)\"\n    b=\"$(echo \"$a\" | sed 's/file03/T3033/')\"\n    mv \"$F\" \"${b}-${RUNDATE}.pdf\" 2> /dev/null\ndone\n", "I am wondering - how can I move all the files in a directory except those files in a specific directory (as 'mv' does not have a '--exclude' option)?", "I am wondering - how can I move all the files in a directory except those files in a specific directory (as 'mv' does not have a '--exclude' option)?", "I am wondering - how can I move all the files in a directory except those files in a specific directory (as 'mv' does not have a '--exclude' option)?", "I am wondering - how can I move all the files in a directory except those files in a specific directory (as 'mv' does not have a '--exclude' option)?", "I am wondering - how can I move all the files in a directory except those files in a specific directory (as 'mv' does not have a '--exclude' option)?", "I am wondering - how can I move all the files in a directory except those files in a specific directory (as 'mv' does not have a '--exclude' option)?", "I am wondering - how can I move all the files in a directory except those files in a specific directory (as 'mv' does not have a '--exclude' option)?", "I am wondering - how can I move all the files in a directory except those files in a specific directory (as 'mv' does not have a '--exclude' option)?", "I am wondering - how can I move all the files in a directory except those files in a specific directory (as 'mv' does not have a '--exclude' option)?", "I am wondering - how can I move all the files in a directory except those files in a specific directory (as 'mv' does not have a '--exclude' option)?", "I am wondering - how can I move all the files in a directory except those files in a specific directory (as 'mv' does not have a '--exclude' option)?", "I want to rename a few files in a folder with one command rather than rename them one by one.I have a folder named /u0x/XMLs where there are around 500 folders. Each of these folders has a file named PROCESSED_ADI.XML. I want to rename all these files to ADI.XML.I tried to use find and -exec mv together:XMLs]$ find . -name \"*.XML\" -exec mv {} ADI.XML \\;\nAfter the command was executed all the files have been deleted from the folders or moved from there, which I am not sure. Could someone shed some light on what went wrong and is there any way the files could be retrieved?", "ls -1 | sort -V > txt_list\nandcat txt_list\ngivesASOFJ.txt\nBJWIF.txt\nCWORI.txt\n...\nI want to mkdir with suffix in ascending order like folder_1, folder_2, folder_3and mv ASOFJ.txt folder_1 , mv BJWIF.txt folder_2, mv CWORI.txt folder_3I have triednum=0 ; while read p ; do ( num=$(expr $num + 1) && mkdir \"folder_\"$num && mv $p \"folder_\"$num ) ; done < txt_list\nBut it didn't work.Do you have any idea on a one-liner that executes the above?Thanks.", "How to move content of a folder to its subfolder.\nWhen I run this:mv xyz/* xyz/archive\nI get this notice:\nmv: cannot move 'xyz/archive' to a subdirectory of itself,\n'xyz/archive/archive'\nIs is possible to exclude archive folder from xyz/* selection ?"], "chosen": ["\nThere are different ways to solve your problem\n\nIf you just want to move those specific files, run these commands:\ncd /home/sun/\nmv sdir1/mp4/file.mp4 sdir1/\nmv sdir2/mp4/file.mp4 sdir2/\n\nIf you want to move all mp4 files on those directories (sdir1 and sdir2), run these commands:\ncd /home/sun/\nmv sdir1/mp4/*.mp4 sdir1/\nmv sdir2/mp4/*.mp4 sdir2/\n\n\nEdit:\n\nMake a script that iterates all the directories:\n\nCreate a script and name it and edit it with your favorite editor (nano, vim, gedit, ...):\ngedit folderIterator.sh\n\nThe script file content is:\n#/bin/bash\n\n# Go to the desired directory\ncd /home/sun/\n\n# Do an action over all the subdirectories in the folder\nfor dir in /home/sun/*/\ndo\n    dir=${dir%*/}\n    mv \"$dir\"/mp4/*.mp4 \"$dir\"/\n\n    # If you want to remove the subdirectory after moving the files, uncomment the following line\n    # rm -rf \"$dir\"\ndone\n\nSave the file and give it execute permissions:\nchmod +x folderIterator.sh\n\nAnd execute it:\n./folderIterator.sh\n\n", "\nYou can do this:\n# move all .mp4 files from sdir1/mp4 to sdir1 directory\nuser@host:~/home/sun$ mv sdir1/mp4/*.mp4 sdir/\n\n# move all .mp4 files from collection/sdir2/mp4 to collection/sdir2 directory\nuser@host:~/home/sun$ mv collection/sdir2/mp4/*.mp4 collection/sdir2/\n\n# move only 1 file\nuser@host:~/home/sun$ mv sdir1/mp4/file.mp4 sdir/\nuser@host:~/home/sun$ mv collection/sdir2/mp4/file.mp4 collection/sdir2/\n\n", "\nI suggest you use find and something like\ncd /home/sun/sdir1/mp4/\nfind . -name \"*\" -exec mv {} /home/sun/sdir1/ \\;\ncd /home/sun/collection/sdir2/mp4/\nfind . -name \"*\" -exec mv {} /home/sun/collection/sdir2/ \\;\n\nAlternatively, you could use tar and something like\ncd /home/sun/sdir1/mp4/\ntar cfp - * | (cd ../ ; tar xvvf -)\n# Make sure everything looks good\nrm -rf mp4\ncd /home/sun/collection/sdir2/mp4/\ntar cfp - * | (cd ../ ; tar xvvf -)\n# Make sure everything looks good\nrm -rf mp4\n\n", "\nYou could use bash random generator that generates an int between 0 and 32767 to choose if a file must be put in set1 or set2.  That would do:\nfor file in ./*; do\n  val=$RANDOM\n  if test $val -gt 3276; then\n    mv \"$file\" ../set1\n  else\n    mv \"$file\" ../set2\n  fi\ndone\n\n", "\nUse a combination of shuf and xargs (it's a good idea to look at their documentation with man):\nshuf -n 10 -e * | xargs -i mv {} path-to-new-folder\n\nThe command above selects 10 random files of the current folder (the * part) and then move them to the new folder.\nUpdate\nAlthough longer, one might find this version even simpler to understand:\nls | shuf -n 10 | xargs -i mv {} path-to-new-folder\n\nshuf just generates a random permutation of the standard input, limiting the results to 10 (like using head, but probably faster).\n", "\nYou can shuffle the file list using shuf or sort -R.\nBut you still need to take a subset, which you\ncan do with head/tail.\n", "\nThe question is pretty old, but for the record this works on OSX. \nYou have to install gshuf with brew install coreutils, then use:\ntenpercent=$((`ls | wc -l` * 10/100))\n\nls | gshuf -n $tenpercent | xargs -I {} mv {} destination/path/\n\n", "\nYou can also do this with Python. I find this easier.\nHere is a python script I use to move a random percent of images that also gets associated label datasets typically required for CV image datasets. Note this moves the files because I do not want my test training dataset in my training dataset.\nI use the below for Yolo training sets as labels and images are in the same directory and the labels are txt files.\nimport numpy as np\nimport os\nimport random\n\n#set directories\ndirectory = str('/MauiData/maui_complete_sf_train')\ntarget_directory = str('/MauiData/maui_complete_sf_test')\ndata_set_percent_size = float(0.07)\n\n#print(os.listdir(directory))\n\n# list all files in dir that are an image\nfiles = [f for f in os.listdir(directory) if f.endswith('.jpg')]\n\n#print(files)\n\n# select a percent of the files randomly \nrandom_files = random.sample(files, int(len(files)*data_set_percent_size))\n#random_files = np.random.choice(files, int(len(files)*data_set_percent_size))\n\n#print(random_files)\n\n# move the randomly selected images by renaming directory \n\nfor random_file_name in random_files:      \n    #print(directory+'/'+random_file_name)\n    #print(target_directory+'/'+random_file_name)\n    os.rename(directory+'/'+random_file_name, target_directory+'/'+random_file_name)\n    continue\n\n# move the relevant labels for the randomly selected images\n\nfor image_labels in random_files:\n    # strip extension and add .txt to find corellating label file then rename directory. \n    os.rename(directory+'/'+(os.path.splitext(image_labels)[0]+'.txt'), target_directory+'/'+(os.path.splitext(image_labels)[0]+'.txt'))\n\n    continue\n\n", "\nAlternative version with find to avoid problems with folders.\nIt copies 31415 randomly chosen files into /home/user/dir/\nfind . -maxdepth 1 -type f | sort -R | head -31415 | xargs cp -t /home/user/dir/\n\n", "\nTypically, we do this with a python script or a Java program. Either of these can use a proper RNG to make the random decisions, and then invoke the necessary calls to move files around.\n", "\nmkdir -p `dirname /destination/moved_file_name.txt`  \nmv /full/path/the/file.txt  /destination/moved_file_name.txt\n\n", "\nHow about this one-liner (in bash):\nmkdir --parents ./some/path/; mv yourfile.txt $_\n\nBreaking that down:\nmkdir --parents ./some/path\n# if it doesn't work; try\nmkdir -p ./some/path\n\ncreates the directory (including all intermediate directories), after which:\nmv yourfile.txt $_\n\nmoves the file to that directory ($_ expands to the last argument passed to the previous shell command, ie: the newly created directory).\nI am not sure how far this will work in other shells, but it might give you some ideas about what to look for.\nHere is an example using this technique:\n$ > ls\n$ > touch yourfile.txt\n$ > ls\nyourfile.txt\n$ > mkdir --parents ./some/path/; mv yourfile.txt $_\n$ > ls -F\nsome/\n$ > ls some/path/\nyourfile.txt\n\n", "\nSave as a script named mv.sh\n#!/bin/bash\n# mv.sh\ndir=\"$2\" # Include a / at the end to indicate directory (not filename)\ntmp=\"$2\"; tmp=\"${tmp: -1}\"\n[ \"$tmp\" != \"/\" ] && dir=\"$(dirname \"$2\")\"\n[ -a \"$dir\" ] ||\nmkdir -p \"$dir\" &&\nmv \"$@\"\n\nOr put at the end of your ~/.bashrc file as a function that replaces the default mv on every new terminal. Using a function allows bash keep it memory, instead of having to read a script file every time.\nfunction mvp ()\n{\n    dir=\"$2\" # Include a / at the end to indicate directory (not filename)\n    tmp=\"$2\"; tmp=\"${tmp: -1}\"\n    [ \"$tmp\" != \"/\" ] && dir=\"$(dirname \"$2\")\"\n    [ -a \"$dir\" ] ||\n    mkdir -p \"$dir\" &&\n    mv \"$@\"\n}\n\nExample usage:\nmv.sh file ~/Download/some/new/path/ # <-End with slash\n\nThese based on the submission of Chris Lutz.\n", "\nYou can use mkdir:\nmkdir -p ~/bar/baz/ && \\\nmv foo.c ~/bar/baz/\n\nA simple script to do it automatically (untested):\n#!/bin/sh\n\n# Grab the last argument (argument number $#)    \neval LAST_ARG=\\$$#\n\n# Strip the filename (if it exists) from the destination, getting the directory\nDIR_NAME=`echo $2 | sed -e 's_/[^/]*$__'`\n\n# Move to the directory, making the directory if necessary\nmkdir -p \"$DIR_NAME\" || exit\nmv \"$@\"\n\n", "\nIt sounds like the answer is no :). I don't really want to create an alias or func just to do this, often because it's one-off and I'm already in the middle of typing the mv command, but I found something that works well for that:\nmv *.sh shell_files/also_with_subdir/ || mkdir -p $_\n\nIf mv fails (dir does not exist), it will make the directory (which is the last argument to the previous command, so $_ has it). So just run this command, then up to re-run it, and this time mv should succeed.\n", "\nThe simplest way to do it is:\nmkdir -p [path/to/directory] && mv [filename] $_\n\nThe nice part about this is it will only move the file if mkdir succeeds.\n\nExplanation:\nLet's suppose I downloaded some PDF files located in my directory (~/download ). I want to move all of them into a directory that doesn't exist (let's say my_PDF).\nI'll type the following command (making sure my current working directory is ~/download):\nmkdir my_PDF && mv *.pdf $_\n\nYou can add -p option to mkdir if you want to create subdirectories just like this: (supposed I want to create a subdirectory named python):\nmkdir -p my_PDF/python && mv *.pdf $_\n\n", "\nMaking use of the tricks in \"Getting the last argument passed to a shell script\" we can make a simple shell function that should work no matter how many files you want to move:\n# Bash only\nmvdir() { mkdir -p \"${@: -1}\" && mv \"$@\"; }\n\n# Other shells may need to search for the last argument\nmvdir() { for last; do true; done; mkdir -p \"$last\" && mv \"$@\"; }\n\nUse the command like this:\nmvdir foo.c foo.h ~/some/new/folder/\n\n", "\nrsync command can do the trick only if the last directory in the destination path doesn't exist, e.g. for the destination path of ~/bar/baz/ if bar exists but baz doesn't, then the following command can be used:\nrsync -av --remove-source-files foo.c ~/bar/baz/\n-a, --archive               archive mode; equals -rlptgoD (no -H,-A,-X)\n-v, --verbose               increase verbosity\n--remove-source-files   sender removes synchronized files (non-dir)\n\nIn this case baz directory will be created if it doesn't exist. But if both bar and baz don't exist rsync will fail:\nsending incremental file list\nrsync: mkdir \"/root/bar/baz\" failed: No such file or directory (2)\nrsync error: error in file IO (code 11) at main.c(657) [Receiver=3.1.2]\n\nSo basically it should be safe to use rsync -av --remove-source-files as an alias for mv.\n", "\nThe following shell script, perhaps?\n#!/bin/sh\nif [[ -e $1 ]]\nthen\n  if [[ ! -d $2 ]]\n  then\n    mkdir --parents $2\n  fi\nfi\nmv $1 $2\n\nThat's the basic part. You might want to add in a bit to check for arguments, and you may want the behavior to change if the destination exists, or the source directory exists, or doesn't exist (i.e. don't overwrite something that doesn't exist).\n", "\nBased on a comment in another answer, here's my shell function.\n# mvp = move + create parents\nfunction mvp () {\n    source=\"$1\"\n    target=\"$2\"\n    target_dir=\"$(dirname \"$target\")\"\n    mkdir --parents $target_dir; mv $source $target\n}\n\nInclude this in .bashrc or similar so you can use it everywhere.\n", "\ni accomplished this with the install command on linux:\nroot@logstash:# myfile=bash_history.log.2021-02-04.gz ; install -v -p -D $myfile /tmp/a/b/$myfile\n\nbash_history.log.2021-02-04.gz -> /tmp/a/b/bash_history.log.2021-02-04.gz\n\nthe only downside being the file permissions are changed:\nroot@logstash:# ls -lh /tmp/a/b/\n\n-rwxr-xr-x 1 root root 914 Fev  4 09:11 bash_history.log.2021-02-04.gz\n\nif you dont mind resetting the permission, you can use:\n-g, --group=GROUP   set group ownership, instead of process' current group\n-m, --mode=MODE     set permission mode (as in chmod), instead of rwxr-xr-x\n-o, --owner=OWNER   set ownership (super-user only)\n\n", "\nCode:\nif [[ -e $1 && ! -e $2 ]]; then\n   mkdir --parents --verbose -- \"$(dirname -- \"$2\")\"\nfi\nmv --verbose -- \"$1\" \"$2\"\n\nExample:\narguments: \"d1\" \"d2/sub\"\nmkdir: created directory 'd2'\nrenamed 'd1' -> 'd2/sub'\n\n", "\nSillier, but working way:\nmkdir -p $2\nrmdir $2\nmv $1 $2\n\nMake the directory with mkdir -p including a temporary directory that is shares the destination file name, then remove that file name directory with a simple rmdir, then move your file to its new destination.\nI think answer using dirname is probably the best though.\n", "\nThis will move foo.c to the new directory baz with the parent directory bar.\nmv foo.c `mkdir -p ~/bar/baz/ && echo $_`\n\nThe -p option to mkdir will create intermediate directories as required.\nWithout -p all directories in the path prefix must already exist.\nEverything inside backticks `` is executed and the output is returned in-line as part of your command.\nSince mkdir doesn't return anything, only the output of echo $_ will be added to the command.\n$_ references the last argument to the previously executed command.\nIn this case, it will return the path to your new directory (~/bar/baz/) passed to the mkdir command.\n\nI unzipped an archive without giving a destination and wanted to move all the files except `demo-app.zip` from my current directory to a new directory called `demo-app`. The following line does the trick:\nmv `ls -A | grep -v demo-app.zip` `mkdir -p demo-app && echo $_`\n\nls -A returns all file names including hidden files (except for the implicit . and ..).\nThe pipe symbol | is used to pipe the output of the ls command to grep (a command-line, plain-text search utility).\nThe -v flag directs grep to find and return all file names excluding demo-app.zip.\nThat list of files is added to our command-line as source arguments to the move command mv. The target argument is the path to the new directory passed to mkdir referenced using $_ and output using echo.\n", "\nI frequently stumble upon this issue while bulk moving files to new subdirectories. Ideally, I want to do this:\nmv * newdir/  \n\nMost of the answers in this thread propose to mkdir and then mv, but this results in:\nmkdir newdir && mv * newdir \nmv: cannot move 'newdir/' to a subdirectory of itself\n\nThe problem I face is slightly different in that I want to blanket move everything, and, if I create the new directory before moving then it also tries to move the new directory to itself. So, I work around this by using the parent directory:\nmkdir ../newdir && mv * ../newdir && mv ../newdir .\n\nCaveats: Does not work in the root folder (/).\n", "\n((cd src-path && tar --remove-files -cf - files-to-move) | ( cd dst-path && tar -xf -))\n\n", "\nThere's a lot of conflicting solutions around for this, here's what worked for us:\n## ss_mv ##\nfunction ss_mv {\n    mkdir -p $(dirname \"$2\") && mv -f \"$@\"\n}\n\nThis assumes commands in the following syntax:\nss_mv /var/www/myfile /var/www/newdir/myfile\n\nIn this way the directory path /var/www/newdir is extracted from the 2nd part of the command, and that new directory is then created (it's critical that you use the dirname tag to avoid myfile being added to the new directory being created).\nThen we go ahead and mv on the entire string again by using the \"$@\" tag.\n", "\nI wrote a script that is a drop-in replacement for mv\nthat should handle all the edge cases,\nincluding the cases where the destination is a file\nbut in a non-existent directory\nor a non-existent directory itself,\nand the case that there are options to be passed to mv,\nand is compliant with POSIX sh.\n#!/bin/sh\n# USAGE:\n# mkdmv [-if] source_file target_file\n# mkdmv [-if] source_file... target_dir\nmkdmv() {\n    n=0 endofargs=\n    for arg; do\n        if [ -n \"$endofargs\" ] || [ \"${arg#-}\" = \"$arg\" ]; then\n            # dest will be set to last non-option arg\n            n=$((n+1)) dest=$arg\n        elif [ \"$arg\" = '--' ]; then\n            endofargs=1\n        fi\n    done\n    # dest is a dir to be created\n    # if there are multiple src files\n    # or if target ends with \"/\"\n    if [ \"$n\" -gt 2 ] || [ \"${dest%/}\" != \"$dest\" ]; then\n        # append `.` to prevent `dirname` from returning parent dir\n        dest=\"$dest/.\"\n    fi\n    mkdir -p -- \"$(dirname -- \"$dest\")\" &&\n        mv \"$@\"\n}\n\n", "\nMy one string solution:\ntest -d \"/home/newdir/\" || mkdir -p \"/home/newdir/\" && mv /home/test.txt /home/newdir/\n\n", "\nYou can even use brace extensions:\nmkdir -p directory{1..3}/subdirectory{1..3}/subsubdirectory{1..2}\n\n\nwhich creates 3 directories (directory1, directory2, directory3),\n\nand in each one of them two subdirectories (subdirectory1, subdirectory2),\n\nand in each of them two subsubdirectories (subsubdirectory1 and subsubdirectory2).\n\n\n\n\n\nYou have to use bash 3.0 or newer.\n", "\nYou did -exec basename {} presumably to avoid replacing the directory separator /, but thereby you are losing directory information, so don't. When leaving the path intact, we just have to include the / in the class of normal characters:\n\u2026find . -type f | \u2026\n   mv \"$FILE\" \"${FILE/[!0-9a-zA-Z.\\/-]/_}\"\n\n", "\nIf you really only want to move files and not folders within folder2 do this:\nfind /PATH/TO/FOLDER1/FOLDER2 -type f -exec mv {} /PATH/TO/DESTINATION/FOLDER/ \\;\n\nThis will find all files in folder2 and move them to your new destination\n/E: Other folders within folder2 will not be moved\n", "\nYou can use this:\n#!/bin/bash\nfor sample in `awk '{print $1}' All_bins.txt`\n    do mv \"$sample\" All_Good_Bins\n    done\n\n", "\nFirst of all, don't parse the output of ls\nA shell loop:\nfor file in file*.pdf\ndo\n    mtime=$(date -r \"$file\" '+%Y%b%d')\n    num=${file%%_*}             # remove the first \"_\" and all following\n    num=${num#file}             # remove the \"file\" prefix\n    num=$(( 3030 + 10#$num ))   # force base-10 interpretation of invalid octal \"08\" and \"09\"\n\n    mv -v \"$file\" \"T${num}-${mtime}.pdf\"\ndone\n\nOr using the rename command (remove the -n option if it looks right)\nrename -MPOSIX=strftime -n '\n    s{file(\\d+).*}{\n        sprintf \"T%d-%s.pdf\", 3030 + $1, strftime(\"%Y%b%d\", localtime((stat)[9]))\n    }e\n' file*pdf\n\n", "\nSince find does have an exclude option, use find + xargs + mv:\nfind /source/directory -name ignore-directory-name -prune -print0 | xargs -0 mv --target-directory=/target/directory\n\nNote that this is almost copied from the find man page (I think using mv --target-directory is better than cpio).\n", "\nLets's assume the dir structure is like,\n|parent\n    |--child1\n    |--child2\n    |--grandChild1\n    |--grandChild2\n    |--grandChild3\n    |--grandChild4\n    |--grandChild5\n    |--grandChild6\n\nAnd we need to move files so that it would appear like,\n|parent\n    |--child1\n    |   |--grandChild1\n    |   |--grandChild2\n    |   |--grandChild3\n    |   |--grandChild4\n    |   |--grandChild5\n    |   |--grandChild6\n    |--child2\n\nIn this case, you need to exclude two directories child1 and child2, and move rest of the directories in to child1 directory.\nuse,\nmv !(child1|child2) child1\n\nThis will move all of rest of the directories into child1 directory.\n", "\nFirst get the names of files and folders and exclude whichever you want:\nls --ignore=file1 --ignore==folder1 --ignore==regular-expression1 ...\n\nThen pass filtered names to mv as the first parameter and the second parameter will be the destination:\nmv $(ls --ignore=file1 --ignore==folder1 --ignore==regular-expression1 ...) destination/\n\n", "\nThis isn't exactly what you asked for, but it might do the job:\nmv the-folder-you-want-to-exclude somewhere-outside-of-the-main-tree\nmv the-tree where-you-want-it\nmv the-excluded-folder original-location\n\n(Essentially, move the excluded folder out of the larger tree to be moved.)\nSo, if I have a/ and I want to exclude a/b/c/*:\nmv a/b/c ../c\nmv a final_destination\nmkdir -p a/b\nmv ../c a/b/c\n\nOr something like that. Otherwise, you might be able to get find to help you.\n", "\nrename your directory to make it hidden so the wildcard does not see it:\nmv specific_dir .specific_dir \nmv * ../other_dir\n\n", "\nThis will move all files at or below the current directory not in the ./exclude/ directory to /wherever...\nfind -E . -not -type d -and -not -regex '\\./exclude/.*' -exec echo mv {} /wherever \\;\n\n", "\nls | grep -v exclude-dir | xargs -t -I '{}' mv {} exclude-dir\n\n", "\n#!/bin/bash\n\ntouch apple  banana  carrot  dog  cherry\n\nmkdir fruit\n\nF=\"apple  banana  carrot  dog cherry\"\n\nmv ${F/dog/} fruit\n\n# this removes 'dog' from the list F, so it remains in the \n     current directory and not moved to 'fruit'\n", "\n\nInspired by @user13747357 's answer.\n\nFirst you can ls the file and filter them by:\nls | egrep -v '(dir_name|file_name.ext)'\n\nThen you can run the following command to move the files except the specific ones:\nmv $(ls | egrep -v '(dir_name|file_name.ext)') target_dir\n\n* Note that I tested this inside a specific directory. Cross-directory operation should be more carefully executed :)\n", "\nsuppose you directory is\n.\n\u251c\u2500\u2500 dir1\n\u2502    \u2514\u2500\u2500 a.txt\n\u251c\u2500\u2500 dir2\n\u2502    \u251c\u2500\u2500 b.txt\n\u2502    \u2514\u2500\u2500 hello.c\n\u251c\u2500\u2500 file1.txt\n\u251c\u2500\u2500 file2.txt\n\u2514\u2500\u2500 file3.txt\n\nand you gonna put file1 file2 file3 into dir2.\nyou can use\nmv $(ls -p | grep -v /)  /dir2 to finish it, because\nls -p | grep -v / will print all files except directory in cwd.\n", "\nFor example, if I want to move all files/directories - except a specified file or directory - inside \"var/www/html\" to a sub-folder named \"my_sub_domain\", then I use \"mv\" with the command \"!(what_to_exclude)\":\n$ cd /var/www/html\n$ mv !(my_sub_domain) my_sub_domain\nTo exclude more I use \"|\" to seperate file/directory names:\n$ mv !(my_sub_domain|test1.html) my_sub_domain\n", "\nFirst of all, do not use a wildcard. Even with -execdir, you're creating a circumstance where all .XML files in a directory will be overwritten with the last match in that directory.\nfind . -type f -name 'PROCESSED_ADI.XML' -exec sh -c 'for i do echo mv \"${i}\" \"$(dirname \"$i\")/ADI.XML\"; done' _ {} +\n\nRun this, as a dry run. If it looks ok, remove echo.\n", "\n#!/bin/bash\n\ncounter=1\nwhile read line\ndo\n    mkdir \"folder_${counter}\" && mv $line \"folder_${counter}\"\n    ((counter++))\ndone <<< $(ls -1 | sort -V)\n\n", "\nYes, it is possible to exclude archive from the selection.\n\nEnable the extended globbing option\n\nshopt -s extglob\n\n\nRun the following command that will move everything but archive\n\nmv !(archive) archive\n\nIt will now move everything from xyz to archive\nPS: I did run the mv command when I was inside the xyz folder.\n"], "rejected": ["\nThe command to move a file (or directory) up one level is:\nmv /home/sun/sdir1/mp4/file.mp4 ..\n\nWildcards can be used to select more files & directories, you can also provide more than one directory at a time.\nmv /home/sun/sdir1/mp4/*.mp4 /home/sun/collection/sdir2/mp4/*.mp4 ..\n\n", "\nThe command to move a file (or directory) up one level is:\nmv /home/sun/sdir1/mp4/file.mp4 ..\n\nWildcards can be used to select more files & directories, you can also provide more than one directory at a time.\nmv /home/sun/sdir1/mp4/*.mp4 /home/sun/collection/sdir2/mp4/*.mp4 ..\n\n", "\nThe command to move a file (or directory) up one level is:\nmv /home/sun/sdir1/mp4/file.mp4 ..\n\nWildcards can be used to select more files & directories, you can also provide more than one directory at a time.\nmv /home/sun/sdir1/mp4/*.mp4 /home/sun/collection/sdir2/mp4/*.mp4 ..\n\n", "\nWith the zsh shell:\nmv -- *(oe['REPLY=$RANDOM'][1,10]) /path/to/destination/\n\nWhere we use the oe glob qualifier to order the glob expansion based on the evaluation of the given code (which here returns a random value), and select the first 10.\nOn recent GNU systems, and with a shell with support for ksh-style process substitution (ksh93, zsh, bash) you can do:\nxargs -r0a <(ls -U --zero | shuf -zn10) mv -t /path/to/destination --\n\nls -U --zero can be replaced with printf '%s\\0' * is GNU ls is too old to support --zero. With the difference that if there's no non-hidden file in the current directory, you'll get an error about the failure to move a file called *.\nxargs -r0a <(shuf -zen10 -- *) mv -t /path/to/destination --\n\nCould also be used as a more correct/reliable/efficient variation on @boechat107's answer, though with the added caveat that you may run into a Argument list too long error upon attempting to  execute shuf if there's a large number of non-hidden files in the current working directory. The printf-based approach above should be fine in that regard as printf is generally built in the shells and so not affected by that limitation of the execve() system call.\nTo move 10% as opposed to 10, with zsh:\nfiles=(*(Noe['REPLY=$RANDOM']))\nmv -- $files[1,$#files/10] /path/to/destination/\n\n(10% rounded down).\n", "\nWith the zsh shell:\nmv -- *(oe['REPLY=$RANDOM'][1,10]) /path/to/destination/\n\nWhere we use the oe glob qualifier to order the glob expansion based on the evaluation of the given code (which here returns a random value), and select the first 10.\nOn recent GNU systems, and with a shell with support for ksh-style process substitution (ksh93, zsh, bash) you can do:\nxargs -r0a <(ls -U --zero | shuf -zn10) mv -t /path/to/destination --\n\nls -U --zero can be replaced with printf '%s\\0' * is GNU ls is too old to support --zero. With the difference that if there's no non-hidden file in the current directory, you'll get an error about the failure to move a file called *.\nxargs -r0a <(shuf -zen10 -- *) mv -t /path/to/destination --\n\nCould also be used as a more correct/reliable/efficient variation on @boechat107's answer, though with the added caveat that you may run into a Argument list too long error upon attempting to  execute shuf if there's a large number of non-hidden files in the current working directory. The printf-based approach above should be fine in that regard as printf is generally built in the shells and so not affected by that limitation of the execve() system call.\nTo move 10% as opposed to 10, with zsh:\nfiles=(*(Noe['REPLY=$RANDOM']))\nmv -- $files[1,$#files/10] /path/to/destination/\n\n(10% rounded down).\n", "\nWith the zsh shell:\nmv -- *(oe['REPLY=$RANDOM'][1,10]) /path/to/destination/\n\nWhere we use the oe glob qualifier to order the glob expansion based on the evaluation of the given code (which here returns a random value), and select the first 10.\nOn recent GNU systems, and with a shell with support for ksh-style process substitution (ksh93, zsh, bash) you can do:\nxargs -r0a <(ls -U --zero | shuf -zn10) mv -t /path/to/destination --\n\nls -U --zero can be replaced with printf '%s\\0' * is GNU ls is too old to support --zero. With the difference that if there's no non-hidden file in the current directory, you'll get an error about the failure to move a file called *.\nxargs -r0a <(shuf -zen10 -- *) mv -t /path/to/destination --\n\nCould also be used as a more correct/reliable/efficient variation on @boechat107's answer, though with the added caveat that you may run into a Argument list too long error upon attempting to  execute shuf if there's a large number of non-hidden files in the current working directory. The printf-based approach above should be fine in that regard as printf is generally built in the shells and so not affected by that limitation of the execve() system call.\nTo move 10% as opposed to 10, with zsh:\nfiles=(*(Noe['REPLY=$RANDOM']))\nmv -- $files[1,$#files/10] /path/to/destination/\n\n(10% rounded down).\n", "\nWith the zsh shell:\nmv -- *(oe['REPLY=$RANDOM'][1,10]) /path/to/destination/\n\nWhere we use the oe glob qualifier to order the glob expansion based on the evaluation of the given code (which here returns a random value), and select the first 10.\nOn recent GNU systems, and with a shell with support for ksh-style process substitution (ksh93, zsh, bash) you can do:\nxargs -r0a <(ls -U --zero | shuf -zn10) mv -t /path/to/destination --\n\nls -U --zero can be replaced with printf '%s\\0' * is GNU ls is too old to support --zero. With the difference that if there's no non-hidden file in the current directory, you'll get an error about the failure to move a file called *.\nxargs -r0a <(shuf -zen10 -- *) mv -t /path/to/destination --\n\nCould also be used as a more correct/reliable/efficient variation on @boechat107's answer, though with the added caveat that you may run into a Argument list too long error upon attempting to  execute shuf if there's a large number of non-hidden files in the current working directory. The printf-based approach above should be fine in that regard as printf is generally built in the shells and so not affected by that limitation of the execve() system call.\nTo move 10% as opposed to 10, with zsh:\nfiles=(*(Noe['REPLY=$RANDOM']))\nmv -- $files[1,$#files/10] /path/to/destination/\n\n(10% rounded down).\n", "\nWith the zsh shell:\nmv -- *(oe['REPLY=$RANDOM'][1,10]) /path/to/destination/\n\nWhere we use the oe glob qualifier to order the glob expansion based on the evaluation of the given code (which here returns a random value), and select the first 10.\nOn recent GNU systems, and with a shell with support for ksh-style process substitution (ksh93, zsh, bash) you can do:\nxargs -r0a <(ls -U --zero | shuf -zn10) mv -t /path/to/destination --\n\nls -U --zero can be replaced with printf '%s\\0' * is GNU ls is too old to support --zero. With the difference that if there's no non-hidden file in the current directory, you'll get an error about the failure to move a file called *.\nxargs -r0a <(shuf -zen10 -- *) mv -t /path/to/destination --\n\nCould also be used as a more correct/reliable/efficient variation on @boechat107's answer, though with the added caveat that you may run into a Argument list too long error upon attempting to  execute shuf if there's a large number of non-hidden files in the current working directory. The printf-based approach above should be fine in that regard as printf is generally built in the shells and so not affected by that limitation of the execve() system call.\nTo move 10% as opposed to 10, with zsh:\nfiles=(*(Noe['REPLY=$RANDOM']))\nmv -- $files[1,$#files/10] /path/to/destination/\n\n(10% rounded down).\n", "\nWith the zsh shell:\nmv -- *(oe['REPLY=$RANDOM'][1,10]) /path/to/destination/\n\nWhere we use the oe glob qualifier to order the glob expansion based on the evaluation of the given code (which here returns a random value), and select the first 10.\nOn recent GNU systems, and with a shell with support for ksh-style process substitution (ksh93, zsh, bash) you can do:\nxargs -r0a <(ls -U --zero | shuf -zn10) mv -t /path/to/destination --\n\nls -U --zero can be replaced with printf '%s\\0' * is GNU ls is too old to support --zero. With the difference that if there's no non-hidden file in the current directory, you'll get an error about the failure to move a file called *.\nxargs -r0a <(shuf -zen10 -- *) mv -t /path/to/destination --\n\nCould also be used as a more correct/reliable/efficient variation on @boechat107's answer, though with the added caveat that you may run into a Argument list too long error upon attempting to  execute shuf if there's a large number of non-hidden files in the current working directory. The printf-based approach above should be fine in that regard as printf is generally built in the shells and so not affected by that limitation of the execve() system call.\nTo move 10% as opposed to 10, with zsh:\nfiles=(*(Noe['REPLY=$RANDOM']))\nmv -- $files[1,$#files/10] /path/to/destination/\n\n(10% rounded down).\n", "\nWith the zsh shell:\nmv -- *(oe['REPLY=$RANDOM'][1,10]) /path/to/destination/\n\nWhere we use the oe glob qualifier to order the glob expansion based on the evaluation of the given code (which here returns a random value), and select the first 10.\nOn recent GNU systems, and with a shell with support for ksh-style process substitution (ksh93, zsh, bash) you can do:\nxargs -r0a <(ls -U --zero | shuf -zn10) mv -t /path/to/destination --\n\nls -U --zero can be replaced with printf '%s\\0' * is GNU ls is too old to support --zero. With the difference that if there's no non-hidden file in the current directory, you'll get an error about the failure to move a file called *.\nxargs -r0a <(shuf -zen10 -- *) mv -t /path/to/destination --\n\nCould also be used as a more correct/reliable/efficient variation on @boechat107's answer, though with the added caveat that you may run into a Argument list too long error upon attempting to  execute shuf if there's a large number of non-hidden files in the current working directory. The printf-based approach above should be fine in that regard as printf is generally built in the shells and so not affected by that limitation of the execve() system call.\nTo move 10% as opposed to 10, with zsh:\nfiles=(*(Noe['REPLY=$RANDOM']))\nmv -- $files[1,$#files/10] /path/to/destination/\n\n(10% rounded down).\n", "\n$what=/path/to/file;\n$dest=/dest/path;\n\nmkdir -p \"$(dirname \"$dest\")\";\nmv \"$what\" \"$dest\"\n\n", "\n$what=/path/to/file;\n$dest=/dest/path;\n\nmkdir -p \"$(dirname \"$dest\")\";\nmv \"$what\" \"$dest\"\n\n", "\n$what=/path/to/file;\n$dest=/dest/path;\n\nmkdir -p \"$(dirname \"$dest\")\";\nmv \"$what\" \"$dest\"\n\n", "\n$what=/path/to/file;\n$dest=/dest/path;\n\nmkdir -p \"$(dirname \"$dest\")\";\nmv \"$what\" \"$dest\"\n\n", "\n$what=/path/to/file;\n$dest=/dest/path;\n\nmkdir -p \"$(dirname \"$dest\")\";\nmv \"$what\" \"$dest\"\n\n", "\n$what=/path/to/file;\n$dest=/dest/path;\n\nmkdir -p \"$(dirname \"$dest\")\";\nmv \"$what\" \"$dest\"\n\n", "\n$what=/path/to/file;\n$dest=/dest/path;\n\nmkdir -p \"$(dirname \"$dest\")\";\nmv \"$what\" \"$dest\"\n\n", "\n$what=/path/to/file;\n$dest=/dest/path;\n\nmkdir -p \"$(dirname \"$dest\")\";\nmv \"$what\" \"$dest\"\n\n", "\n$what=/path/to/file;\n$dest=/dest/path;\n\nmkdir -p \"$(dirname \"$dest\")\";\nmv \"$what\" \"$dest\"\n\n", "\n$what=/path/to/file;\n$dest=/dest/path;\n\nmkdir -p \"$(dirname \"$dest\")\";\nmv \"$what\" \"$dest\"\n\n", "\n$what=/path/to/file;\n$dest=/dest/path;\n\nmkdir -p \"$(dirname \"$dest\")\";\nmv \"$what\" \"$dest\"\n\n", "\n$what=/path/to/file;\n$dest=/dest/path;\n\nmkdir -p \"$(dirname \"$dest\")\";\nmv \"$what\" \"$dest\"\n\n", "\n$what=/path/to/file;\n$dest=/dest/path;\n\nmkdir -p \"$(dirname \"$dest\")\";\nmv \"$what\" \"$dest\"\n\n", "\n$what=/path/to/file;\n$dest=/dest/path;\n\nmkdir -p \"$(dirname \"$dest\")\";\nmv \"$what\" \"$dest\"\n\n", "\n$what=/path/to/file;\n$dest=/dest/path;\n\nmkdir -p \"$(dirname \"$dest\")\";\nmv \"$what\" \"$dest\"\n\n", "\n$what=/path/to/file;\n$dest=/dest/path;\n\nmkdir -p \"$(dirname \"$dest\")\";\nmv \"$what\" \"$dest\"\n\n", "\n$what=/path/to/file;\n$dest=/dest/path;\n\nmkdir -p \"$(dirname \"$dest\")\";\nmv \"$what\" \"$dest\"\n\n", "\n$what=/path/to/file;\n$dest=/dest/path;\n\nmkdir -p \"$(dirname \"$dest\")\";\nmv \"$what\" \"$dest\"\n\n", "\n$what=/path/to/file;\n$dest=/dest/path;\n\nmkdir -p \"$(dirname \"$dest\")\";\nmv \"$what\" \"$dest\"\n\n", "\n$what=/path/to/file;\n$dest=/dest/path;\n\nmkdir -p \"$(dirname \"$dest\")\";\nmv \"$what\" \"$dest\"\n\n", "\nLinux is known for providing powerful and efficient utilities that enable users to perform common tasks such as renaming files in straightforward ways without the need for Bash scripts.\nWith that being said, below you will find a relevant example:\nfind . -depth -type f -name '*[^0-9a-zA-Z\\.\\/_\\-]*' -exec rename -n 's/[^0-9a-zA-Z\\.\\/_\\-]/_/g' {} +\n\nResult:\nrename(./folder2/#cdcda.txt, ./folder2/_cdcda.txt)\nrename(./@babba.txt, ./_babba.txt)\nrename(./#ababa.txt, ./_ababa.txt)\n\n\nNotes:\n\ndepth specifies that subdirectories will be processed before their parent directories.\ntype f specifies that only files will be searched.\nexec rename specifies that find will execute the rename command on each file that matches the search criteria.\ns/ specifies a substitution operation.\n/_/ is the replacement string that replaces any matched character with an underscore.\ng modifier means global and indicates that all occurrences of the matched characters should be replaced.\n{} is a placeholder that find will replace with the path to each file that matches the search criteria.\n+ instructs find to execute the rename command on as many files as possible at once, rather than one at a time. This can improve the efficiency of the operation by reducing the overhead of invoking the rename command multiple times.\nThe regular expression pattern you provided was matching uppercase letters, so I updated it to exclude them.\n\nWarning:\n\nWhen performing a mass operation such as renaming multiple files, it's a good practice to preview the results before executing the command. You can accomplish this by using the -n (no action) flag after the rename command. This will simulate the renaming operation and display what the resulting file names will be without actually renaming the files.\n\n", "\nThe 'mv' command to move files does support wildcard characters. Simply use mv folder1/folder2/* <destination>.\nThis command will move all files in folder1/folder2 to your specified destination.\n", "\nUse while loop instead\nwhile read i; do\n  mv fromfilelocation/\"$i\" /folder/Collected/\ndone </folder/collected/folders.txt\n\n", "\nThis might work for you (GNU sort and rename):\nls -1 file* |\nsort -t_ -k1,1 -k2,2r file1 |\nsort -ut_ -k1,1 |\nrename -n 'm/^[^_]*(\\d\\d)_(\\d{4})-(\\d{2})-(\\d{2})_\\d+(\\..*)/; \n           my $f = 3030+$1;\n           my @m = (\"XXX\",\"Jan\",\"Feb\",\"Mar\",\"Apr\",\"May\",\"Jun\",\"Jul\",\"Aug\",\"Sep\",\"Oct\",\"Nov\",\"Dec\");\n           $_ = sprintf \"T%d-$2%s$4$5\", $f, $m[$3]'\n\nList out the required files.\nSort the list by file number and reversed date order.\nRemove all but the first of each file number.\nUse rename to format the file names.\nN.B. Once the file formats agree with your requirements, remove the -n option for rename and the files will be renamed.\n", "\nmv * exclude-dir\n\nwas the perfect solution for me\n", "\nmv * exclude-dir\n\nwas the perfect solution for me\n", "\nmv * exclude-dir\n\nwas the perfect solution for me\n", "\nmv * exclude-dir\n\nwas the perfect solution for me\n", "\nmv * exclude-dir\n\nwas the perfect solution for me\n", "\nmv * exclude-dir\n\nwas the perfect solution for me\n", "\nmv * exclude-dir\n\nwas the perfect solution for me\n", "\nmv * exclude-dir\n\nwas the perfect solution for me\n", "\nmv * exclude-dir\n\nwas the perfect solution for me\n", "\nmv * exclude-dir\n\nwas the perfect solution for me\n", "\nmv * exclude-dir\n\nwas the perfect solution for me\n", "\n\nAfter the command was executed all the files have been deleted from the folders or moved from there, which I am not sure\n\nYou're renaming the files but the destination or rather the renamed file has a different location, It is the current location/path where you ran the find command.\nYou can use -execdir if your find supports it.\nfind . -name \"*.XML\" -execdir mv -v {} ADI.XML \\;\n\n\nHere is definition of execdir\n -execdir command {} +\n              Like -exec, but the specified command is run from the subdirectory containing the matched file, which is not normally the directory in which you started  find.   As  with\n              -exec,  the  {} should be quoted if find is being invoked from a shell.  This a much more secure method for invoking commands, as it avoids race conditions during resolu-\n              tion of the paths to the matched files.  As with the -exec action, the `+' form of -execdir will build a command line to process more than one matched file, but any given\n              invocation  of  command  will  only list files that exist in the same subdirectory.  If you use this option, you must ensure that your $PATH environment variable does not\n              reference `.'; otherwise, an attacker can run any commands they like by leaving an appropriately-named file in a directory in which  you  will  run  -execdir.   The  same\n              applies  to  having entries in $PATH which are empty or which are not absolute directory names.  If any invocation with the `+' form returns a non-zero value as exit sta-\n              tus, then find returns a non-zero exit status.  If find encounters an error, this can sometimes cause an immediate exit, so some pending commands may not be run  at  all.\n              The result of the action depends on whether the + or the ; variant is being used; -execdir command {} + always returns true, while -execdir command {} ; returns true only\n              if command returns 0.\n\n\nHere is a bit of demo about what/why did your files got removed deleted.\nLet's create a dummy directories and file anywhere but here we will create them in /tmp\ncd  /tmp\n\n\nLet's create the directories and files.\nmkdir -p u0x/XMLs/folder_{1..10} && touch u0x/XMLs/folder_{1..10}/PROCESSED_ADI.XML\n\n\nNow check what was created inside those directories, using the tree command.\ntree u0x/\n\n\nOutput\nu0x/\n\u2514\u2500\u2500 XMLs\n    \u251c\u2500\u2500 folder_1\n    \u2502\u00a0\u00a0 \u2514\u2500\u2500 PROCESSED_ADI.XML\n    \u251c\u2500\u2500 folder_10\n    \u2502\u00a0\u00a0 \u2514\u2500\u2500 PROCESSED_ADI.XML\n    \u251c\u2500\u2500 folder_2\n    \u2502\u00a0\u00a0 \u2514\u2500\u2500 PROCESSED_ADI.XML\n    \u251c\u2500\u2500 folder_3\n    \u2502\u00a0\u00a0 \u2514\u2500\u2500 PROCESSED_ADI.XML\n    \u251c\u2500\u2500 folder_4\n    \u2502\u00a0\u00a0 \u2514\u2500\u2500 PROCESSED_ADI.XML\n    \u251c\u2500\u2500 folder_5\n    \u2502\u00a0\u00a0 \u2514\u2500\u2500 PROCESSED_ADI.XML\n    \u251c\u2500\u2500 folder_6\n    \u2502\u00a0\u00a0 \u2514\u2500\u2500 PROCESSED_ADI.XML\n    \u251c\u2500\u2500 folder_7\n    \u2502\u00a0\u00a0 \u2514\u2500\u2500 PROCESSED_ADI.XML\n    \u251c\u2500\u2500 folder_8\n    \u2502\u00a0\u00a0 \u2514\u2500\u2500 PROCESSED_ADI.XML\n    \u2514\u2500\u2500 folder_9\n        \u2514\u2500\u2500 PROCESSED_ADI.XML\n\n11 directories, 10 files\n\n\nNow we execute your find command, but with the -v flag/option.\nfind u0x/ -name \"*.XML\" -exec mv -v {} ADI.XML \\;\n\n\nOutput\nrenamed './XMLs/folder_2/PROCESSED_ADI.XML' -> 'ADI.XML'\nrenamed './XMLs/folder_9/PROCESSED_ADI.XML' -> 'ADI.XML'\nrenamed './XMLs/folder_7/PROCESSED_ADI.XML' -> 'ADI.XML'\nrenamed './XMLs/folder_10/PROCESSED_ADI.XML' -> 'ADI.XML'\nrenamed './XMLs/folder_6/PROCESSED_ADI.XML' -> 'ADI.XML'\nrenamed './XMLs/folder_3/PROCESSED_ADI.XML' -> 'ADI.XML'\nrenamed './XMLs/folder_8/PROCESSED_ADI.XML' -> 'ADI.XML'\nrenamed './XMLs/folder_1/PROCESSED_ADI.XML' -> 'ADI.XML'\nrenamed './XMLs/folder_4/PROCESSED_ADI.XML' -> 'ADI.XML'\nrenamed './XMLs/folder_5/PROCESSED_ADI.XML' -> 'ADI.XML'\n\n\nNow check what happened to the files using the tree command.\ntree u0x/\n\n\nOutput\nu0x/\n\u251c\u2500\u2500 ADI.XML\n\u2514\u2500\u2500 XMLs\n    \u251c\u2500\u2500 folder_1\n    \u251c\u2500\u2500 folder_10\n    \u251c\u2500\u2500 folder_2\n    \u251c\u2500\u2500 folder_3\n    \u251c\u2500\u2500 folder_4\n    \u251c\u2500\u2500 folder_5\n    \u251c\u2500\u2500 folder_6\n    \u251c\u2500\u2500 folder_7\n    \u251c\u2500\u2500 folder_8\n    \u2514\u2500\u2500 folder_9\n\n11 directories, 1 file\n\n\nNow If you take a good look at the above output from tree all of the PROCESSED_ADI.XML are gone from it's location/folder but there is one ADI.XML inside the parent directory/folder u0x\nLike what was mentioned by @Gordon Davidson All the xml (as long as the file ends in .xml) files has been moved in one location and it was overwritten again and again so now you have only one file named. ADI.XML\n\nUsing -execdir will have the expected output you're looking for.\n\nThe output of the tree command if -execdir was used, should be:\ntree u0x/\n\nu0x/\n\u2514\u2500\u2500 XMLs\n    \u251c\u2500\u2500 folder_1\n    \u2502\u00a0\u00a0 \u2514\u2500\u2500 ADI.XML\n    \u251c\u2500\u2500 folder_10\n    \u2502\u00a0\u00a0 \u2514\u2500\u2500 ADI.XML\n    \u251c\u2500\u2500 folder_2\n    \u2502\u00a0\u00a0 \u2514\u2500\u2500 ADI.XML\n    \u251c\u2500\u2500 folder_3\n    \u2502\u00a0\u00a0 \u2514\u2500\u2500 ADI.XML\n    \u251c\u2500\u2500 folder_4\n    \u2502\u00a0\u00a0 \u2514\u2500\u2500 ADI.XML\n    \u251c\u2500\u2500 folder_5\n    \u2502\u00a0\u00a0 \u2514\u2500\u2500 ADI.XML\n    \u251c\u2500\u2500 folder_6\n    \u2502\u00a0\u00a0 \u2514\u2500\u2500 ADI.XML\n    \u251c\u2500\u2500 folder_7\n    \u2502\u00a0\u00a0 \u2514\u2500\u2500 ADI.XML\n    \u251c\u2500\u2500 folder_8\n    \u2502\u00a0\u00a0 \u2514\u2500\u2500 ADI.XML\n    \u2514\u2500\u2500 folder_9\n        \u2514\u2500\u2500 ADI.XML\n\n11 directories, 10 files\n\n", "\nlet c=0; for i in $('ls'); do c=$((c+1)); mkdir -p folder_$c; mv $i folder_$c; done\n\nThis should do it, I think.\nExplanation:\n\ndefine variable c\ngo over each element in ls\n\nadd 1 to c\ncreate folder with suffix c\nmove element to folder\n\n\n\n", "\nYou can use extended globs to exclude archive from your pattern as follows:\nshopt -s extglob\nmv !(archive) archive\n\nThis will move everything in the current folder, except for hidden files, to archive.\nIf you want to move hidden files starting with a . to the archive folder too, you need to set the dotglob option as described in bash manual under Filename Expansion:\nshopt -s dotglob\n\nHere is another method using find:\nfind . -maxdepth 1 -type f ! -name \"archive\" -exec mv -t archive {} +\n\nAlthough the first method is preferred, IMO, since bash builtins are perfectly capable of what find is doing here.\n"]}