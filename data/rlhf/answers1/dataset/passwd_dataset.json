{"prompt": ["How can I query all users on a box and force password expiration?Currently, I am querying all users:getent shadow | awk -F: '$2 ~ /^\\$/ || $2 ~ /^!\\$/ {print $1} {print $3}'\nAnd this gets me the user name as well as the last password change, but I only need to force the passwd -e on users who haven't changed their password since before March 1, 2022 - anyone who has changed their password after March 1, 2022 I can leave those alone (I believe this would be a value of 19052 - so any value greater than or equal to that I can skip).", "I have a small elif script that has 4 options. I will need to make a user that has permissions to run just that script on login and when it finishes with the script to log him out.I am trying to do it trough /etc/passwd like this:\nuser:x:1003:1003::/home/user:script.shWhen already connected with root and then \"su\" to user, it executes the script.\nThe issue is that the user cant connect trough putty and execute the script, which is the goal of what i am trying to do.Any advise is welcome and appreciated.Cheers,", "I'm trying to change the password for user foo with user bar by calling a shell command. But I have some problems. I can do this to send a password to sudo$ echo sudopw | sudo -S ls\nAnd this to change password:$ echo foo:newpw | sudo chpasswd\n[sudo] password for bar: sudopw    \nThis changes the password for user foo to newpw, but it forces me to enter the sudo password manually. The problem is that I cannot see how to combine these things. I tried this, but it does not work:$ echo sudopw | sudo -S echo foo:newpw | chpasswd \nchpasswd: Permission denied.\nchpasswd: cannot lock /etc/passwd; try again later.\n[sudo] password for bar: [bar@host]$\nI did manage to do it like this:echo sudopw | echo -e \"newpw\\nnewpw\" | sudo passwd dummy\nBut when I tried it like this it asks for password again.os.system('echo sudopw | echo -e \"newpw\\nnewpw\" | sudo passwd dummy')\nI have found numerous answers on how to send the password to sudo <cmd> where cmd does not require any additional input. But I really cannot solve the situation of BOTH sending input to cmd AND sending the password to sudo from a python script.", "I'm trying to change the password for user foo with user bar by calling a shell command. But I have some problems. I can do this to send a password to sudo$ echo sudopw | sudo -S ls\nAnd this to change password:$ echo foo:newpw | sudo chpasswd\n[sudo] password for bar: sudopw    \nThis changes the password for user foo to newpw, but it forces me to enter the sudo password manually. The problem is that I cannot see how to combine these things. I tried this, but it does not work:$ echo sudopw | sudo -S echo foo:newpw | chpasswd \nchpasswd: Permission denied.\nchpasswd: cannot lock /etc/passwd; try again later.\n[sudo] password for bar: [bar@host]$\nI did manage to do it like this:echo sudopw | echo -e \"newpw\\nnewpw\" | sudo passwd dummy\nBut when I tried it like this it asks for password again.os.system('echo sudopw | echo -e \"newpw\\nnewpw\" | sudo passwd dummy')\nI have found numerous answers on how to send the password to sudo <cmd> where cmd does not require any additional input. But I really cannot solve the situation of BOTH sending input to cmd AND sending the password to sudo from a python script.", "I'm trying to change the password for user foo with user bar by calling a shell command. But I have some problems. I can do this to send a password to sudo$ echo sudopw | sudo -S ls\nAnd this to change password:$ echo foo:newpw | sudo chpasswd\n[sudo] password for bar: sudopw    \nThis changes the password for user foo to newpw, but it forces me to enter the sudo password manually. The problem is that I cannot see how to combine these things. I tried this, but it does not work:$ echo sudopw | sudo -S echo foo:newpw | chpasswd \nchpasswd: Permission denied.\nchpasswd: cannot lock /etc/passwd; try again later.\n[sudo] password for bar: [bar@host]$\nI did manage to do it like this:echo sudopw | echo -e \"newpw\\nnewpw\" | sudo passwd dummy\nBut when I tried it like this it asks for password again.os.system('echo sudopw | echo -e \"newpw\\nnewpw\" | sudo passwd dummy')\nI have found numerous answers on how to send the password to sudo <cmd> where cmd does not require any additional input. But I really cannot solve the situation of BOTH sending input to cmd AND sending the password to sudo from a python script.", "I want to change root password of multiple server's. I used shell with for loop and chpasswd utility to do this. Since the sudo account is password enabled, it is prompting sudo password all the time I exit script.Below is bash Script is written in bash. But always prompting for password.#!/bin/bash\npass=\"PASSWORD\"\n\nfor i in $(cat serverlist)\n\ndo\n\nssh -t sudouser@$i \"sudo chpasswd <<EOF\n\nroot:\"$pass\"\n\nEOF\" ;\n\ndone\nCompletely automated bash to change root password.", "I developed a tool to send one-line commands to different linux machines in one shot using JSch (A java library used to communicating with other machines over ssh)So our client needs to change the password on ALL machines. Google helped me reach this point:echo -e \"123\\n123\" | passwd username\nWhere '123' is the new password.The command executes but this is ALWAYS the output:[root@QNA-XR1 ~]# echo -e \"123\\n123\" | passwd\nChanging password for root\nNew password:\nRetype password:\npasswd: password for root is unchanged\nWhich indicates that the command didn't succeed.Please note that this is an small device with linux running on it. It's a privately compiled version to be as compact as possible. I don't know much about linux actually !This is the machines info:[root@QNA-XR1 ~]# uname -a\nLinux QNA-XR1 2.6.22-XR100-v1.1.7 #1 Tue Aug 19 22:55:50 EDT 2008 ppc unknown\npasswd help:[root@QNA-XR1 ~]# passwd --help\nBusyBox v1.7.3 (2008-01-09 00:06:30 EST) multi-call binary\n\nUsage: passwd [OPTION] [name]\n\nChange a user password. If no name is specified,\nchanges the password for the current user.\n\nOptions:\n        -a      Define which algorithm shall be used for the password\n                (choices: des, md5)\n        -d      Delete the password for the specified user account\n        -l      Locks (disables) the specified user account\n        -u      Unlocks (re-enables) the specified user account\necho help[root@QNA-XR1 ~]# help echo\necho: echo [-neE] [arg ...]\n    Output the ARGs.  If -n is specified, the trailing newline is\n    suppressed.  If the -e option is given, interpretation of the\n    following backslash-escaped characters is turned on:\n        \\a      alert (bell)\n        \\b      backspace\n        \\c      suppress trailing newline\n        \\E      escape character\n        \\f      form feed\n        \\n      new line\n        \\r      carriage return\n        \\t      horizontal tab\n        \\v      vertical tab\n        \\\\      backslash\n        \\num    the character whose ASCII code is NUM (octal).\n\n    You can explicitly turn off the interpretation of the above characters\n    with the -E option.\nThanks a lot in advance for you help.", "I developed a tool to send one-line commands to different linux machines in one shot using JSch (A java library used to communicating with other machines over ssh)So our client needs to change the password on ALL machines. Google helped me reach this point:echo -e \"123\\n123\" | passwd username\nWhere '123' is the new password.The command executes but this is ALWAYS the output:[root@QNA-XR1 ~]# echo -e \"123\\n123\" | passwd\nChanging password for root\nNew password:\nRetype password:\npasswd: password for root is unchanged\nWhich indicates that the command didn't succeed.Please note that this is an small device with linux running on it. It's a privately compiled version to be as compact as possible. I don't know much about linux actually !This is the machines info:[root@QNA-XR1 ~]# uname -a\nLinux QNA-XR1 2.6.22-XR100-v1.1.7 #1 Tue Aug 19 22:55:50 EDT 2008 ppc unknown\npasswd help:[root@QNA-XR1 ~]# passwd --help\nBusyBox v1.7.3 (2008-01-09 00:06:30 EST) multi-call binary\n\nUsage: passwd [OPTION] [name]\n\nChange a user password. If no name is specified,\nchanges the password for the current user.\n\nOptions:\n        -a      Define which algorithm shall be used for the password\n                (choices: des, md5)\n        -d      Delete the password for the specified user account\n        -l      Locks (disables) the specified user account\n        -u      Unlocks (re-enables) the specified user account\necho help[root@QNA-XR1 ~]# help echo\necho: echo [-neE] [arg ...]\n    Output the ARGs.  If -n is specified, the trailing newline is\n    suppressed.  If the -e option is given, interpretation of the\n    following backslash-escaped characters is turned on:\n        \\a      alert (bell)\n        \\b      backspace\n        \\c      suppress trailing newline\n        \\E      escape character\n        \\f      form feed\n        \\n      new line\n        \\r      carriage return\n        \\t      horizontal tab\n        \\v      vertical tab\n        \\\\      backslash\n        \\num    the character whose ASCII code is NUM (octal).\n\n    You can explicitly turn off the interpretation of the above characters\n    with the -E option.\nThanks a lot in advance for you help."], "chosen": ["\nI like the approach @KamilCuk took. To add to that I would include a minimum UID and maximum UID on parsing /etc/passwd to exclude system accounts. (note: some distributions start the first non-system UID at differing values, usually either 500 or 1000 -- check your distro). The maximum UID can exclude generic user accounts placed at the top of the range like the nobody account on openSUSE with UID == 65534\nTo determine whether to expire an account with a password change older that March 1, 2022, it is fairly easy to convert that date and the date returned by chage to seconds-since-Epoch. That way you can use a simple comparison of if the last password change is less than the number of seconds since Epoch for March 1, 2022 -- expire the account.\nBelow is one approach you can take to put it all together. xargs is another option to build the list instead of expiring accounts one-by-one. The actual expiration is commented out below and instead the command that would be run is printed to stdout to allow testing before actual expiration of accounts.\n#!/bin/bash\n\n## validate script is run with root privilege\n[ $UID != 0 ] && [ $EUID != 0 ] && {\n  printf \"error: script must be run as root, UID '%s' can't,\\n\" \"$UID\" >&2\n  exit 1\n} \n\nminUID=1000     ## first non-system UID\nmaxUID=65534    ## nobody\n\nmarch1epoch=$(date -d \"2022-03-01\" +%s)   ## seconds since epoch\n\n## pipe non-system users to while loop to check aging with chage\nawk -v minU=\"$minUID\" -v maxU=\"$maxUID\" -F: '\n  $3 >= minU && $3 < maxU { print $1 }\n' /etc/passwd | \n{\n## read each user name, get age since last pw change\nwhile read -r usrnm; do \n  age=$(date -d \"$(chage -l \"$usrnm\" | \n        awk -F: 'FNR==1 {print $NF; exit}')\" +%s)\n  ## compare with march1epoch, expire all that are older\n  [ \"$age\" -lt \"$march1epoch\" ] && echo \"passwd -e \\\"$usrnm\\\"\"\n  ### uncomment line below to actually expire account\n  # [ \"$age\" -lt \"$march1epoch\" ] && passwd -e \"$usrnm\"\ndone\n}\n\n(note: you can use Process Substitution to feed the while loop in bash rather than piping the results to it -- up to you. If you are stuck with POSIX shell, then piping will work in both instances)\nWhen satisfied, uncomment the final line in the loop, and optionally remove the line that simply outputs the command that would be run.\n", "\nTry giving the full path to script.sh in passwd. Even if this file is in the $PATH when you su to the user, it isn't necessarily in the $PATH in an SSH session. The SSH session might provide an environment that is different in other ways, too.\n", "\nYou can use sudo command without password.\n$ sudo visudo\n\nIf you run python with XXX user, then please add the following line.\nXXX ALL=(ALL) NOPASSWD:/usr/sbin/chpasswd\n\nAfter, you can use $ sudo chpasswd command without password.\n", "\nI finally managed to solve it. I want to emphasize that this solution might have security flaws and may not be a suitable choice for everybody. In my case, it should only be run once, and anyone who could take advantage of any flaws in this code have already come way to far.\nr = Popen(('mkpasswd', '-m', 'sha-512', new_password), stdout=PIPE)\nshadow = r.communicate()[0].strip()\n\nproc = Popen(['sudo', '-S', '-k', 'usermod', '-p', shadow, 'foo'], \n             stdin=PIPE, stdout=PIPE)\nproc.stdin.write(sudo_password + b'\\n')\nproc.stdin.flush()\nproc.communicate()\n\n", "\nIf visudo is not your option, then please try the following\n$ echo 'sudopassword\nfoo:newpassword' | sudo -S /usr/sbin/chpasswd\n\nOr\n$ echo -e \"sudopassword\\nfoo:newpassword\" | sudo -S /usr/sbin/chpasswd\n\n", "\nI also think you should use expect. The script I've written isn't fully tested, since I don't have a server which I'm conformable on to change passwords :-)\n#!/bin/bash\n\nread -p \"Server username? \" USERNAME\nread -sp \"Server password for ${USERNAME}? \" PASSWORD\n\necho\nread -p \"Name of file containing server list? \" S_FILE\nread -p \"User to change on servers? \" S_USERNAME\nread -sp \"New password for user ${S_USERNAME}?\" S_PASSWORD\necho\n\nwhile IFS= read -r SERVER; do\n        [ ! -z \"${SERVER}\" ] || continue\n        expect <<-EOF\n                spawn ssh ${USERNAME}@${SERVER}\n                expect \"*: \" { send \"${PASSWORD}\\r\" }\n                expect \"*$ \" { send \"echo '${S_USERNAME}:${S_PASSWORD}' | sudo chpasswd\\r\" }\n                expect \"*: \" { send \"${PASSWORD}\\r\" }\n                expect \"*$ \" { send \"exit\\r\" }\nEOF\n        echo\ndone < ${S_FILE}\nexit $?\n\n", "\n/bin/passwd may be opening /dev/tty to force reading from a terminal instead of a pipe.\nYou may be better off encrypting (hashing, really) your new password using crypt(), and then replacing the password hash in /etc/shadow (for systems that have it) or /etc/passwd (for systems that don't).  This has the disadvantage of being somewhat OS-dependent, but it doesn't get into weird tty games.\nYou might also be able to force allocation of a tty in ssh - ssh can operate both with or without one.  Then you would add a couple of delays before sending the password in plaintext twice - this method is less OS-dependent, but tty games can be less than fun sometimes.\n", "\nYou can use the single command to change the user password.\necho -e \"password\\npassword\" | sudo -S passwd testuser\n"], "rejected": ["\nI did this:\ncut -d: -f1 /etc/passwd | { while IFS= read -r n; do echo -n \"$n \"; chage -li \"$n\" | awk 'NR==1{print $NF}'; done; echo CUTME 2022-03-01; } | sort -k2 | awk 'f{print} /CUTME/{f=1}'\n\nYou can then xargs passwd -e if you want.\n", "\nTry a normal user with adduser and then edit two files in his home...\n# .profile\nlogout\n\n...and...\n# .bash_logout\nclear\n\nWhen this user logs in ( with ssh/PuTTY ) then .profile logs him out and .bash_logout is executed too. So you can decide to do something at login or logout or twice.\n", "\nsudo is caching the password for a short while, you may try to make 2 different calls, one to provide password to sudo: something like sudo ls works just fine, then you call the second command, which will not require the password for sudo, just the input you need to change the user's password.\n", "\nsudo is caching the password for a short while, you may try to make 2 different calls, one to provide password to sudo: something like sudo ls works just fine, then you call the second command, which will not require the password for sudo, just the input you need to change the user's password.\n", "\nsudo is caching the password for a short while, you may try to make 2 different calls, one to provide password to sudo: something like sudo ls works just fine, then you call the second command, which will not require the password for sudo, just the input you need to change the user's password.\n", "\nWriting a script to do unattended root things is dangerous. All you need is one machine to somehow behave differently than you expect and your automated approach wouldn't work. Worse, you could end up in some bad state, possibly without even realizing that anything went wrong.\nThis sounds like a great fit for csshx (or something similar). Use it to manually apply whatever changes you want in parallel across multiple hosts. For example, you could connect to 16 hosts at once like this:\ncsshx host[1-16]\n\nthen type commands and watch output for each host.\nIf this seems infeasible due to the number of machines you have, I would counter that it's much safer than scripting, and - even if \"slow\" - the overall time spent might very well be less than that of trying to create an automated solution. ;)\n", "\nYou can use chpasswd (as root but it's not secure):\n# echo \"user:passwd\" | chpasswd\n\n", "\nYou can use chpasswd (as root but it's not secure):\n# echo \"user:passwd\" | chpasswd\n\n"]}