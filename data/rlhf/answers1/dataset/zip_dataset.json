{"prompt": ["I'm writing a bash script which compresses (with encryption or without, depending on what the user chooses) and decompresses files using zip.\nMy problem is the decompressing part - when the user chooses a zip file to decompress (via zenity file selection), is there any way to check if the file is password protected in order to ask the user for the password (or if it isn't, just proceed and decompress the file)? I didn't really try anything yet, as I've struggled to come up with any idea or find a solution on stack and other websites.", "I'm writing a bash script which compresses (with encryption or without, depending on what the user chooses) and decompresses files using zip.\nMy problem is the decompressing part - when the user chooses a zip file to decompress (via zenity file selection), is there any way to check if the file is password protected in order to ask the user for the password (or if it isn't, just proceed and decompress the file)? I didn't really try anything yet, as I've struggled to come up with any idea or find a solution on stack and other websites.", "I am trying to zip a file using shell script command. I am using following command:  zip ./test/step1.zip $FILES\nwhere $FILES contain all the input files. But I am getting a warning as follows    zip warning: name not matched: myfile.dat\nand one more thing I observed that the file which is at last in the list of files in a folder has the above warning and that file is not getting zipped.Can anyone explain me why this is happening? I am new to shell script world.", "I am trying to zip a file using shell script command. I am using following command:  zip ./test/step1.zip $FILES\nwhere $FILES contain all the input files. But I am getting a warning as follows    zip warning: name not matched: myfile.dat\nand one more thing I observed that the file which is at last in the list of files in a folder has the above warning and that file is not getting zipped.Can anyone explain me why this is happening? I am new to shell script world.", "I am trying to zip a file using shell script command. I am using following command:  zip ./test/step1.zip $FILES\nwhere $FILES contain all the input files. But I am getting a warning as follows    zip warning: name not matched: myfile.dat\nand one more thing I observed that the file which is at last in the list of files in a folder has the above warning and that file is not getting zipped.Can anyone explain me why this is happening? I am new to shell script world.", "I am trying to zip a file using shell script command. I am using following command:  zip ./test/step1.zip $FILES\nwhere $FILES contain all the input files. But I am getting a warning as follows    zip warning: name not matched: myfile.dat\nand one more thing I observed that the file which is at last in the list of files in a folder has the above warning and that file is not getting zipped.Can anyone explain me why this is happening? I am new to shell script world.", "I am trying to zip a file using shell script command. I am using following command:  zip ./test/step1.zip $FILES\nwhere $FILES contain all the input files. But I am getting a warning as follows    zip warning: name not matched: myfile.dat\nand one more thing I observed that the file which is at last in the list of files in a folder has the above warning and that file is not getting zipped.Can anyone explain me why this is happening? I am new to shell script world.", "I am trying to zip a file using shell script command. I am using following command:  zip ./test/step1.zip $FILES\nwhere $FILES contain all the input files. But I am getting a warning as follows    zip warning: name not matched: myfile.dat\nand one more thing I observed that the file which is at last in the list of files in a folder has the above warning and that file is not getting zipped.Can anyone explain me why this is happening? I am new to shell script world.", "I am trying to zip a file using shell script command. I am using following command:  zip ./test/step1.zip $FILES\nwhere $FILES contain all the input files. But I am getting a warning as follows    zip warning: name not matched: myfile.dat\nand one more thing I observed that the file which is at last in the list of files in a folder has the above warning and that file is not getting zipped.Can anyone explain me why this is happening? I am new to shell script world.", "How can I get the equivalent of an ls of a .zip file (not gzip), without decompressing it, from the command shell? That is, how can I list the different files compressed within my .zip archive?", "How can I get the equivalent of an ls of a .zip file (not gzip), without decompressing it, from the command shell? That is, how can I list the different files compressed within my .zip archive?", "How can I get the equivalent of an ls of a .zip file (not gzip), without decompressing it, from the command shell? That is, how can I list the different files compressed within my .zip archive?", "How can I get the equivalent of an ls of a .zip file (not gzip), without decompressing it, from the command shell? That is, how can I list the different files compressed within my .zip archive?", "How can I get the equivalent of an ls of a .zip file (not gzip), without decompressing it, from the command shell? That is, how can I list the different files compressed within my .zip archive?", "How can I get the equivalent of an ls of a .zip file (not gzip), without decompressing it, from the command shell? That is, how can I list the different files compressed within my .zip archive?", "How can I get the equivalent of an ls of a .zip file (not gzip), without decompressing it, from the command shell? That is, how can I list the different files compressed within my .zip archive?", "How can I get the equivalent of an ls of a .zip file (not gzip), without decompressing it, from the command shell? That is, how can I list the different files compressed within my .zip archive?", "How can I get the equivalent of an ls of a .zip file (not gzip), without decompressing it, from the command shell? That is, how can I list the different files compressed within my .zip archive?", "Recently, i've been searching how to compress the git status modified files on command line linux. This git status before git add and git commit commands.$ git status\n.\n.\nmodified:   app/model/solicitud/Solicitud.js\nmodified:   app/view/basura/Grilla.js\nmodified:   app/view/excepcion/Grilla.js\nmodified:   app/view/modulo/Contenedor.js\nmodified:   app/view/modulo/Grilla.js\n.\n.\nSo, i came with this solutions, to .tar.gz and zip respectively:$ git status |grep -i \"modified:\" |cut -d':' -f2 |tee |tr -d \" \" | tar -T - -zcvf ~/myfolderdesttar/myfile.tar.gz\n$ git status |grep -i \"modified:\" |cut -d':' -f2 |tee |tr -d \" \" | zip ~/myfolderdestzip/myzipfile.zip -@\n\u00bfDo you have a shorter solution to this or a better way with git command?.\nThanks.", "Given there is a secret file deep inside a nested ZIP file, i.e. a zip file inside a zip file inside a zip file, etc...The zip files are named 1.zip, 2.zip, 3.zip, etc...We don't know how deep the zip files are nested, but it may be thousands.What would be the easiest way to loop through all of them up until the last one to read the secret file?My initial approach would have been to call unzip recursively, but my Bash skills are limited. What are your ideas to solve this?", "Given there is a secret file deep inside a nested ZIP file, i.e. a zip file inside a zip file inside a zip file, etc...The zip files are named 1.zip, 2.zip, 3.zip, etc...We don't know how deep the zip files are nested, but it may be thousands.What would be the easiest way to loop through all of them up until the last one to read the secret file?My initial approach would have been to call unzip recursively, but my Bash skills are limited. What are your ideas to solve this?", "Given there is a secret file deep inside a nested ZIP file, i.e. a zip file inside a zip file inside a zip file, etc...The zip files are named 1.zip, 2.zip, 3.zip, etc...We don't know how deep the zip files are nested, but it may be thousands.What would be the easiest way to loop through all of them up until the last one to read the secret file?My initial approach would have been to call unzip recursively, but my Bash skills are limited. What are your ideas to solve this?", "Given there is a secret file deep inside a nested ZIP file, i.e. a zip file inside a zip file inside a zip file, etc...The zip files are named 1.zip, 2.zip, 3.zip, etc...We don't know how deep the zip files are nested, but it may be thousands.What would be the easiest way to loop through all of them up until the last one to read the secret file?My initial approach would have been to call unzip recursively, but my Bash skills are limited. What are your ideas to solve this?", "Given there is a secret file deep inside a nested ZIP file, i.e. a zip file inside a zip file inside a zip file, etc...The zip files are named 1.zip, 2.zip, 3.zip, etc...We don't know how deep the zip files are nested, but it may be thousands.What would be the easiest way to loop through all of them up until the last one to read the secret file?My initial approach would have been to call unzip recursively, but my Bash skills are limited. What are your ideas to solve this?", "Can somebody please explain the following mystery?I created a binary file of size ~37[MB]. zipping it in Ubuntu -- using the terminal -- took less than 1[sec]. I then tried python: zipping it programatically (using the zipfile module) took also about 1[sec].I then tried to unzip the zip file I created. In Ubuntu -- using the terminal -- this took less than 1[sec].In python, the code to unzip (used the zipfile module) took close to 37[sec] to run! any ideas why?", "Can somebody please explain the following mystery?I created a binary file of size ~37[MB]. zipping it in Ubuntu -- using the terminal -- took less than 1[sec]. I then tried python: zipping it programatically (using the zipfile module) took also about 1[sec].I then tried to unzip the zip file I created. In Ubuntu -- using the terminal -- this took less than 1[sec].In python, the code to unzip (used the zipfile module) took close to 37[sec] to run! any ideas why?", "Can somebody please explain the following mystery?I created a binary file of size ~37[MB]. zipping it in Ubuntu -- using the terminal -- took less than 1[sec]. I then tried python: zipping it programatically (using the zipfile module) took also about 1[sec].I then tried to unzip the zip file I created. In Ubuntu -- using the terminal -- this took less than 1[sec].In python, the code to unzip (used the zipfile module) took close to 37[sec] to run! any ideas why?", "I can get the count number of files in the zip but unable to exclude any files have extension metadata.  How can I count only \"pdf\" files in the zip.  I really appreciate any help you can provide.unzip -l 0532.zip\n742248    05-31-2023 15:19   /pdf/0531/CP-1960-5266M.pdf\n4125      05-31-2023 15:19   /pdf/0531/CB-CB-177729.pdf.metadata\n1221395   05-31-2023 15:19   /pdf/0531/CB-CB-177729.pdf\n4128      05-31-2023 15:19   /pdf/0531/CP-1988-10086.pdf.metadata\n243050    05-31-2023 15:19   /pdf/0531/CP-1988-10086.pdf\n4125      05-31-2023 15:19   /pdf/0531/R-1978448.pdf.metadata\n5735942   05-31-2023 15:19   /pdf/0531/R-1978448.pdf\n.......   ....              ....\n.......   .....             ....\n---------                     -------\n2152688064                     1634 files\nI also try this but it fail to exclude \"metadata\" files. The total count exactly the same.unzip -l 0532.zip | awk '{count = $2} END{print count}'\n\n1634\n", "I have a zipped folder : folder.zip, the zip contains file1 and file2. I want to unzip file1 without unzipping folder.zip (Like what we can do using WinRaR). I want to be able to do this scenario using command line :\nopen (Without unzipping) folder.zip and display content\nFind file1 inside folder.zip\nUnzip file1\nGet at the end file1 unzipped and folder.zip\nI tried to do it using WinRaR application, and I'm expecting to do it using command line.", "I have a task to reach the last file in long line of nested zip archives. They go like this:3301.zip\n| 3300.zip\n| 3299.zip\n|\n...\n| 1.zipBasically, I have to extract one archive from another 3300 times in order to reach the file within 1.zip.I have searched for ways to do this, but maybe my search terms weren't right or I missed something. I tried \"reach last file nested zips\", \"extract nested zips\". My working environment is Linux and I tried several Terminal commands and tools. Nothing did what I wanted.", "I've got a large collection of gzipped archives on my Ubuntu webserver, and I need them converted to zips. I figure this would be done with a script, but what language should I use, and how would I go about unzipping and rezipping files?", "I've got a large collection of gzipped archives on my Ubuntu webserver, and I need them converted to zips. I figure this would be done with a script, but what language should I use, and how would I go about unzipping and rezipping files?", "I've got a large collection of gzipped archives on my Ubuntu webserver, and I need them converted to zips. I figure this would be done with a script, but what language should I use, and how would I go about unzipping and rezipping files?", "I've got a large collection of gzipped archives on my Ubuntu webserver, and I need them converted to zips. I figure this would be done with a script, but what language should I use, and how would I go about unzipping and rezipping files?", "I've got a large collection of gzipped archives on my Ubuntu webserver, and I need them converted to zips. I figure this would be done with a script, but what language should I use, and how would I go about unzipping and rezipping files?", "I've got a large collection of gzipped archives on my Ubuntu webserver, and I need them converted to zips. I figure this would be done with a script, but what language should I use, and how would I go about unzipping and rezipping files?", "Is there any way to perform diff operetion on two files in two zips without extracting them? If not - any other workaround to compare them without extracting? Thanks.", "Is there any way to perform diff operetion on two files in two zips without extracting them? If not - any other workaround to compare them without extracting? Thanks.", "Is there any way to perform diff operetion on two files in two zips without extracting them? If not - any other workaround to compare them without extracting? Thanks.", "Is there any way to perform diff operetion on two files in two zips without extracting them? If not - any other workaround to compare them without extracting? Thanks.", "Is there any way to perform diff operetion on two files in two zips without extracting them? If not - any other workaround to compare them without extracting? Thanks.", "Is there any way to perform diff operetion on two files in two zips without extracting them? If not - any other workaround to compare them without extracting? Thanks.", "Is there any way to perform diff operetion on two files in two zips without extracting them? If not - any other workaround to compare them without extracting? Thanks.", "Is there any way to perform diff operetion on two files in two zips without extracting them? If not - any other workaround to compare them without extracting? Thanks.", "Is there any way to perform diff operetion on two files in two zips without extracting them? If not - any other workaround to compare them without extracting? Thanks.", "I want to use mysqldump to get a table from a remote MySQL server, then compress this downloaded file using zip. While downloading, I wish I can view the progress using pv.Can I do the above things with | in one line of command?These are what I've tried:mysqldump -uuser_name -ppassword -hremote_address --routines my_database my_table | pv | zip > my_database_my_table.sql.zip\nThe problem with this command is that when executing unzip my_database_my_table.sql.zip, I got - as the name of the output file. I wish I could determine the file's name when I execute zip command.Is it possible to set the name of the inflated file?mysqldump -uuser_name -ppassword -hremote_address --routines my_database my_table | pv | zip my_database_my_table.sql > my_database_my_table.sql.zip\nThis command gives me mysqldump: Got errno 32 on write error.", "I want to use mysqldump to get a table from a remote MySQL server, then compress this downloaded file using zip. While downloading, I wish I can view the progress using pv.Can I do the above things with | in one line of command?These are what I've tried:mysqldump -uuser_name -ppassword -hremote_address --routines my_database my_table | pv | zip > my_database_my_table.sql.zip\nThe problem with this command is that when executing unzip my_database_my_table.sql.zip, I got - as the name of the output file. I wish I could determine the file's name when I execute zip command.Is it possible to set the name of the inflated file?mysqldump -uuser_name -ppassword -hremote_address --routines my_database my_table | pv | zip my_database_my_table.sql > my_database_my_table.sql.zip\nThis command gives me mysqldump: Got errno 32 on write error.", "I want to use mysqldump to get a table from a remote MySQL server, then compress this downloaded file using zip. While downloading, I wish I can view the progress using pv.Can I do the above things with | in one line of command?These are what I've tried:mysqldump -uuser_name -ppassword -hremote_address --routines my_database my_table | pv | zip > my_database_my_table.sql.zip\nThe problem with this command is that when executing unzip my_database_my_table.sql.zip, I got - as the name of the output file. I wish I could determine the file's name when I execute zip command.Is it possible to set the name of the inflated file?mysqldump -uuser_name -ppassword -hremote_address --routines my_database my_table | pv | zip my_database_my_table.sql > my_database_my_table.sql.zip\nThis command gives me mysqldump: Got errno 32 on write error."], "chosen": ["\nAlso: In a DOS prompt, type \"unzip myfile.zip\" and if you get prompted for the password, it is protected.\n", "\nif 7z l -slt file.zip | grep -q ZipCrypto; then\n  echo \"password protected / encrypted\"\nelse\n  echo \"no password protection / not encrypted\"\nfi\n\nSee: How to detect zip file encryption algorithm\n", "\n\nzip warning: name not matched: myfile.dat\n\nThis means the file myfile.dat does not exist.\nYou will get the same error if the file is a symlink pointing to a non-existent file.\nAs you say, whatever is the last file at the of $FILES, it will not be added to the zip along with the warning. So I think something's wrong with the way you create $FILES. Chances are there is a newline, carriage return, space, tab, or other invisible character at the end of the last filename, resulting in something that doesn't exist. Try this for example:\nfor f in $FILES; do echo :$f:; done\n\nI bet the last line will be incorrect, for example:\n:myfile.dat :\n\n...or something like that instead of :myfile.dat: with no characters before the last :\nUPDATE\nIf you say the script started working after running dos2unix on it, that confirms what everybody suspected already, that somehow there was a carriage-return at the end of your $FILES list.\nod -c shows the \\r carriage-return.  Try echo $FILES | od -c\n", "\nAnother possible cause that can generate a zip warning: name not matched: error is having any of zip's environment variables set incorrectly.\nFrom the man page:\nENVIRONMENT\n    The following environment variables are read and used by zip as described.\n\nZIPOPT\n    contains default options that will be used when running zip.  The contents of this environment variable will get added to the command line just after the zip command.\n\nZIP\n    [Not on RISC OS and VMS] see ZIPOPT\n\nZip$Options\n    [RISC OS] see ZIPOPT\n\nZip$Exts\n    [RISC OS] contains extensions separated by a : that will cause native filenames with one of the specified extensions to be added to the zip file with basename and extension swapped.\n\nZIP_OPTS\n    [VMS] see ZIPOPT\n\nIn my case, I was using zip in a script and had the binary location in an environment variable ZIP so that we could change to a different zip binary easily without making tonnes of changes in the script.\nExample:\nZIP=/usr/bin/zip\n...\n${ZIP} -r folder.zip folder\n\nThis is then processed as:\n/usr/bin/zip /usr/bin/zip -r folder.zip folder\n\nAnd generates the errors:\nzip warning: name not matched: folder.zip\nzip I/O error: Operation not permitted\nzip error: Could not create output file (/usr/bin/zip.zip)\n\nThe first because it's now trying to add folder.zip to the archive instead of using it as the archive. The second and third because it's trying to use the file /usr/bin/zip.zip as the archive which is (fortunately) not writable by a normal user.\nNote: This is a really old question, but I didn't find this answer anywhere, so I'm posting it to help future searchers (my future self included).\n", "\neebbesen hit the nail in his comment for my case (but i cannot vote for comment).\nAnother possible reason missed in the other comments is file exceeding the file size limit (4GB).\n", "\nI converted my script for unix environment using dos2unix command and executed my script as ./myscript.sh instead bash myscript.sh.\n", "\nI just discovered another potential cause for this. If the permissions of the directory/subdirectory don't allow the zip to find the file, it will report this error. Actually, if you run a chmod -R 444 on the directory, and then try to zip it, you will reproduce this error, and also have a \"stored 0%\" report, like this:\nzip warning: name not matched: borrar/enviar\n  adding: borrar/ (stored 0%)\nHence, try changing the permissions of the file. If you are trying to send them through email, and those email filters (like Gmail's) invent silly filters of not sending executables, don't forget that making permissions very strict when making zip compression can be the cause of the error you are reporting, of \"name not matched\".\n", "\nspaces are not allowed:\nit would fail if there are more than one files(s) in $FILES unless you put them in loop\n", "\nI also encountered this issue. In my case, the line separate is CRLF in my zip shell script which causes the problem. Using LF fixed it.\n", "\nThe less utility is capable of peeking into a zip archive.\nLess comes bundled with Unix and there is no need to install als.\nThe output is scrollable (paged) and does not log things to the terminal (unlike unzip -l mentioned in the other answer).\nAs per https://superuser.com/a/216675/249975,\nSo simply use less filename.zip\n", "\nUse unzip with -l option:\nunzip -l file.zip\n\n", "\nPerreal's answer is right, but I recommend installing atool (look for it in your distribution's package manager). Then, for any kind of archive file, bzip2, gzip, tar... you have just one command to remember :\nals archive_name\n\n", "\nTo view the contents of a zipped file without unzip by using this command\nunzip -l file.zip\n\nFor tar files, we can use\nzcat <archived-file>\n\n", "\nzipinfo -1 filename.zip\n\nIt returns only filenames, and no more, example (response):\nlisting.html\nmy_data.csv\nsuper.txt\n\n", "\nUse lesspipe in Debian/Ubuntu, it also can list many other archive types:\n\n     *.arj\n     *.tar.bz2\n     *.bz\n     *.bz2\n     *.deb, *.udeb\n     *.doc\n     *.gif, *.jpeg, *.jpg, *.pcd, *.png, *.tga, *.tiff, *.tif\n     *.iso, *.raw, *.bin\n     *.lha, *.lzh\n     *.pdf\n     *.rar, *.r[0-9][0-9]\n     *.rpm\n     *.tar.gz, *.tgz, *.tar.z, *.tar.dz\n     *.gz, *.z, *.dz\n     *.tar\n     *.jar, *.war, *.xpi, *.zip\n     *.zoo\n\n\nUsage:\nlesspipe file.zip\n\nreference\n", "\nYou can also use \"zmore archive_name\".\nIt will list archive and it content.\n", "\nI'll add in the following option, as I found it was by far the most convenient approach for my purposes (exploring contents of a 2GB tar, with tens of thousands of files and directories).\nUsing archivemount was the most useful method for me.\nThis is performed as follows:\nmkdir mount-point\narchivemount archive.tar.gz mountpoint\ncd mount-point\n\numount mount-point\n\nExplanation\nYou need to create an empty folder as your mount point. Easiest is to just create that folder within the folder where you have the archive file, as per above example. Although you can create it anywhere you like. Just change mount-point in the command accordingly.\nOnce you cd into the mount-point folder, you'll have a normal Linux folder and file tree to explore with any commands that you'd otherwise use to explore, find, cat, edit, ls, etc., folders and files in Linux. Very handy.\nUse umount to unmount the archive once you are done\nNote, you may need to first install archivemount. E.g, sudo apt install archivemount.\nWhy I found this so useful\nI basically wanted an easy way to investigate the contents of a large tar file. Just having a massive text output (tens of thousands of lines) of the folder and file names wasn't particularly useful for me. Even after figuring out ways to pipe that content through other post-processors.\nYou can use this method with zip files, tar files, and those compressed with gzip, bzip, or compress.\nFull details on archivemount are here.\nA good write-up on it is here.\nThis quote (from that article) summarises how flexible this tool is:\n\n[Because archivemount via FUSE] exposes its filesystems through the Linux kernel, you can use any application to load and save files directly into such mounted archives. This lets you use your favourite text editor, image viewer, or music player on files that are still inside an archive file. Going one step further, because archivemount also supports write access for some archive formats, you can edit a text file directly from inside an archive too.\n\n", "\nTry using zless if you would like to browse a single zipped file.  This may be less useful when the zip contains multiple files.\nPer the description from the man page:\n\nZless is a filter which allows examination of compressed or plain text files one screenful at a time on a soft-copy terminal.  It is the equivalent of setting the  environment  variable  LESSOPEN  to  '|gzip  -cdfq  --  %s',  and  the  environment  variable  LESSMETACHARS  to  '<new\u2010line>;*?\"()<>[|&^`#$%=~',  and  then running less.  However, enough people seem to think that having the command zless available is important to be worth providing it.\n\nSome other handy \"z\" utilities are zcat and zmore (mentioned in previous answers), zdiff and zgrep.\nRegarding answering the original question, how to view the contents of a zip, I prefer zipinfo followed by unzip -l.\n", "\nto tar modified files:\ngit status | grep modified | awk '{print $3}' | xargs tar cvf modified.tar\n\nto tar new files:\ngit status | grep new | awk '{print $3}' | xargs tar cvf new.tar\n\n", "\nHere's my 2 cents.\n#!/bin/bash\n\nfunction extract(){\n  unzip $1 -d ${1/.zip/} && eval $2 && cd ${1/.zip/}\n  for zip in `find . -maxdepth 1 -iname *.zip`; do\n    extract $zip 'rm $1'\n  done\n}\n\nextract '1.zip'\n\n", "\nThanks Cyrus! The master wizard Shawn J. Goff had the perfect script for this:\nwhile [ \"`find . -type f -name '*.zip' | wc -l`\" -gt 0 ]; do find -type f -name \"*.zip\" -exec unzip -- '{}' \\; -exec rm -- '{}' \\;; done\n\n", "\nProbably not the cleanest way, but that should do the trick:\n#!/bin/sh\nIDX=1 # ID of your first zip file\nwhile [ 42 ]\ndo\n    unzip $IDX.zip # Extract\n    if [[ $? != 0 ]]\n    then\n        break # Quit if unzip failed (no more files)\n    fi\n    if [ $IDX -ne 1 ]\n    then\n        rm $IDX.zip # Remove zip to leave your directory clean\n    fi\n    (( IDX ++ )) # Next file\ndone\n\n", "\nCheckout this java based utility nzip for nested zips.\nExtracting and compressing nested zips can be done easily using following commands:\njava -jar nzip.jar -c list -s readme.zip \n\njava -jar nzip.jar -c extract -s \"C:\\project\\readme.zip\" -t readme \n\njava -jar nzip.jar -c compress -s readme -t \"C:\\project\\readme.zip\" \n\nPS. I am the author and will be happy to fix any bugs quickly.\n\n", "\nHere is a solution for windows assuming 7zip is installed in the default location.\n@echo off\nSetlocal EnableDelayedExpansion\nSet source=%1\nSet SELF=%~dpnx0\nFor %%Z in (!source!) do (\n    set FILENAME=%%~nxZ\n)\nset FILENAME=%FILENAME:\"=%\n\n\"%PROGRAMFILES%\\7-zip\\7z.exe\" x -o* -y \"%FILENAME%\"\n\nREM DEL \"%FILENAME%\"\nrem \" This is just to satisfy stackoverflow code formatting!\n\n\nFor %%Z in (!source!) do (\n    set FILENAME=%%~nZ\n)\nfor %%a in (zip rar jar z bz2 gz gzip tgz tar lha iso wim cab rpm deb) do (\n    \n    forfiles /P ^\"%FILENAME%^\" /S /M *.%%a /C \"cmd /c if @isdir==FALSE \\\"%SELF%\\\" @path\"\n)\n\nThis has been adapted from here https://social.technet.microsoft.com/Forums/ie/en-US/ccd7172b-85e3-4b4a-ad93-5902e0abd903/batch-file-extracting-all-files-from-nested-archives?forum=ITCG\nNotes:\n\nThe only way to do variable modification using the ~ modifiers is to use a dummy for..in loop. If there is a better way please edit.\n~nx modifies the variable to make it a full path+file name.\n~dpnx also does the same thing to %0 i.e. gets the full path and filename of the script.\n-o* in the 7zip command line allows 7zip to create folder names without the .zip extension like it does when extracting with a right click in the gui.\n~n modifies the variable to make it a filename without an extension. i.e. drops the .zip\nNote that the escape character (for quotes) in FORFILES /P is ^ (caret) while for the CMD /C it is \\. This ensures that it handles path and filenames with spaces also recursively without any problem.\nYou can remove the REM from the DEL statement if you want the zip file to be deleted after unzipping.\n\n", "\nI was struggling to unzip/decompress/extract zip files with Python as well and that \"create ZipFile object, loop through its .namelist(), read the files and write them to file system\" low-level approach didn't seem very Python. So I started to dig zipfile objects that I believe not very well documented and covered all the object methods:\n>>> from zipfile import ZipFile\n>>> filepath = '/srv/pydocfiles/packages/ebook.zip'\n>>> zip = ZipFile(filepath)\n>>> dir(zip)\n['NameToInfo', '_GetContents', '_RealGetContents', '__del__', '__doc__', '__enter__', '__exit__', '__init__', '__module__', '_allowZip64', '_didModify', '_extract_member', '_filePassed', '_writecheck', 'close', 'comment', 'compression', 'debug', 'extract', 'extractall', 'filelist', 'filename', 'fp', 'getinfo', 'infolist', 'mode', 'namelist', 'open', 'printdir', 'pwd', 'read', 'setpassword', 'start_dir', 'testzip', 'write', 'writestr'] \n\nThere we go the \"extractall\" method works just like tarfile's extractall ! (on python 2.6 and 2.7 but NOT 2.5)\nThen the performance concerns; the file ebook.zip is 84.6 MB (mostly pdf files) and uncompressed folder is 103 MB, zipped by default \"Archive Utility\" under MacOSx 10.5. So I did the same with Python's timeit module:\n>>> from timeit import Timer\n>>> t = Timer(\"filepath = '/srv/pydocfiles/packages/ebook.zip'; \\\n...         extract_to = '/tmp/pydocnet/build'; \\\n...         from zipfile import ZipFile; \\\n...         ZipFile(filepath).extractall(path=extract_to)\")\n>>> \n>>> t.timeit(1)\n1.8670060634613037\n\nwhich took less than 2 seconds on a heavy loaded machine that has 90% of the memory is being used by other applications.\nHope this helps someone.\n", "\nI don't know what code you use to unzip your file, but the following works for me: After creating a zip archive \"test.zip\" containing just one file \"file1\", the following Python script extracts \"file1\" from the archive:\nfrom zipfile import ZipFile, ZIP_DEFLATED\nzip = ZipFile(\"test.zip\", mode='r', compression=ZIP_DEFLATED, allowZip64=False)\ndata = zip.read(\"file1\")\nprint len(data)\n\nThis takes nearly no time: I tried a 37MB input file which compressed down to a 15MB zip archive.  In this example the Python script took 0.346 seconds on my MacBook Pro.  Maybe in your case the 37 seconds were taken up by something you did with the data instead?\n", "\nSome options:\n\nUse subprocess to defer it to some external tool. You can pipe data directly to it.\nczipfile, but that does not seem to be maintained anymore (last release 2010). A somewhat recent fork is ziyuang/czipfile (last update 2019).\nPyTorch has the internal native torch._C.PyTorchFileReader which can read zip files, see the torch.load logic, and _open_zipfile_reader. This does not support arbitrary zip files currently, but I think it only would need minor adaptations to support it.\nlibzip.py (2023) is a ctypes wrapper around libzip. But it seems very unknown?\n\n", "\nIf a line ends with string .pdf increment counter by one and after last line output counter:\nunzip -l 0532.zip | awk 'BEGIN{counter=0} /\\.pdf$/{counter++} END{print counter}'\n\nOutput:\n\n4\n\n", "\nDid you try unzip folder.zip my/file/in/folder/file1 the/other/file/in/folder/file2?\n", "\nHere is a Perl script, nested-unzip that walks through nested zip files and  prints the contents if the innermost zip file.\n#!/usr/bin/perl\n\nuse strict;\nuse warnings;\n\nuse Archive::Zip::SimpleZip qw($SimpleZipError) ;\nuse File::Basename;\nuse Text::Glob;\n\nsub walk\n{\n    my $zip = shift;\n    my $path = shift ;\n    my $depth = shift // 1 ;\n\n    my $indent = '  ' x $depth;\n    for my $p (<$path/*>)\n    {\n        my $filename = basename $p;\n        my $dir = dirname $p;\n\n        if (-d $p)\n        {\n            print $indent . \"$filename [as $filename.zip]\\n\";\n\n            my $newfh = $zip->openMember(Name => $filename . \".zip\");\n\n            my $newzip = new Archive::Zip::SimpleZip $newfh, Stream => 1\n                    or die \"Cannot create zip file '$filename.zip': $SimpleZipError\\n\" ;\n\n            walk($newzip, $p, $depth + 1);\n            $newzip->close();\n        }\n        else\n        {\n            print $indent . \"$filename\\n\";\n            $zip->add($p, Name => $filename);\n        }\n    }\n}\n\nmy $zipfile = $ARGV[0];\nmy $path = $ARGV[1] ;\n\nmy $zip = new Archive::Zip::SimpleZip $zipfile\n        or die \"Cannot create zip file '$zipfile': $SimpleZipError\\n\" ;\n\n\nprint \"$path\\n\";\nwalk($zip, $path);\n\ncreate a nested zip file to play with\n$ echo hello >hello.txt\n$ zip 1.zip hello.txt \n$ zip 2.zip 1.zip\n$ zip 3.zip 2.zip\n\nand finally running the script\n$ perl nested-unzip 3.zip \n3.zip\n  2.zip\n    1.zip\n      hello.txt\n\n", "\nI'd do it with a bash(1) one-liner:\nfor f in *.tar.gz;\\\ndo rm -rf ${f%.tar.gz} ;\\\nmkdir ${f%.tar.gz} ;\\\ntar -C ${f%.tar.gz} zxvf $f ;\\\nzip -r ${f%.tar.gz} $f.zip ;\\\nrm -rf ${f%.tar.gz} ;\\\ndone\n\nIt isn't very pretty because I'm not great at bash(1). Note that this destroys a lot of directories so be sure you know what this does before doing it.\nSee the bash(1) reference card for more details on the ${foo%bar} syntax.\n", "\nA simple bash script would be easiest, surely? That way you can just invoke the tar and zip commands.\n", "\nthe easiest solution on unix platforms may well be to use fuse and something like archivemount (libarchive), http://en.wikipedia.org/wiki/Archivemount .\n/iaw\n", "\nYou can use node.js and tar-to-zip for this purpose. All you need to do is:\nInstall node.js with nvm if you do not have it.\nAnd then install tar-to-zip with:\nnpm i tar-to-zip -g\n\nAnd use it with:\ntar-to-zip *.tar.gz\n\nAlso you can convert .tar.gz files to .zip programmatically.\nYou should install async and tar-to-zip locally:\nnpm i async tar-to-zip\n\nAnd then create converter.js with contents:\n#!/usr/bin/env node\n\n'use strict';\n\nconst fs = require('fs');\nconst tarToZip = require('tar-to-zip');\nconst eachSeries = require('async/eachSeries');\nconst names = process.argv.slice(2);\n\neachSeries(names, convert, exitIfError);\n\nfunction convert(name, done) {\n    const {stdout} = process;\n    const onProgress = (n) => {\n        stdout.write(`\\r${n}%: ${name}`);\n    };\n    const onFinish = (e) => {\n        stdout.write('\\n');\n        done();\n    };\n\n    const nameZip = name.replace(/\\.tar\\.gz$/, '.zip');    \n    const zip = fs.createWriteStream(nameZip)\n        .on('error', (error) => {\n            exitIfError(error);\n            fs.unlinkSync(zipPath);\n        });\n\n    const progress = true;\n    tarToZip(name, {progress})\n        .on('progress', onProgress)\n        .on('error', exitIfError)\n        .getStream()\n        .pipe(zip)\n        .on('finish', onFinish);\n}\n\nfunction exitIfError(error) {\n    if (!error)\n        return;\n\n    console.error(error.message);\n    process.exit(1);\n}\n\n", "\nZipfiles are handy because they offer random access to files. Tar files only sequential.\nMy solution for this conversion is this shell script, which calls itself via tar(1) \"--to-command\" option. (I prefer that rather than having 2 scripts). But I admit \"untar and zip -r\"  is faster than this, because zipnote(1) cannot work in-place, unfortunately.\n#!/bin/zsh -feu\n\n## Convert a tar file into zip:\n\nusage() {\n    setopt POSIX_ARGZERO\n    cat <<EOF\n    usage: ${0##*/} [+-h] [-v] [--] {tarfile} {zipfile}\"\n\n-v verbose\n-h print this message\nconverts the TAR archive into ZIP archive.\nEOF\n    unsetopt POSIX_ARGZERO\n}\n\nwhile getopts :hv OPT; do\n    case $OPT in\n        h|+h)\n            usage\n            exit\n            ;;\n        v)\n            # todo: ignore TAR_VERBOSE from env?\n            # Pass to the grand-child process:\n            export TAR_VERBOSE=y\n            ;;\n        *)\n            usage >&2\n            exit 2\n    esac\ndone\nshift OPTIND-1\nOPTIND=1\n\n# when invoked w/o parameters:\nif [ $# = 0 ] # todo: or stdin is not terminal\nthen\n    # we are invoked by tar(1)\n    if [ -n \"${TAR_VERBOSE-}\" ]; then echo $TAR_REALNAME >&2;fi\n    zip --grow --quiet $ZIPFILE -\n    # And rename it:\n    # fixme: this still makes a full copy, so slow.\n    printf \"@ -\\n@=$TAR_REALNAME\\n\" | zipnote -w $ZIPFILE\nelse\n    if [ $# != 2 ]; then usage >&2; exit 1;fi\n    # possibly: rm -f $ZIPFILE\n    ZIPFILE=$2 tar -xaf $1 --to-command=$0\nfi\n\n", "\nHere is a python solution based on this answer here: \nimport sys, tarfile, zipfile, glob\n\ndef convert_one_archive(file_name):\n    out_file = file_name.replace('.tar.gz', '.zip')\n    with tarfile.open(file_name, mode='r:gz') as tf:\n        with zipfile.ZipFile(out_file, mode='a', compression=zipfile.ZIP_DEFLATED) as zf:\n            for m in tf.getmembers():\n                f = tf.extractfile( m )\n                fl = f.read()\n                fn = m.name\n                zf.writestr(fn, fl)\n\nfor f in glob.glob('*.tar.gz'):\n    convert_one_archive(f)\n\n", "\nCombining the responses so far, the following bash function will compare the file listings from the zip files. The listings include verbose output (unzip -v), so checksums can be compared. Output is sorted by filename (sort -k8) to allow side by side comparison and the diff output expanded (W200) so the filenames are visible in the side by side view.\nfunction zipdiff() { diff -W200 -y <(unzip -vql \"$1\" | sort -k8) <(unzip -vql \"$2\" | sort -k8); }\n\nThis can be added to your ~/.bashrc file to be used from any console. It can be used with zipdiff a.zip b.zip. Piping the output to less or redirecting to a file is helpful for large zip files.\n", "\nunzip -l will list the contents of a zip file. You can then pass that to diff in the normal manner as mentioned here: https://askubuntu.com/questions/229447/how-do-i-diff-the-output-of-two-commands\nSo for example if you had two zip files:\nfoo.zip\nbar.zip\n\nYou could run diff -y <(unzip -l foo.zip) <(unzip -l bar.zip) to do a side-by-side diff of the contents of the two files.\nHope that helps!\n", "\nCompressed File Contents Only\nTL;DR\nThe command to diff 2 zipfiles (a.zip and b.zip) is\ndiff \\\n  <(unzip -vqq a.zip  | awk '{$2=\"\"; $3=\"\"; $4=\"\"; $5=\"\"; $6=\"\"; print}' | sort -k3 -f) \\\n  <(unzip -vqq b.zip  | awk '{$2=\"\"; $3=\"\"; $4=\"\"; $5=\"\"; $6=\"\"; print}' | sort -k3 -f)\n\nExplanation\nI was looking for a way to compare the contents of the files stored in the zipfile, but not other metadata.  Consider the following:\n$ echo foo > foo.txt\n$ zip now.zip foo.txt\n  adding: foo.txt (stored 0%)\n$ zip later.zip foo.txt\n  adding: foo.txt (stored 0%)\n$ diff now.zip later.zip \nBinary files now.zip and later.zip differ\n\nConceptually, this makes no sense; I ran the same command on the same inputs and got 2 different outputs!  The difference is the metadata, which stores the date the file was added!\n$ unzip -v now.zip \nArchive:  now.zip\n Length   Method    Size  Cmpr    Date    Time   CRC-32   Name\n--------  ------  ------- ---- ---------- ----- --------  ----\n       4  Stored        4   0% 04-08-2020 23:27 7e3265a8  foo.txt\n--------          -------  ---                            -------\n       4                4   0%                            1 file\n$ unzip -v later.zip\nArchive:  later.zip\n Length   Method    Size  Cmpr    Date    Time   CRC-32   Name\n--------  ------  ------- ---- ---------- ----- --------  ----\n       4  Stored        4   0% 04-08-2020 23:28 7e3265a8  foo.txt\n--------          -------  ---                            -------\n       4                4   0%                            1 file\n\n\nNote: I manually edited the time of the second file here from 23:27 to 23:28 for clarity.  The field in the file itself stores the value of seconds (which, in my case, differed -- a binary diff would still fail) even though they are not represented in the command's output.\n\nSo to diff the files only, we must ignore the date fields.  unzip -vqq will get us a better summary:\n$ unzip -vqq now.zip\n       4  Stored        4   0% 04-08-2020 23:27 7e3265a8  foo.txt\n\nSo let's mask out the fields (we don't care about dates or compression metrics) and sort the files:\n$ unzip -vqq now.zip  | awk '{$2=\"\"; $3=\"\"; $4=\"\"; $5=\"\"; $6=\"\"; print}' | sort -k3 -f\n4      7e3265a8 foo.txt\n\n", "\nI wanted the actual diff between the files in the zips in a readable format. Here is a bash function that I wrote for this purpose which makes use of git. This has a good UX if you already use git as part of your normal workflow and can read git diffs.\n# usage: zipdiff before.zip after.zip\nfunction zipdiff {\n  current=$(pwd)\n  before=\"$current/$1\"\n  after=\"$current/$2\"\n  tempdir=$(mktemp -d)\n  cd \"$tempdir\"\n  git init &> /dev/null\n  unzip -qq \"$before\" *\n  git add . &> /dev/null\n  git commit -m \"before\" &> /dev/null\n  rm -rf \"$tempdir/*\"  \n  yes | unzip -qq \"$after\" * &> /dev/null\n  git add .\n  git diff --cached\n  cd \"$current\"\n  rm -rf \"$tempdir\"\n}\n\n\n", "\nIf you want to diff two files (as in see the difference) you have to extract them - even if only to memory!\nIn order to see the diff of two files in two zips you can do something like this (no error checking or whatsoever):\n# define a little bash function\nfunction zipdiff () { diff -u <(unzip -p $1 $2) <(unzip -p $3 $4); }\n\n# test it: create a.zip and b.zip, each with a different file.txt\necho hello >file.txt; zip a.zip file.txt\necho world >file.txt; zip b.zip file.txt\n\nzipdiff a.zip file.txt b.zip file.txt\n--- /dev/fd/63  2016-02-23 18:18:09.000000000 +0100\n+++ /dev/fd/62  2016-02-23 18:18:09.000000000 +0100\n@@ -1 +1 @@\n-hello\n+world\n\nNote: unzip -p extracts files to pipe (stdout).\nIf you only want to know if the files are different you can inspect their checksums using \nunzip -v -l zipfile [file_to_inspect]\n\nNote: -v means verbose and -llist contents)\nunzip -v -l a.zip \nArchive:  a.zip\n Length   Method    Size  Cmpr    Date    Time   CRC-32   Name\n--------  ------  ------- ---- ---------- ----- --------  ----\n       6  Stored        6   0% 2016-02-23 18:23 363a3020  file.txt\n--------          -------  ---                            -------\n       6                6   0%                            1 file\n\nunzip -v -l b.zip \nArchive:  b.zip\n Length   Method    Size  Cmpr    Date    Time   CRC-32   Name\n--------  ------  ------- ---- ---------- ----- --------  ----\n       6  Stored        6   0% 2016-02-23 18:23 dd3861a8  file.txt\n--------          -------  ---                            -------\n       6                6   0%                            1 file \n\nIn the example above you can see that the checksums (CRC-32) are different.\nYou might also be interested in this project: \nhttps://github.com/nhnb/zipdiff\n", "\nBy postprocessing the output of zipcmp, you can recurse through the archives to obtain a more detailed summary of the differences between them.\n#!/bin/bash\n\n# process zipcmp's output to do true diffs of archive contents\n# 1. grep removes the '+++' and '---' from zipcmp's output\n# 2. awk prints the final column of output\n# 3. sort | uniq to dedupe\nfor badfile in $(zipcmp ${1?No first zip} ${2?No second zip} \\\n    | grep -Ev '^[+-]{3}' \\\n    | awk '{print $NF}' \\\n    | sort | uniq);\ndo\n    echo \"diffing $badfile\"\n    diff <(unzip -p $1 $badfile) <(unzip -p $2 $badfile) ;\ndone;\n\n\n", "\nIf you need just to check if files are equal you can compare CRC32 checksums, which are stored in archive local header fields/central directory.\n", "\nThe comp_zip tool in the open-source library Zip-Ada (available here or here) performs a comparison without extraction: contents, files of a.zip missing in b.zip and integrity check of both.\n", "\nWeb-tools such as https://www.diffnow.com/compare-files offer a quite nice visual information which files in the zip have changed:\n\nThis works very convenient for not too big zip-files without the need to install anything. This works not only for Linux but also for other operating systems including Windows and Mac.\nThe tools discussed in the other answers offer obviously more advanced options and can be faster for larger zip files.\n", "\nA quick man zip shows that you can use -O or --output-file to specify the output name. That should do you.\n", "\nHere is how I used them together:\nmysqldump -u db_user -pdb_password db_name| pv | zip > backup.zip\n\nHere is https://stackoverflow.com/a/50985546/3778130 full automatic backup script if someone is interested. \nHope it helps someone down the road.\n", "\nIn order to be able to get the progress out of pv, it needs to know the full size of the data. Unfortunately, by piping it to mysqldump it does not have that kind of data.\nI would recommend to dump the data first and transfer and restore it later.\n\nDump it.\npv mysqldump.sql | zip > ~/mysqldump.sql.zip\nscp remotehost:/home/folder/mysqldump.sql ./\nunzip it\npv mysqldump.sql | mysql -u<dbuser> -p <dbname>\n\n"], "rejected": ["\nThe best way i found\nTo always try to set password.\nIf password not exist set qwerty\n7z x -aou /tmp/archive.zip -pqwerty\n\nIf encrypted, there must be message\nencrypted archive! Wrong password\nFor additional check\ni recommend command that print technical info by 7z.\nIf password not exist set qwerty\n7z l -slt /tmp/archive.zip -pqwerty\n\nOutput must  contain Encrypted = + or encrypted archive! Wrong password\n", "\nThe best way i found\nTo always try to set password.\nIf password not exist set qwerty\n7z x -aou /tmp/archive.zip -pqwerty\n\nIf encrypted, there must be message\nencrypted archive! Wrong password\nFor additional check\ni recommend command that print technical info by 7z.\nIf password not exist set qwerty\n7z l -slt /tmp/archive.zip -pqwerty\n\nOutput must  contain Encrypted = + or encrypted archive! Wrong password\n", "\nAlthough the Title is vast but I came into similar Warning issue when trying to zip a project created by docker-compose.yml where the data of mysql is saved as folder inside my project folder.\nWhen I tried to zip, it gives same error, but zip could create an archive that contains all the files except mysql.sock. although the file exist but zip couldn't compress it. it's because the file is being used by mysql and constantly being red/written into and also it's protected.\nso whenever you're trying to compress and such files you'll get that warning. So try to find such files and exclude them if you don't need them.\nIn my case I did zip -rq .... -x '**/mysql.sock' and it worked.\n\n", "\nAlthough the Title is vast but I came into similar Warning issue when trying to zip a project created by docker-compose.yml where the data of mysql is saved as folder inside my project folder.\nWhen I tried to zip, it gives same error, but zip could create an archive that contains all the files except mysql.sock. although the file exist but zip couldn't compress it. it's because the file is being used by mysql and constantly being red/written into and also it's protected.\nso whenever you're trying to compress and such files you'll get that warning. So try to find such files and exclude them if you don't need them.\nIn my case I did zip -rq .... -x '**/mysql.sock' and it worked.\n\n", "\nAlthough the Title is vast but I came into similar Warning issue when trying to zip a project created by docker-compose.yml where the data of mysql is saved as folder inside my project folder.\nWhen I tried to zip, it gives same error, but zip could create an archive that contains all the files except mysql.sock. although the file exist but zip couldn't compress it. it's because the file is being used by mysql and constantly being red/written into and also it's protected.\nso whenever you're trying to compress and such files you'll get that warning. So try to find such files and exclude them if you don't need them.\nIn my case I did zip -rq .... -x '**/mysql.sock' and it worked.\n\n", "\nAlthough the Title is vast but I came into similar Warning issue when trying to zip a project created by docker-compose.yml where the data of mysql is saved as folder inside my project folder.\nWhen I tried to zip, it gives same error, but zip could create an archive that contains all the files except mysql.sock. although the file exist but zip couldn't compress it. it's because the file is being used by mysql and constantly being red/written into and also it's protected.\nso whenever you're trying to compress and such files you'll get that warning. So try to find such files and exclude them if you don't need them.\nIn my case I did zip -rq .... -x '**/mysql.sock' and it worked.\n\n", "\nAlthough the Title is vast but I came into similar Warning issue when trying to zip a project created by docker-compose.yml where the data of mysql is saved as folder inside my project folder.\nWhen I tried to zip, it gives same error, but zip could create an archive that contains all the files except mysql.sock. although the file exist but zip couldn't compress it. it's because the file is being used by mysql and constantly being red/written into and also it's protected.\nso whenever you're trying to compress and such files you'll get that warning. So try to find such files and exclude them if you don't need them.\nIn my case I did zip -rq .... -x '**/mysql.sock' and it worked.\n\n", "\nAlthough the Title is vast but I came into similar Warning issue when trying to zip a project created by docker-compose.yml where the data of mysql is saved as folder inside my project folder.\nWhen I tried to zip, it gives same error, but zip could create an archive that contains all the files except mysql.sock. although the file exist but zip couldn't compress it. it's because the file is being used by mysql and constantly being red/written into and also it's protected.\nso whenever you're trying to compress and such files you'll get that warning. So try to find such files and exclude them if you don't need them.\nIn my case I did zip -rq .... -x '**/mysql.sock' and it worked.\n\n", "\nAlthough the Title is vast but I came into similar Warning issue when trying to zip a project created by docker-compose.yml where the data of mysql is saved as folder inside my project folder.\nWhen I tried to zip, it gives same error, but zip could create an archive that contains all the files except mysql.sock. although the file exist but zip couldn't compress it. it's because the file is being used by mysql and constantly being red/written into and also it's protected.\nso whenever you're trying to compress and such files you'll get that warning. So try to find such files and exclude them if you don't need them.\nIn my case I did zip -rq .... -x '**/mysql.sock' and it worked.\n\n", "\nTo list/view the contents of a compressed file on a Linux host without uncompressing it (and where GZIP is installed), use the \"zcat\" command.\nzcat compressedfilename |more\n", "\nTo list/view the contents of a compressed file on a Linux host without uncompressing it (and where GZIP is installed), use the \"zcat\" command.\nzcat compressedfilename |more\n", "\nTo list/view the contents of a compressed file on a Linux host without uncompressing it (and where GZIP is installed), use the \"zcat\" command.\nzcat compressedfilename |more\n", "\nTo list/view the contents of a compressed file on a Linux host without uncompressing it (and where GZIP is installed), use the \"zcat\" command.\nzcat compressedfilename |more\n", "\nTo list/view the contents of a compressed file on a Linux host without uncompressing it (and where GZIP is installed), use the \"zcat\" command.\nzcat compressedfilename |more\n", "\nTo list/view the contents of a compressed file on a Linux host without uncompressing it (and where GZIP is installed), use the \"zcat\" command.\nzcat compressedfilename |more\n", "\nTo list/view the contents of a compressed file on a Linux host without uncompressing it (and where GZIP is installed), use the \"zcat\" command.\nzcat compressedfilename |more\n", "\nTo list/view the contents of a compressed file on a Linux host without uncompressing it (and where GZIP is installed), use the \"zcat\" command.\nzcat compressedfilename |more\n", "\nTo list/view the contents of a compressed file on a Linux host without uncompressing it (and where GZIP is installed), use the \"zcat\" command.\nzcat compressedfilename |more\n", "\nTo create a tar of modified and newly added files:\nCommand 1\n(git diff --name-only --diff-filter=M && git ls-files --others --exclude-standard) | sort -u | xargs tar cvf modified.tar\ngit diff --name-only --diff-filter=M : Lists the modified files.\ngit ls-files --others --exclude-standard : Lists untracked files.\nsort -u : Sorts and removes duplicates.\nxargs tar cvf modified.tar : Creates the tarball.\nCommand 2\ngit status -s | awk '{print $2}' | xargs tar cvf modified.tar --exclude='node_modules'\n", "\nI know that this question is a bit old but if someone stumbles upon similar problem then this bash script might be useful.\nThis script unzips recursively and retains the original folder hierarchy structure inside zip file instead of unzipping everything into the current directory.\nThis script also handles a bit pathological cases in which there are many zip files within zips or folders alternately in one zip file.\nIterating over files and folders based on this tutorial to avoid problems with white spaces, NULs, newline delimiters, etc.\nhttp://mywiki.wooledge.org/BashFAQ/001\n#!/bin/bash\n\nfunction extractZipsInCurrentDirLevel() {\n  find . -mindepth 1 -maxdepth 1 -type f -iname '*.zip' -print0 | \n  while IFS= read -r -d '' zipfile; \n  do\n    unzip \"${zipfile}\" -d \"${zipfile%.*}\"; # %.* removes file extension\n    rm \"${zipfile}\";\n  done\n}\n\nfunction extractZipsRecursively() {\n  extractZipsInCurrentDirLevel; # this can generate new folders after unzipping\n  find . -mindepth 1 -maxdepth 1 -type d -print0 | \n  while IFS= read -r -d '' folder; \n  do # call this function recursively for every child subdirectory\n    cd \"${folder}\"\n    extractZipsRecursively;\n    cd ..\n  done\n}\n\nextractZipsRecursively; # main entry function call of shell script\n\n", "\nI know that this question is a bit old but if someone stumbles upon similar problem then this bash script might be useful.\nThis script unzips recursively and retains the original folder hierarchy structure inside zip file instead of unzipping everything into the current directory.\nThis script also handles a bit pathological cases in which there are many zip files within zips or folders alternately in one zip file.\nIterating over files and folders based on this tutorial to avoid problems with white spaces, NULs, newline delimiters, etc.\nhttp://mywiki.wooledge.org/BashFAQ/001\n#!/bin/bash\n\nfunction extractZipsInCurrentDirLevel() {\n  find . -mindepth 1 -maxdepth 1 -type f -iname '*.zip' -print0 | \n  while IFS= read -r -d '' zipfile; \n  do\n    unzip \"${zipfile}\" -d \"${zipfile%.*}\"; # %.* removes file extension\n    rm \"${zipfile}\";\n  done\n}\n\nfunction extractZipsRecursively() {\n  extractZipsInCurrentDirLevel; # this can generate new folders after unzipping\n  find . -mindepth 1 -maxdepth 1 -type d -print0 | \n  while IFS= read -r -d '' folder; \n  do # call this function recursively for every child subdirectory\n    cd \"${folder}\"\n    extractZipsRecursively;\n    cd ..\n  done\n}\n\nextractZipsRecursively; # main entry function call of shell script\n\n", "\nI know that this question is a bit old but if someone stumbles upon similar problem then this bash script might be useful.\nThis script unzips recursively and retains the original folder hierarchy structure inside zip file instead of unzipping everything into the current directory.\nThis script also handles a bit pathological cases in which there are many zip files within zips or folders alternately in one zip file.\nIterating over files and folders based on this tutorial to avoid problems with white spaces, NULs, newline delimiters, etc.\nhttp://mywiki.wooledge.org/BashFAQ/001\n#!/bin/bash\n\nfunction extractZipsInCurrentDirLevel() {\n  find . -mindepth 1 -maxdepth 1 -type f -iname '*.zip' -print0 | \n  while IFS= read -r -d '' zipfile; \n  do\n    unzip \"${zipfile}\" -d \"${zipfile%.*}\"; # %.* removes file extension\n    rm \"${zipfile}\";\n  done\n}\n\nfunction extractZipsRecursively() {\n  extractZipsInCurrentDirLevel; # this can generate new folders after unzipping\n  find . -mindepth 1 -maxdepth 1 -type d -print0 | \n  while IFS= read -r -d '' folder; \n  do # call this function recursively for every child subdirectory\n    cd \"${folder}\"\n    extractZipsRecursively;\n    cd ..\n  done\n}\n\nextractZipsRecursively; # main entry function call of shell script\n\n", "\nI know that this question is a bit old but if someone stumbles upon similar problem then this bash script might be useful.\nThis script unzips recursively and retains the original folder hierarchy structure inside zip file instead of unzipping everything into the current directory.\nThis script also handles a bit pathological cases in which there are many zip files within zips or folders alternately in one zip file.\nIterating over files and folders based on this tutorial to avoid problems with white spaces, NULs, newline delimiters, etc.\nhttp://mywiki.wooledge.org/BashFAQ/001\n#!/bin/bash\n\nfunction extractZipsInCurrentDirLevel() {\n  find . -mindepth 1 -maxdepth 1 -type f -iname '*.zip' -print0 | \n  while IFS= read -r -d '' zipfile; \n  do\n    unzip \"${zipfile}\" -d \"${zipfile%.*}\"; # %.* removes file extension\n    rm \"${zipfile}\";\n  done\n}\n\nfunction extractZipsRecursively() {\n  extractZipsInCurrentDirLevel; # this can generate new folders after unzipping\n  find . -mindepth 1 -maxdepth 1 -type d -print0 | \n  while IFS= read -r -d '' folder; \n  do # call this function recursively for every child subdirectory\n    cd \"${folder}\"\n    extractZipsRecursively;\n    cd ..\n  done\n}\n\nextractZipsRecursively; # main entry function call of shell script\n\n", "\nI know that this question is a bit old but if someone stumbles upon similar problem then this bash script might be useful.\nThis script unzips recursively and retains the original folder hierarchy structure inside zip file instead of unzipping everything into the current directory.\nThis script also handles a bit pathological cases in which there are many zip files within zips or folders alternately in one zip file.\nIterating over files and folders based on this tutorial to avoid problems with white spaces, NULs, newline delimiters, etc.\nhttp://mywiki.wooledge.org/BashFAQ/001\n#!/bin/bash\n\nfunction extractZipsInCurrentDirLevel() {\n  find . -mindepth 1 -maxdepth 1 -type f -iname '*.zip' -print0 | \n  while IFS= read -r -d '' zipfile; \n  do\n    unzip \"${zipfile}\" -d \"${zipfile%.*}\"; # %.* removes file extension\n    rm \"${zipfile}\";\n  done\n}\n\nfunction extractZipsRecursively() {\n  extractZipsInCurrentDirLevel; # this can generate new folders after unzipping\n  find . -mindepth 1 -maxdepth 1 -type d -print0 | \n  while IFS= read -r -d '' folder; \n  do # call this function recursively for every child subdirectory\n    cd \"${folder}\"\n    extractZipsRecursively;\n    cd ..\n  done\n}\n\nextractZipsRecursively; # main entry function call of shell script\n\n", "\nInstead of using the python module we can use the zip featured offered by ubuntu in python. I use this because sometimes the python zip fails.\nimport os\n\nfilename = test\nos.system('7z a %s.zip %s'% (filename, filename))\n\n", "\nInstead of using the python module we can use the zip featured offered by ubuntu in python. I use this because sometimes the python zip fails.\nimport os\n\nfilename = test\nos.system('7z a %s.zip %s'% (filename, filename))\n\n", "\nInstead of using the python module we can use the zip featured offered by ubuntu in python. I use this because sometimes the python zip fails.\nimport os\n\nfilename = test\nos.system('7z a %s.zip %s'% (filename, filename))\n\n", "\nJust count the number of lines that end with .pdf, using grep -c.\nunzip -l 0532.zip | grep -c '\\.pdf$'\n\n", "\nI tried unzip zipfile.zip '*/file1.txt' and it works. Thank you!\n", "\nIf the zip files are all sequentially numbered, then you can unpack them all with a simple one-liner:\nfor i in {3301..1} ; do f=\"$i.zip\" ; unzip -q \"$f\" ; rm \"$f\" ; done \n\nAnd should you ever need it, the packing can be done with a very similar one-liner:\nf=\"flag.txt\" ; for i in {1..3301} ; do g=\"$i.zip\" ; zip -q $g $f ; rm $f ; f=\"$g\" ; done\n\n", "\nHere is script based on @Brad Campbell's answer that works on files passed as command arguments, works with other tar file types (uncompressed or the other compression types supported by tarfile), and handles directories in the source tar file.  It will also print warnings if the source file contains a symlink or hardlink, which are converted to regular files.  For symlinks, the link is resolved during conversion.  This can lead to an error if the link target is not in the tar; this is also potentially dangerous from a security standpoint, so user beware.\n#!/usr/bin/python\n\nimport sys, tarfile, zipfile, glob, re\n\ndef convert_one_archive(in_file, out_file):\n    with tarfile.open(in_file, mode='r:*') as tf:\n        with zipfile.ZipFile(out_file, mode='a', compression=zipfile.ZIP_DEFLATED) as zf:\n            for m in [m for m in tf.getmembers() if not m.isdir()]:\n                if m.issym() or m.islnk():\n                    print('warning: symlink or hardlink converted to file')\n                f = tf.extractfile(m)\n                fl = f.read()\n                fn = m.name\n                zf.writestr(fn, fl)\n\nfor in_file in sys.argv[1:]:\n    out_file = re.sub(r'\\.((tar(\\.(gz|bz2|xz))?)|tgz|tbz|tbz2|txz)$', '.zip', in_file)\n    if out_file == in_file:\n        print(in_file, '---> [skipped]')\n    else:\n        print(in_file, '--->', out_file)\n        convert_one_archive(in_file, out_file)\n\n", "\nHere is script based on @Brad Campbell's answer that works on files passed as command arguments, works with other tar file types (uncompressed or the other compression types supported by tarfile), and handles directories in the source tar file.  It will also print warnings if the source file contains a symlink or hardlink, which are converted to regular files.  For symlinks, the link is resolved during conversion.  This can lead to an error if the link target is not in the tar; this is also potentially dangerous from a security standpoint, so user beware.\n#!/usr/bin/python\n\nimport sys, tarfile, zipfile, glob, re\n\ndef convert_one_archive(in_file, out_file):\n    with tarfile.open(in_file, mode='r:*') as tf:\n        with zipfile.ZipFile(out_file, mode='a', compression=zipfile.ZIP_DEFLATED) as zf:\n            for m in [m for m in tf.getmembers() if not m.isdir()]:\n                if m.issym() or m.islnk():\n                    print('warning: symlink or hardlink converted to file')\n                f = tf.extractfile(m)\n                fl = f.read()\n                fn = m.name\n                zf.writestr(fn, fl)\n\nfor in_file in sys.argv[1:]:\n    out_file = re.sub(r'\\.((tar(\\.(gz|bz2|xz))?)|tgz|tbz|tbz2|txz)$', '.zip', in_file)\n    if out_file == in_file:\n        print(in_file, '---> [skipped]')\n    else:\n        print(in_file, '--->', out_file)\n        convert_one_archive(in_file, out_file)\n\n", "\nHere is script based on @Brad Campbell's answer that works on files passed as command arguments, works with other tar file types (uncompressed or the other compression types supported by tarfile), and handles directories in the source tar file.  It will also print warnings if the source file contains a symlink or hardlink, which are converted to regular files.  For symlinks, the link is resolved during conversion.  This can lead to an error if the link target is not in the tar; this is also potentially dangerous from a security standpoint, so user beware.\n#!/usr/bin/python\n\nimport sys, tarfile, zipfile, glob, re\n\ndef convert_one_archive(in_file, out_file):\n    with tarfile.open(in_file, mode='r:*') as tf:\n        with zipfile.ZipFile(out_file, mode='a', compression=zipfile.ZIP_DEFLATED) as zf:\n            for m in [m for m in tf.getmembers() if not m.isdir()]:\n                if m.issym() or m.islnk():\n                    print('warning: symlink or hardlink converted to file')\n                f = tf.extractfile(m)\n                fl = f.read()\n                fn = m.name\n                zf.writestr(fn, fl)\n\nfor in_file in sys.argv[1:]:\n    out_file = re.sub(r'\\.((tar(\\.(gz|bz2|xz))?)|tgz|tbz|tbz2|txz)$', '.zip', in_file)\n    if out_file == in_file:\n        print(in_file, '---> [skipped]')\n    else:\n        print(in_file, '--->', out_file)\n        convert_one_archive(in_file, out_file)\n\n", "\nHere is script based on @Brad Campbell's answer that works on files passed as command arguments, works with other tar file types (uncompressed or the other compression types supported by tarfile), and handles directories in the source tar file.  It will also print warnings if the source file contains a symlink or hardlink, which are converted to regular files.  For symlinks, the link is resolved during conversion.  This can lead to an error if the link target is not in the tar; this is also potentially dangerous from a security standpoint, so user beware.\n#!/usr/bin/python\n\nimport sys, tarfile, zipfile, glob, re\n\ndef convert_one_archive(in_file, out_file):\n    with tarfile.open(in_file, mode='r:*') as tf:\n        with zipfile.ZipFile(out_file, mode='a', compression=zipfile.ZIP_DEFLATED) as zf:\n            for m in [m for m in tf.getmembers() if not m.isdir()]:\n                if m.issym() or m.islnk():\n                    print('warning: symlink or hardlink converted to file')\n                f = tf.extractfile(m)\n                fl = f.read()\n                fn = m.name\n                zf.writestr(fn, fl)\n\nfor in_file in sys.argv[1:]:\n    out_file = re.sub(r'\\.((tar(\\.(gz|bz2|xz))?)|tgz|tbz|tbz2|txz)$', '.zip', in_file)\n    if out_file == in_file:\n        print(in_file, '---> [skipped]')\n    else:\n        print(in_file, '--->', out_file)\n        convert_one_archive(in_file, out_file)\n\n", "\nHere is script based on @Brad Campbell's answer that works on files passed as command arguments, works with other tar file types (uncompressed or the other compression types supported by tarfile), and handles directories in the source tar file.  It will also print warnings if the source file contains a symlink or hardlink, which are converted to regular files.  For symlinks, the link is resolved during conversion.  This can lead to an error if the link target is not in the tar; this is also potentially dangerous from a security standpoint, so user beware.\n#!/usr/bin/python\n\nimport sys, tarfile, zipfile, glob, re\n\ndef convert_one_archive(in_file, out_file):\n    with tarfile.open(in_file, mode='r:*') as tf:\n        with zipfile.ZipFile(out_file, mode='a', compression=zipfile.ZIP_DEFLATED) as zf:\n            for m in [m for m in tf.getmembers() if not m.isdir()]:\n                if m.issym() or m.islnk():\n                    print('warning: symlink or hardlink converted to file')\n                f = tf.extractfile(m)\n                fl = f.read()\n                fn = m.name\n                zf.writestr(fn, fl)\n\nfor in_file in sys.argv[1:]:\n    out_file = re.sub(r'\\.((tar(\\.(gz|bz2|xz))?)|tgz|tbz|tbz2|txz)$', '.zip', in_file)\n    if out_file == in_file:\n        print(in_file, '---> [skipped]')\n    else:\n        print(in_file, '--->', out_file)\n        convert_one_archive(in_file, out_file)\n\n", "\nHere is script based on @Brad Campbell's answer that works on files passed as command arguments, works with other tar file types (uncompressed or the other compression types supported by tarfile), and handles directories in the source tar file.  It will also print warnings if the source file contains a symlink or hardlink, which are converted to regular files.  For symlinks, the link is resolved during conversion.  This can lead to an error if the link target is not in the tar; this is also potentially dangerous from a security standpoint, so user beware.\n#!/usr/bin/python\n\nimport sys, tarfile, zipfile, glob, re\n\ndef convert_one_archive(in_file, out_file):\n    with tarfile.open(in_file, mode='r:*') as tf:\n        with zipfile.ZipFile(out_file, mode='a', compression=zipfile.ZIP_DEFLATED) as zf:\n            for m in [m for m in tf.getmembers() if not m.isdir()]:\n                if m.issym() or m.islnk():\n                    print('warning: symlink or hardlink converted to file')\n                f = tf.extractfile(m)\n                fl = f.read()\n                fn = m.name\n                zf.writestr(fn, fl)\n\nfor in_file in sys.argv[1:]:\n    out_file = re.sub(r'\\.((tar(\\.(gz|bz2|xz))?)|tgz|tbz|tbz2|txz)$', '.zip', in_file)\n    if out_file == in_file:\n        print(in_file, '---> [skipped]')\n    else:\n        print(in_file, '--->', out_file)\n        convert_one_archive(in_file, out_file)\n\n", "\nSome command line tools exists:\n\ndiffzips.pl written in Perl.\nzipdiff written in Java.\nzipdiff port to .NET of the previous one.\nzipcmp written in C, from libzip library\nzcmp and zdiff from gzip, can be used on zip files.\n\nI am an happy user of diffzips.pl to compare the content of epub files. diffzips.pl has also the advantage to be recursive, comparing zip file inside the parent zip.\n", "\nSome command line tools exists:\n\ndiffzips.pl written in Perl.\nzipdiff written in Java.\nzipdiff port to .NET of the previous one.\nzipcmp written in C, from libzip library\nzcmp and zdiff from gzip, can be used on zip files.\n\nI am an happy user of diffzips.pl to compare the content of epub files. diffzips.pl has also the advantage to be recursive, comparing zip file inside the parent zip.\n", "\nSome command line tools exists:\n\ndiffzips.pl written in Perl.\nzipdiff written in Java.\nzipdiff port to .NET of the previous one.\nzipcmp written in C, from libzip library\nzcmp and zdiff from gzip, can be used on zip files.\n\nI am an happy user of diffzips.pl to compare the content of epub files. diffzips.pl has also the advantage to be recursive, comparing zip file inside the parent zip.\n", "\nSome command line tools exists:\n\ndiffzips.pl written in Perl.\nzipdiff written in Java.\nzipdiff port to .NET of the previous one.\nzipcmp written in C, from libzip library\nzcmp and zdiff from gzip, can be used on zip files.\n\nI am an happy user of diffzips.pl to compare the content of epub files. diffzips.pl has also the advantage to be recursive, comparing zip file inside the parent zip.\n", "\nSome command line tools exists:\n\ndiffzips.pl written in Perl.\nzipdiff written in Java.\nzipdiff port to .NET of the previous one.\nzipcmp written in C, from libzip library\nzcmp and zdiff from gzip, can be used on zip files.\n\nI am an happy user of diffzips.pl to compare the content of epub files. diffzips.pl has also the advantage to be recursive, comparing zip file inside the parent zip.\n", "\nSome command line tools exists:\n\ndiffzips.pl written in Perl.\nzipdiff written in Java.\nzipdiff port to .NET of the previous one.\nzipcmp written in C, from libzip library\nzcmp and zdiff from gzip, can be used on zip files.\n\nI am an happy user of diffzips.pl to compare the content of epub files. diffzips.pl has also the advantage to be recursive, comparing zip file inside the parent zip.\n", "\nSome command line tools exists:\n\ndiffzips.pl written in Perl.\nzipdiff written in Java.\nzipdiff port to .NET of the previous one.\nzipcmp written in C, from libzip library\nzcmp and zdiff from gzip, can be used on zip files.\n\nI am an happy user of diffzips.pl to compare the content of epub files. diffzips.pl has also the advantage to be recursive, comparing zip file inside the parent zip.\n", "\nSome command line tools exists:\n\ndiffzips.pl written in Perl.\nzipdiff written in Java.\nzipdiff port to .NET of the previous one.\nzipcmp written in C, from libzip library\nzcmp and zdiff from gzip, can be used on zip files.\n\nI am an happy user of diffzips.pl to compare the content of epub files. diffzips.pl has also the advantage to be recursive, comparing zip file inside the parent zip.\n", "\nSome command line tools exists:\n\ndiffzips.pl written in Perl.\nzipdiff written in Java.\nzipdiff port to .NET of the previous one.\nzipcmp written in C, from libzip library\nzcmp and zdiff from gzip, can be used on zip files.\n\nI am an happy user of diffzips.pl to compare the content of epub files. diffzips.pl has also the advantage to be recursive, comparing zip file inside the parent zip.\n", "\nI am not familiar with pv, but my zip documentation states for zip to use the stdin, the dash must be specified. So i use this :\nmysqldump --user=username --password=password mydatabase | zip mydatabase.zip -\n\n", "\nI am not familiar with pv, but my zip documentation states for zip to use the stdin, the dash must be specified. So i use this :\nmysqldump --user=username --password=password mydatabase | zip mydatabase.zip -\n\n", "\nI am not familiar with pv, but my zip documentation states for zip to use the stdin, the dash must be specified. So i use this :\nmysqldump --user=username --password=password mydatabase | zip mydatabase.zip -\n\n"]}