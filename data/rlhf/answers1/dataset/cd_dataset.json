{"prompt": ["My bash script is written to go to each subfolder in the current directory: for d in */; \ndo\n    target=${d%/}\n    cd \"$target\"\ndone\nWhen I run my bash script, I am getting a cd error for a directory that exists:++ for d in '*/'\n++ target='Zelkova serrata'\n++ cd 'Zelkova serrata'\n./script7.sh: line 8: cd: Zelkova serrata: No such file or directory\nYet, in terminal command line I can do cd 'Zelkova serrata' within the same directory as the script and all is fine. Is it possible the bash script has a different source directory than the one its located in?", "My bash script is written to go to each subfolder in the current directory: for d in */; \ndo\n    target=${d%/}\n    cd \"$target\"\ndone\nWhen I run my bash script, I am getting a cd error for a directory that exists:++ for d in '*/'\n++ target='Zelkova serrata'\n++ cd 'Zelkova serrata'\n./script7.sh: line 8: cd: Zelkova serrata: No such file or directory\nYet, in terminal command line I can do cd 'Zelkova serrata' within the same directory as the script and all is fine. Is it possible the bash script has a different source directory than the one its located in?", "My bash script is written to go to each subfolder in the current directory: for d in */; \ndo\n    target=${d%/}\n    cd \"$target\"\ndone\nWhen I run my bash script, I am getting a cd error for a directory that exists:++ for d in '*/'\n++ target='Zelkova serrata'\n++ cd 'Zelkova serrata'\n./script7.sh: line 8: cd: Zelkova serrata: No such file or directory\nYet, in terminal command line I can do cd 'Zelkova serrata' within the same directory as the script and all is fine. Is it possible the bash script has a different source directory than the one its located in?", "I am wondering why cd does not work in shell script. It is as follows,#!/bin/sh\ncd test\nmkdir $(date +%d-%mm-%Y)\nWhen I run this, I get can't cd to testcd: 2: can't cd to /test\nWhy is it like this?", "I am wondering why cd does not work in shell script. It is as follows,#!/bin/sh\ncd test\nmkdir $(date +%d-%mm-%Y)\nWhen I run this, I get can't cd to testcd: 2: can't cd to /test\nWhy is it like this?", "I am wondering why cd does not work in shell script. It is as follows,#!/bin/sh\ncd test\nmkdir $(date +%d-%mm-%Y)\nWhen I run this, I get can't cd to testcd: 2: can't cd to /test\nWhy is it like this?", "I am wondering why cd does not work in shell script. It is as follows,#!/bin/sh\ncd test\nmkdir $(date +%d-%mm-%Y)\nWhen I run this, I get can't cd to testcd: 2: can't cd to /test\nWhy is it like this?", "I am wondering why cd does not work in shell script. It is as follows,#!/bin/sh\ncd test\nmkdir $(date +%d-%mm-%Y)\nWhen I run this, I get can't cd to testcd: 2: can't cd to /test\nWhy is it like this?", "I am wondering why cd does not work in shell script. It is as follows,#!/bin/sh\ncd test\nmkdir $(date +%d-%mm-%Y)\nWhen I run this, I get can't cd to testcd: 2: can't cd to /test\nWhy is it like this?", "I am wondering why cd does not work in shell script. It is as follows,#!/bin/sh\ncd test\nmkdir $(date +%d-%mm-%Y)\nWhen I run this, I get can't cd to testcd: 2: can't cd to /test\nWhy is it like this?", "I am wondering why cd does not work in shell script. It is as follows,#!/bin/sh\ncd test\nmkdir $(date +%d-%mm-%Y)\nWhen I run this, I get can't cd to testcd: 2: can't cd to /test\nWhy is it like this?", "I am wondering why cd does not work in shell script. It is as follows,#!/bin/sh\ncd test\nmkdir $(date +%d-%mm-%Y)\nWhen I run this, I get can't cd to testcd: 2: can't cd to /test\nWhy is it like this?", "I am wondering why cd does not work in shell script. It is as follows,#!/bin/sh\ncd test\nmkdir $(date +%d-%mm-%Y)\nWhen I run this, I get can't cd to testcd: 2: can't cd to /test\nWhy is it like this?", "If I have the following structure:directory/\n folder1/ <--\n folder2/\n folder3/\n ...\nHow to move to the next folder? Without to do:cd ../folderX\n", "I am working on multiple projects with similar structures and sub-directories. An example of the hierarchy would be something like this:Where X is the project name and subdirectories Main, Libs, Lx and Mx are all the same for different projects. insteding of cd'ing betweeing ong paths, I would like to create an alias (or a simple command) to jump to a directory (eg:Libs/ M2) regardless of the project name and the sub-directory that I am in (whether I am in L1 or L8, or project_red or project_yellow, I want to jump to M2). This is easy to do by creating an alias for a single project:alias goM2='cd /projects/project_red/Libs/M1/M2'\nBut I am not sure how to do this for all different project names. I can create multiple aliases but I was wondering if there is a neat way to do this. Perhaps by parsing the current directory to extract the project name and add the desired destination at the end but I am not sure how to do this.Thanks", "I am working on multiple projects with similar structures and sub-directories. An example of the hierarchy would be something like this:Where X is the project name and subdirectories Main, Libs, Lx and Mx are all the same for different projects. insteding of cd'ing betweeing ong paths, I would like to create an alias (or a simple command) to jump to a directory (eg:Libs/ M2) regardless of the project name and the sub-directory that I am in (whether I am in L1 or L8, or project_red or project_yellow, I want to jump to M2). This is easy to do by creating an alias for a single project:alias goM2='cd /projects/project_red/Libs/M1/M2'\nBut I am not sure how to do this for all different project names. I can create multiple aliases but I was wondering if there is a neat way to do this. Perhaps by parsing the current directory to extract the project name and add the desired destination at the end but I am not sure how to do this.Thanks", "I am working on multiple projects with similar structures and sub-directories. An example of the hierarchy would be something like this:Where X is the project name and subdirectories Main, Libs, Lx and Mx are all the same for different projects. insteding of cd'ing betweeing ong paths, I would like to create an alias (or a simple command) to jump to a directory (eg:Libs/ M2) regardless of the project name and the sub-directory that I am in (whether I am in L1 or L8, or project_red or project_yellow, I want to jump to M2). This is easy to do by creating an alias for a single project:alias goM2='cd /projects/project_red/Libs/M1/M2'\nBut I am not sure how to do this for all different project names. I can create multiple aliases but I was wondering if there is a neat way to do this. Perhaps by parsing the current directory to extract the project name and add the desired destination at the end but I am not sure how to do this.Thanks", "I am working on multiple projects with similar structures and sub-directories. An example of the hierarchy would be something like this:Where X is the project name and subdirectories Main, Libs, Lx and Mx are all the same for different projects. insteding of cd'ing betweeing ong paths, I would like to create an alias (or a simple command) to jump to a directory (eg:Libs/ M2) regardless of the project name and the sub-directory that I am in (whether I am in L1 or L8, or project_red or project_yellow, I want to jump to M2). This is easy to do by creating an alias for a single project:alias goM2='cd /projects/project_red/Libs/M1/M2'\nBut I am not sure how to do this for all different project names. I can create multiple aliases but I was wondering if there is a neat way to do this. Perhaps by parsing the current directory to extract the project name and add the desired destination at the end but I am not sure how to do this.Thanks", "cat ~/.last_dir/mnt/c/Users/Administrator/OneDrive/Desktop/main project/backup/main project 2\ncd cat ~/.last_dir-bash: cd: too many arguments\nI tried using backslash inside the file/mnt/c/Users/Administrator/OneDrive/Desktop/main\\ project/backup/main\\ project\\ 2\nStill same error", "cat ~/.last_dir/mnt/c/Users/Administrator/OneDrive/Desktop/main project/backup/main project 2\ncd cat ~/.last_dir-bash: cd: too many arguments\nI tried using backslash inside the file/mnt/c/Users/Administrator/OneDrive/Desktop/main\\ project/backup/main\\ project\\ 2\nStill same error", "I'm working on a simple Linux Shell, it can fork() and call execvp(), but I recently added \"build in functions\" which need to NOT fork().Here is the execution handling:    if (strcmp(cmd, \"exit\") == 0) {\n        exit = 1;\n    }\n    else if (builtIn(opt) == 0){\n        execvp(cmd, opt);\n    }\n    else {\n        pid_t pID = fork();\n\n        if (pID == 0) { \n            execvp(cmd, opt);\n        } else if (pID < 0) { \n            printf(\"\\nFailed to fork\\n\");\n        } else {\n            wait(0);\n        }\n    }\nbuiltIn() just checks the command and returns 1 or 0:int builtIn(char * opt[]) {\n\n    if (strcmp(opt[0], \"cd\")) {\n        return 1;\n    }\n    return 0;\n}\n"], "chosen": ["\nThe issue is that the current directory is \"state\" that is modified on each pass of the loop and to use the posted commands, the cwd state should not be changed by a pass.\nSpawning a subshell can fix this problem of mutating state.  The subshell inherits the state of its parent, but does not affect the parent.\ndo ( command; command ; ...; ) will spawn a new shell on each loop pass.  \nfor d in */; \ndo (\n  target=${d%/}\n  cd \"$target\"\n) done\n\n", "\nWith bullet proofing\n~$ find /full/path/to/dir -maxdepth 1 -type d -printo | xargs -0 -I% sh -c \"cd %; echo \"do some fun here\"\"\n\nYou'll escape name splitting if there is any space there.\n", "\nYou are looping through relative paths, try including the absolute path, for example:\n#!/bin/bash\n\npwd=$PWD\nfor d in */; \ndo\n    target=\"$pwd/${d%/}\"\n    cd \"$target\"\n    echo $PWD\ndone\n\n", "\nNot really relevant for this question. I had the same error message, however, I was using\ncd ~/foo/bar\n\nAfter changing this to \ncd $HOME/foo/bar\n\nit was fixed.\n", "\nI had the same problem.  Turned out the problem was \\r\\n line endings.\nTo fix it, do\ntr -d \"\\r\" < oldname.sh > newname.sh\n\nFrom http://talk.maemo.org/showthread.php?s=1cadd53b369d5408c2b9d53580a32dc4&t=67836&page=2\n", "\nI had this problem, and was very confused for a while.\nIt turns out I had set my $CDPATH environment variable, which normally allows regular cd commands to work as usual. However, I was running my script in non-interactive mode, as \"sh\" (not \"bash\"), where the behavior is a little different. It seems that a command like:\ncd subdir  # works via interactive bash; not in script run via sh.\n\nwill work as expected in my interactive login shell, bash, even when CDPATH is set. However, when I run the identical command in a script (using sh), it failed with\nmyscript.sh: line 9: cd: subdir: No such file or directory\n\nI modified it to be a relative path:\ncd ./subdir\n\nand it works! I believe the difference is in how the shell uses CDPATH. In one case, it searches both CDPATH and your current directory, but in the script it only searches CDPATH. This is similar to the behavior of PATH. If you leave . (the current directory) out of your PATH, then you have to type ./localbinary instead of just localbinary to execute that file.\nThis is my educated guess. When I set / unset CDPATH it breaks / unbreaks the cd subdir command, and cd ./subdir works in all cases for me.\n", "\nput pwd as the first line.  Then see if that directory has a test subdirectory.\nIt looks like its running from the root directory\n", "\nThe answer by Benito Ciaro is on point. I would just like to add another method that you can use to remove  \\r\\n line endings. Open the script in text-editor Sublime and in the menu \n\nGoto View \u2192 Line Endings \u2192 Unix\n\nThis will remove the '\\r' character from your script. Don't forget to save your file.\n", "\nIt depends on where the script is being executed from, if the script is in your $PATH, then it will be based off of the current directory you gave the command from (working directory).\nIf this is a script being run as a cron job, it's best to use a full directory path.\nExample:\n    cd /home/user/test\nGiving the full path will also work if the script is in your $PATH.\n", "\nWell I got it working using \"\"\nSo in your case it would be:\ncd \"test\"\n\n/Marcus\n", "\n2 is the errno for \"No such file or directory\". Are you sure the script test exists in the working directory of the script?\nYou might want to cd to a known \"good\" directory first and then cd into known child directories of that good directory.\n", "\nMake sure you are in the right directory\nRun the command bellow to known where are you\npwd\n\nShell scripts are run inside a subshell, and each subshell has its own concept of what the current directory is. The cd succeeds, but as soon as the subshell exits, you're back in the interactive shell and nothing ever changed there.\nTry this\n. myscript.sh\n\n", "\nI faced the same problem in ubuntu. My command shell is:\n$ export DIR=mydir\n\nthen execute a script file that contains:\n#!/bin/sh\ncd ~/$DIR\n\ngiving output:\ncd: 2: can't cd to ~/mydir\n\nby trying many options, at the end it can only be solved like this:\n#!/bin/sh\nWORKDIR=~/$DIR\ncd \"$WORKDIR\"\n\n", "\nYou can use the history option:\nJust push the Up Arrow key to evoke a cd command with the previously visited directory at the command line. Keeping pressing the Up Arrow key until you see the previously visited directory you need and then press [Enter].\nor\nYou might want to take advantage of the extremely handy pushd function. Pushd enables you to create a stack (a list kept in memory) of directory locations.\nYou can read thru this article which provides further information regarding pushd function.\n", "\nIf the substructure is the same for every project (differing only in the number of libs and mains under Libs and Main directories), assuming your projects directory is under your $HOME directory, and a projects directory tree like this:\n\nprojects/\n|-- project1\n|   |-- Libs\n|   |   |-- M1\n|   |   |-- M2\n|   |   `-- M3\n|   `-- Main\n|       |-- L1\n|       |-- L2\n|       `-- L3\n`-- project2\n    |-- Libs\n    |   |-- M1\n    |   |-- M2\n    |   `-- M3\n    `-- Main\n        |-- L1\n        |-- L2\n        `-- L3\n\na function (declared in your profile or whatever library you use to load during your bash sessions) like the following _go_to_project_dir will do the work as desire.\nOf course some variables have only an explanatory purpose and a lot of assumptions have been done according to your file system hierarchy.\n_go_to_project_dir() {\n  local projects_HOME=\"$HOME/projects\" # this could be configured as needed\n\n  local current_project_dir # this is only an auxiliar variable\n  printf -v current_project_dir \"%b\" \"${PWD%%/[(Libs)(Main)]*}\" # printf -v will store the formated message into the variable following -v option\n                                                                # '%%' will remove the longest occurrence of the following pattern '/[(Libs)(Main)]*' \n                                                                # from the 'PWD' variable using pathname expansion\n\n  local current_project_name\n  printf -v current_project_name \"%b\" \"${current_project_dir#${projects_HOME}/}\" # '#' will remove shortest occurrence of the following pattern \n                                                                                 # '${projects_HOME}/' from the 'current_project_dir' variable \n                                                                                 # using pathname expansion\n\n  local dir_name=\"$1\"                             # Directory where you want to go\n  local project_name=\"${2-$current_project_name}\" # this will store second parameter if provided or 'current_project_name' content elsewhere \n\n  local dir_type=\"${dir_name:0:1}\"                # this will extract the first character from your directory name but you could select a different length to match your actual pattern names\n\n  case ${dir_type} in # here we select the path according to the previously extracted directory type\n    M )\n      path_to_go=\"${projects_HOME}/${project_name}/Libs/${dir_name}\"\n    ;;\n    L )\n      path_to_go=\"${projects_HOME}/${project_name}/Main/${dir_name}\"\n    ;;\n  esac\n\n  cd \"${path_to_go}\" # And it's done\n}\n\nOf course you can extract dir_type in some different ways according to your directory name patterns, but the core idea remains the same.\n", "\nTo move between directories within the same project (and assuming that Main and Libs are the only direct children of the project root) something like this function should work.\nprojcd() {\n    projdir=$PWD # Save current directory.\n    projdir=${projdir%/Main/*} # Pull off anything after \"Main\"\n    projdir=${projdir%/Libs/*} # Pull off anything after \"Libs\"\n\n    # Find the target directory by name (more than one match will fail later).\n    tgt=$(find \"$projdir\" -name \"$1\")\n\n    if [ -z \"$tgt\" ]; then\n        echo \"No directory found for $1.\" >&2\n        exit 1\n    fi\n\n    relpath=$(sed -e 's#[^/]\\+/\\?#../#g' <<<\"${PWD#$projdir/}\")\n\n    cd \"$relpath/$tgt\"\n}\n\n", "\nIf the various L1, L2, M1, M2 were all distinct names, you could add the collection of directory paths to the CDPATH environment variable (rather than making aliases).  The feature has been discussed several times, e.g.,. How to make a custom BASH function to cd into a certain directory with autocomplete\n", "\n\nalias  subfolder name=\" eval $\\\"cd /from root  to projects folder path/` pwd | cut -d'/' -fn`/sub folder path into the\n  respective project\\\"\"\n\n1)eval command take arguments and constructs command of it.\n2) pwd | cut -d'/' -fn is used to get current Project name. sub folder path name     and root to projects folder path are constants here.n represents order of project folder from root directory \n3) Each time if you executes alias for sub folder it fetches current project name and concatenate it to root to projects folder path and sub folder path name and cd command and then executes.\nIn your case command is\nfor e.g:Libs folder\nalias  Libs=\" eval $\\\"cd /projects/\\` pwd | cut -d'/' -f3\\`/Libs\\\"\"\n", "\ncd \"$(<~/.last_dir)\"\n\nFirst, put quotes around the $(...) to make the space part of the filename.\nSecond, $(<...) is a bash construct that reads the file directly without executing cat, but is not entirely portable.\nFor a more generic, less bash-specific version, use Maxim's solution.\n", "\njust put quotation marks around your path:\n\"/mnt/c/Users/Administrator/OneDrive/Desktop/main project/backup/main project 2\"\n\nthis should work for most cases\n", "\nIn addition to Luis answer. Even if there is a program cd in /bin, it won't work since each process have their own pwd(present working directory) so it changes pwd of the cd program not its parent, main shell.\n"], "rejected": ["\nTo understand what's happening, try this and examine the output carefully:\nmkdir -p A/B/C B C D\n\necho Trying sequence: */\npwd\nfor d in */ ; do\n    cd \"$d\"\n    pwd\ndone\n\nPerhaps what you want is:\nmkdir -p A/B/C B C D\n\nexec 3<. ; orig_dir=/proc/$$/fd/3\n\necho Trying sequence: */\npwd\nfor d in */ ; do\n    cd -P \"$orig_dir/$d\"\n    pwd\ndone\ncd -P \"$orig_dir\"\npwd\n\nor if exec 3<. does not work in your shell:\nmkdir -p A/B/C B C D\n\norig_dir=$PWD\n\necho Trying sequence: */\npwd\nfor d in */ ; do\n    cd -P \"$orig_dir/$d\"\n    pwd\ndone\ncd -P \"$orig_dir\"\npwd\n\n", "\nTo understand what's happening, try this and examine the output carefully:\nmkdir -p A/B/C B C D\n\necho Trying sequence: */\npwd\nfor d in */ ; do\n    cd \"$d\"\n    pwd\ndone\n\nPerhaps what you want is:\nmkdir -p A/B/C B C D\n\nexec 3<. ; orig_dir=/proc/$$/fd/3\n\necho Trying sequence: */\npwd\nfor d in */ ; do\n    cd -P \"$orig_dir/$d\"\n    pwd\ndone\ncd -P \"$orig_dir\"\npwd\n\nor if exec 3<. does not work in your shell:\nmkdir -p A/B/C B C D\n\norig_dir=$PWD\n\necho Trying sequence: */\npwd\nfor d in */ ; do\n    cd -P \"$orig_dir/$d\"\n    pwd\ndone\ncd -P \"$orig_dir\"\npwd\n\n", "\nTo understand what's happening, try this and examine the output carefully:\nmkdir -p A/B/C B C D\n\necho Trying sequence: */\npwd\nfor d in */ ; do\n    cd \"$d\"\n    pwd\ndone\n\nPerhaps what you want is:\nmkdir -p A/B/C B C D\n\nexec 3<. ; orig_dir=/proc/$$/fd/3\n\necho Trying sequence: */\npwd\nfor d in */ ; do\n    cd -P \"$orig_dir/$d\"\n    pwd\ndone\ncd -P \"$orig_dir\"\npwd\n\nor if exec 3<. does not work in your shell:\nmkdir -p A/B/C B C D\n\norig_dir=$PWD\n\necho Trying sequence: */\npwd\nfor d in */ ; do\n    cd -P \"$orig_dir/$d\"\n    pwd\ndone\ncd -P \"$orig_dir\"\npwd\n\n", "\nI don't know much about this but I changed the permission of the folder and it worked for me\nchmod -R 775 ubuntu\n\n", "\nI don't know much about this but I changed the permission of the folder and it worked for me\nchmod -R 775 ubuntu\n\n", "\nI don't know much about this but I changed the permission of the folder and it worked for me\nchmod -R 775 ubuntu\n\n", "\nI don't know much about this but I changed the permission of the folder and it worked for me\nchmod -R 775 ubuntu\n\n", "\nI don't know much about this but I changed the permission of the folder and it worked for me\nchmod -R 775 ubuntu\n\n", "\nI don't know much about this but I changed the permission of the folder and it worked for me\nchmod -R 775 ubuntu\n\n", "\nI don't know much about this but I changed the permission of the folder and it worked for me\nchmod -R 775 ubuntu\n\n", "\nI don't know much about this but I changed the permission of the folder and it worked for me\nchmod -R 775 ubuntu\n\n", "\nI don't know much about this but I changed the permission of the folder and it worked for me\nchmod -R 775 ubuntu\n\n", "\nI don't know much about this but I changed the permission of the folder and it worked for me\nchmod -R 775 ubuntu\n\n", "\nif you are using bash, you can abuse bash-arrays and use this little bash-function:\nnextcd() {\n    if [  $# -gt 0 ]; then\n        _nextcd_dirs=(\"$@\")\n        _nextcd_root=$(pwd)\n    fi\n    cd \"${_nextcd_root}\"\n    if [ -z \"${_nextcd_dirs[0]}\" ]; then\n        echo \"no more directories to change to\" 1>&2\n    else\n        cd \"${_nextcd_dirs[0]}\"\n        _nextcd_dirs=(\"${_nextcd_dirs[@]:1}\")\n    fi\n}\n\nusage\n(the beginning of each line (up to and including the $ ) is the prompt, indicating where you currently are on the filesystem; the rest of the line (starting with nextcd) is the actual command you are running):\ndirectory/$ nextcd folder1 folder2 folder3\ndirectory/folder1/$ nextcd\ndirectory/folder2/$ nextcd\ndirectory/folder3/$ nextcd\nno more directories to change to\ndirectory/$\n\nso, the first line (nextcd folder1 folder2 folder3) calls the function with all the directories you want to iterate through. you could use wildcards (nextcd */) but keep in mind that the script doesn't check whether the arguments are actual directories before trying to change to them.\nit will change to the first argument immediately.\nwhenever you call nextcd (without any arguments), it will cd into the next of the original arguments (removing it from the list) until the list is empty (in which case it will printout an error and return to the original directory).\nwhenever you call nextcd with arguments, the old directories will be forgotten and you start anew.\nthe arguments need not be in the same directory:\nnextcd /tmp ~ /usr/bin/\n\nand can have duplicates:\nnextcd folder1 /tmp folder1 folder2\n\ncaveats\nit only works as a function in the current shell (so you cannot create a script that does this for you)\n", "\nYou can try something like https://pypi.org/project/fastcd and configure shortcuts if basic functional is not enough\n", "\nYou can try something like https://pypi.org/project/fastcd and configure shortcuts if basic functional is not enough\n", "\nYou can try something like https://pypi.org/project/fastcd and configure shortcuts if basic functional is not enough\n", "\nYou can try something like https://pypi.org/project/fastcd and configure shortcuts if basic functional is not enough\n", "\nYou need to quote the results of expanding cat ...:\ncd \"$(cat ~/.last_dir)\"\n\n", "\nYou need to quote the results of expanding cat ...:\ncd \"$(cat ~/.last_dir)\"\n\n", "\nIt's true that you need to avoid forking, but you also need to avoid executing. There is no /bin/cd that programs call to change directories.\nInstead of executing something, call the chdir system call with your path. If the user types cd /tmp, call chdir(\"/tmp\")\nThe current directory is a property of each process (as the open files or the umask value)  You cannot call a program to change your current dir, as a program is a different process and will change effectively its directory (not yours).  That's the reason of not existing a cd external command and to have to make a system call to change it.\n"]}