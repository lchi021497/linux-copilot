{"prompt": ["What is the proper way to insert tab in sed? I'm inserting a header line into a stream using sed. I could probably do a replacement of some character afterward to put in tab using regular expression, but is there a better way to do it?For example, let's say I have:some_command | sed '1itextTABtext'\nI would like the first line to look like this (text is separated by a tab character):text    text\nI have tried substituting TAB in the command above with \"\\t\", \"\\x09\", \" \" (tab itself). I have  tried it with and without double quotes and I can't get sed to insert tab in between the text.I am trying to do this in SLES 9.", "What is the proper way to insert tab in sed? I'm inserting a header line into a stream using sed. I could probably do a replacement of some character afterward to put in tab using regular expression, but is there a better way to do it?For example, let's say I have:some_command | sed '1itextTABtext'\nI would like the first line to look like this (text is separated by a tab character):text    text\nI have tried substituting TAB in the command above with \"\\t\", \"\\x09\", \" \" (tab itself). I have  tried it with and without double quotes and I can't get sed to insert tab in between the text.I am trying to do this in SLES 9.", "What is the proper way to insert tab in sed? I'm inserting a header line into a stream using sed. I could probably do a replacement of some character afterward to put in tab using regular expression, but is there a better way to do it?For example, let's say I have:some_command | sed '1itextTABtext'\nI would like the first line to look like this (text is separated by a tab character):text    text\nI have tried substituting TAB in the command above with \"\\t\", \"\\x09\", \" \" (tab itself). I have  tried it with and without double quotes and I can't get sed to insert tab in between the text.I am trying to do this in SLES 9.", "What is the proper way to insert tab in sed? I'm inserting a header line into a stream using sed. I could probably do a replacement of some character afterward to put in tab using regular expression, but is there a better way to do it?For example, let's say I have:some_command | sed '1itextTABtext'\nI would like the first line to look like this (text is separated by a tab character):text    text\nI have tried substituting TAB in the command above with \"\\t\", \"\\x09\", \" \" (tab itself). I have  tried it with and without double quotes and I can't get sed to insert tab in between the text.I am trying to do this in SLES 9.", "What is the proper way to insert tab in sed? I'm inserting a header line into a stream using sed. I could probably do a replacement of some character afterward to put in tab using regular expression, but is there a better way to do it?For example, let's say I have:some_command | sed '1itextTABtext'\nI would like the first line to look like this (text is separated by a tab character):text    text\nI have tried substituting TAB in the command above with \"\\t\", \"\\x09\", \" \" (tab itself). I have  tried it with and without double quotes and I can't get sed to insert tab in between the text.I am trying to do this in SLES 9.", "What is the proper way to insert tab in sed? I'm inserting a header line into a stream using sed. I could probably do a replacement of some character afterward to put in tab using regular expression, but is there a better way to do it?For example, let's say I have:some_command | sed '1itextTABtext'\nI would like the first line to look like this (text is separated by a tab character):text    text\nI have tried substituting TAB in the command above with \"\\t\", \"\\x09\", \" \" (tab itself). I have  tried it with and without double quotes and I can't get sed to insert tab in between the text.I am trying to do this in SLES 9.", "What is the proper way to insert tab in sed? I'm inserting a header line into a stream using sed. I could probably do a replacement of some character afterward to put in tab using regular expression, but is there a better way to do it?For example, let's say I have:some_command | sed '1itextTABtext'\nI would like the first line to look like this (text is separated by a tab character):text    text\nI have tried substituting TAB in the command above with \"\\t\", \"\\x09\", \" \" (tab itself). I have  tried it with and without double quotes and I can't get sed to insert tab in between the text.I am trying to do this in SLES 9.", "What is the proper way to insert tab in sed? I'm inserting a header line into a stream using sed. I could probably do a replacement of some character afterward to put in tab using regular expression, but is there a better way to do it?For example, let's say I have:some_command | sed '1itextTABtext'\nI would like the first line to look like this (text is separated by a tab character):text    text\nI have tried substituting TAB in the command above with \"\\t\", \"\\x09\", \" \" (tab itself). I have  tried it with and without double quotes and I can't get sed to insert tab in between the text.I am trying to do this in SLES 9.", "I have been racking my brain on this for three days now.Let's say I have a file named \"test.sh\" and I have another file called \"update.sh\" which contains some \"sed\" commands to alter or update the \"test.sh\" script.Everything works fine for all my other \"sed\" commands in the \"update.sh\" script, it updates the \"test.sh\" file just fine EXCEPT for the following...I have one line that I can't get \"sed\" to update.So I have the following line in the \"test.sh\" script...LC_ALL=C PYTHONHASHSEED=0 chroot . dpkg -i --path-include=\"/usr/share/doc/*\" \"${deb_list[@]}\"\nAnd I need it to be updated to...LC_ALL=C PYTHONHASHSEED=0 chroot . dpkg -i --force-overwrite --path-include=\"/usr/share/doc/*\" \"${deb_list[@]}\"\nMy current \"sed\" command looks like this...sed -i 's|LC_ALL=C PYTHONHASHSEED=0 chroot . dpkg -i --path-include=\"/usr/share/doc/*\" \"${deb_list[@]}\"|LC_ALL=C PYTHONHASHSEED=0 chroot . dpkg -i --force-overwrite --path-include=\"/usr/share/doc/*\" \"${deb_list[@]}\"|' test.sh\nNote: I'm using '|' as my delimiter.And it doesn't work.  I've tried all kinds of variations, escaping characters etc. and nothing is working.I would appreciate any help/clues on this.", "i was just looking around but i didn't find anything that works for me.\nI would like to insert a new line (basically an html table row) on top of the other rows.<table id=\"tfhover\" class=\"tftable\" border=\"1\">\n<tr><th>HEADER1</th><th>HEADER2</th><th>HEADER3</th><th>HEADER4</th></tr>\n<tr><td>Row:1 Cell:1</td><td>Row:1 Cell:2</td><td>Row:1 Cell:3</td><td>Row:1 Cell:4</td></tr>\n</table>\nSo, is there anyone that can suggest me a sed cmd that will insert a new:<tr><td>Row:1 Cell:1</td><td>Row:1 Cell:2</td><td>Row:1 Cell:3</td><td>Row:1 Cell:4</td>\njust below the HEADERS?Thanks!", "I have a sample file:- name: my-app\n  <<: *foo\n  installed: true\n  labels:\n    code: x.x\n    mode: y.y\n  set:\n    - name: a.b.c\n      value: abc-ab1cd2\n    - name: d.e.f\n      value: ab1cd2\nI needed sed/awk command to first match the word (my-app) in a file test.yaml and then replace the value (1234 in value: ) for -name: def and also subsequently for the value (abc-1234 in value: ) for -name: a.b.cI have tried a sed commandsed -i -e '/d.e.f/{ n; s/value: .*/value: 'value-to-change'/g }' test.yamland it just replaces the value for -name: d.e.f for all of the apps in my file. Whereas, I actually wanted to just perform the change for one app (my-app)", "Script looks as below[Unit]\nDescription=Serial Getty on %I\nDocumentation=man:agetty(8) man:systemd-getty-generator(8)\n\nType=idle\nRestart=always\nUtmpIdentifier=%I\nExecStart=-/sbin/agetty -o '-p -- \\\\u' --keep-baud 115200,38400,9600 %I $TERM\nWant to replaceExecStart=-/sbin/agetty -o '-p -- \\\\u' --keep-baud 115200,38400,9600 %I $TERM\nwith \nExecStart=-/sbin/agetty 9600 %I $TERM\nTried with these commandssed -i 's/ExecStart=-/sbin/agetty -o '-p -- \\\\u' --keep-baud 110200,38900,9680 %I $TERM/ExecStart=-/sbin/agetty 9600 %I $TERM/g' \nbut it is not working due to presence of / in search stringCan anyone please help", "I have a file like that:one_variable=/tmp\nversion=16.0\nanother_variable=jack\nand I'm trying to search and replace the value of version if it exists or append version=newvalue if it doesn't.At the moment I'm using this one-line sed command which works great on Linux. It replaces the value of version with $version_selected or appends version= with the new value.# sed -i'' -e \"/^version=/{h;s/=.*/=$version_selected/};\\${x;/^$/{s//version=$version_selected/;H};x}\" infile\nHowever, on MacOS this thrown an error:sed: 1: \"/^version=/{h;s/=. ...\": bad flag in substitute command: '}'\nHow can I make it work on both Linux and MacOS in one line? Maybe can awk do the same without any issues? Or something else? I don't work use gsed!", "I have a file like that:one_variable=/tmp\nversion=16.0\nanother_variable=jack\nand I'm trying to search and replace the value of version if it exists or append version=newvalue if it doesn't.At the moment I'm using this one-line sed command which works great on Linux. It replaces the value of version with $version_selected or appends version= with the new value.# sed -i'' -e \"/^version=/{h;s/=.*/=$version_selected/};\\${x;/^$/{s//version=$version_selected/;H};x}\" infile\nHowever, on MacOS this thrown an error:sed: 1: \"/^version=/{h;s/=. ...\": bad flag in substitute command: '}'\nHow can I make it work on both Linux and MacOS in one line? Maybe can awk do the same without any issues? Or something else? I don't work use gsed!", "Here's my inputdummy\nThis is a line\ndummy\ndummy\nthis is another line\nthe output should bedummy\n# This is a line\nThis is a line\ndummy\ndummy\n# this is another line\nthis is another line\nWhich is quite simple IMO...Just tried the sed below but this wouldn't add the pattern found. It just prints # above the line. sed -i '/^this/I i\\ '#' & ' $file  \nThoughts? Thanks.Seems like this syntax is not the right way to achieve this.", "I have file which contain followingltm pool /Common/foo_mim_pool {\n    members {\n        /Common/mim-foo-010101-1:5222 {\n            address 10.22.1.161\n        }\n    }\n}\nltm pool /Common/foo_ts_pool {\n    members {\n        /Common/ts-vx-010101-1:6698 {\n            address 10.20.1.68\n        }\n        /Common/ts-vx-010101-1:6699 {\n            address 10.20.1.68\n        }\n        /Common/ts-vx-010101-2:6698 {\n            address 10.21.1.199\n        }\n        /Common/ts-vx-010101-2:6699 {\n            address 10.21.1.199\n        }\n    }\n    monitor /Common/ts_monitor\n}\nI want to merge them in single line like following example but look like something i missing to understandltm pool /Common/foo_mim_pool { members { /Common/mim-foo-010101-1:5222 { address 10.22.1.161 } } monitor /Common/tcp}\n\nltm pool /Common/foo_ts_pool { members { /Common/ts-vx-010101-1:6698 { address 10.20.1.68 } /Common/ts-vx-010101-1:6699 { address 10.20.1.68 } /Common/ts-vx-010101-2:6698 { address 10.21.1.199 } /Common/ts-vx-010101-2:6699 { address 10.21.1.199 } } monitor /Common/ts_monitor }\nMy first attempt to use following command but its not producing what I wantpaste -d \" \" - - - - - - - - < file.txtawk 'NR%2{printf \"%s \",$0;next;}1' file.txt", "I have file which contain followingltm pool /Common/foo_mim_pool {\n    members {\n        /Common/mim-foo-010101-1:5222 {\n            address 10.22.1.161\n        }\n    }\n}\nltm pool /Common/foo_ts_pool {\n    members {\n        /Common/ts-vx-010101-1:6698 {\n            address 10.20.1.68\n        }\n        /Common/ts-vx-010101-1:6699 {\n            address 10.20.1.68\n        }\n        /Common/ts-vx-010101-2:6698 {\n            address 10.21.1.199\n        }\n        /Common/ts-vx-010101-2:6699 {\n            address 10.21.1.199\n        }\n    }\n    monitor /Common/ts_monitor\n}\nI want to merge them in single line like following example but look like something i missing to understandltm pool /Common/foo_mim_pool { members { /Common/mim-foo-010101-1:5222 { address 10.22.1.161 } } monitor /Common/tcp}\n\nltm pool /Common/foo_ts_pool { members { /Common/ts-vx-010101-1:6698 { address 10.20.1.68 } /Common/ts-vx-010101-1:6699 { address 10.20.1.68 } /Common/ts-vx-010101-2:6698 { address 10.21.1.199 } /Common/ts-vx-010101-2:6699 { address 10.21.1.199 } } monitor /Common/ts_monitor }\nMy first attempt to use following command but its not producing what I wantpaste -d \" \" - - - - - - - - < file.txtawk 'NR%2{printf \"%s \",$0;next;}1' file.txt", "Struggling again.I would like to add a line right after another one when matching some pattern and not a another one.Here's my input file :# abc def hello\n# bye hello zzzz\n# abc def hello\nExpected output is :# abc def hello\nnew line\n# bye hello zzzz\n# abc def hello\nnew line\nI want to add a line after any line of a file that starts with #, contains the word hello but not byeI read about some exclusion possibility with sed (i.e \\*<kbd>/pattern/!</kbd> \\*) but haven't managed to add it to command so far.Thanks!sed -e '/^#.\\*hello.\\*/Ia\\\\'\"new line\" $input_file\nwhere can the /bye/! thingy be included to this?", "Struggling again.I would like to add a line right after another one when matching some pattern and not a another one.Here's my input file :# abc def hello\n# bye hello zzzz\n# abc def hello\nExpected output is :# abc def hello\nnew line\n# bye hello zzzz\n# abc def hello\nnew line\nI want to add a line after any line of a file that starts with #, contains the word hello but not byeI read about some exclusion possibility with sed (i.e \\*<kbd>/pattern/!</kbd> \\*) but haven't managed to add it to command so far.Thanks!sed -e '/^#.\\*hello.\\*/Ia\\\\'\"new line\" $input_file\nwhere can the /bye/! thingy be included to this?", "I want to add the text scsi_mod.scan=sync on the end of the line that start with GRUB_CMDLINE_LINUX and append the text at the end of the line but before the character \".In case scsi_mod.scan=sync already exist then sed should not append an additional scsi_mod.scan=sync.We did the followingsed -i '/GRUB_CMDLINE_LINUX/s/$/ scsi_mod.scan=sync/' /etc/default/grub\n\nGRUB_TIMEOUT=5\nGRUB_DISTRIBUTOR=\"$(sed 's, release .*$,,g' /etc/system-release)\"\nGRUB_DEFAULT=saved\nGRUB_DISABLE_SUBMENU=true\nGRUB_TERMINAL_OUTPUT=\"console\"\nGRUB_CMDLINE_LINUX=\"crashkernel=auto rd.lvm.lv=VG/LV_root rd.lvm.lv=VG/lv_swap ipv6.disable=1 rhgb quiet scsi_mod.scan=sync\" scsi_mod.scan=sync\nGRUB_DISABLE_RECOVERY=\"true\"\nbut as you can see from the example above, we not succeeded to append the text before \".The expected results should be like thisGRUB_TIMEOUT=5\nGRUB_DISTRIBUTOR=\"$(sed 's, release .*$,,g' /etc/system-release)\"\nGRUB_DEFAULT=saved\nGRUB_DISABLE_SUBMENU=true\nGRUB_TERMINAL_OUTPUT=\"console\"\nGRUB_CMDLINE_LINUX=\"crashkernel=auto rd.lvm.lv=VG/LV_root rd.lvm.lv=VG/lv_swap ipv6.disable=1 rhgb quiet scsi_mod.scan=sync\" \nGRUB_DISABLE_RECOVERY=\"true\"\n", "I want to add the text scsi_mod.scan=sync on the end of the line that start with GRUB_CMDLINE_LINUX and append the text at the end of the line but before the character \".In case scsi_mod.scan=sync already exist then sed should not append an additional scsi_mod.scan=sync.We did the followingsed -i '/GRUB_CMDLINE_LINUX/s/$/ scsi_mod.scan=sync/' /etc/default/grub\n\nGRUB_TIMEOUT=5\nGRUB_DISTRIBUTOR=\"$(sed 's, release .*$,,g' /etc/system-release)\"\nGRUB_DEFAULT=saved\nGRUB_DISABLE_SUBMENU=true\nGRUB_TERMINAL_OUTPUT=\"console\"\nGRUB_CMDLINE_LINUX=\"crashkernel=auto rd.lvm.lv=VG/LV_root rd.lvm.lv=VG/lv_swap ipv6.disable=1 rhgb quiet scsi_mod.scan=sync\" scsi_mod.scan=sync\nGRUB_DISABLE_RECOVERY=\"true\"\nbut as you can see from the example above, we not succeeded to append the text before \".The expected results should be like thisGRUB_TIMEOUT=5\nGRUB_DISTRIBUTOR=\"$(sed 's, release .*$,,g' /etc/system-release)\"\nGRUB_DEFAULT=saved\nGRUB_DISABLE_SUBMENU=true\nGRUB_TERMINAL_OUTPUT=\"console\"\nGRUB_CMDLINE_LINUX=\"crashkernel=auto rd.lvm.lv=VG/LV_root rd.lvm.lv=VG/lv_swap ipv6.disable=1 rhgb quiet scsi_mod.scan=sync\" \nGRUB_DISABLE_RECOVERY=\"true\"\n", "What is the fastest way to extract a substring of interest from input such as the following?MsgTrace(65/26)noop:user=xxx=INBOX:cmd=534\nImapFetchComplete(56/39)user=xxxxxxxxxx\nDesired output (i.e., the :-terminated string following the string MsgTrace(65/26) in this example):noopI tried the following, but without success:egrep -i \"[a-zA-Z]+\\(.*\\)[a-z]+:\"\n", "What is the fastest way to extract a substring of interest from input such as the following?MsgTrace(65/26)noop:user=xxx=INBOX:cmd=534\nImapFetchComplete(56/39)user=xxxxxxxxxx\nDesired output (i.e., the :-terminated string following the string MsgTrace(65/26) in this example):noopI tried the following, but without success:egrep -i \"[a-zA-Z]+\\(.*\\)[a-z]+:\"\n", "I need to append a UUID ( newly generated unique for each line) to each line of a file. I would prefer to use SED or AWK for this activity and take advantage of UUIDGEN executable on my linux box. I cannot figure out how to generate the the UUID for each line and append it.I have tried:awk '{print system(uuidgen) $1} myfile.csv\nsed -i -- 's/^/$(uuidgen)/g' myfile.csv\nAnd many other variations that didn't work. Can this be done with SED or AWK, or should I be investigating another solution that is not shell script based?Sincerely,\nStephen.", "I need to append a UUID ( newly generated unique for each line) to each line of a file. I would prefer to use SED or AWK for this activity and take advantage of UUIDGEN executable on my linux box. I cannot figure out how to generate the the UUID for each line and append it.I have tried:awk '{print system(uuidgen) $1} myfile.csv\nsed -i -- 's/^/$(uuidgen)/g' myfile.csv\nAnd many other variations that didn't work. Can this be done with SED or AWK, or should I be investigating another solution that is not shell script based?Sincerely,\nStephen.", "I need to append a UUID ( newly generated unique for each line) to each line of a file. I would prefer to use SED or AWK for this activity and take advantage of UUIDGEN executable on my linux box. I cannot figure out how to generate the the UUID for each line and append it.I have tried:awk '{print system(uuidgen) $1} myfile.csv\nsed -i -- 's/^/$(uuidgen)/g' myfile.csv\nAnd many other variations that didn't work. Can this be done with SED or AWK, or should I be investigating another solution that is not shell script based?Sincerely,\nStephen.", "I need to append a UUID ( newly generated unique for each line) to each line of a file. I would prefer to use SED or AWK for this activity and take advantage of UUIDGEN executable on my linux box. I cannot figure out how to generate the the UUID for each line and append it.I have tried:awk '{print system(uuidgen) $1} myfile.csv\nsed -i -- 's/^/$(uuidgen)/g' myfile.csv\nAnd many other variations that didn't work. Can this be done with SED or AWK, or should I be investigating another solution that is not shell script based?Sincerely,\nStephen.", "I need to append a UUID ( newly generated unique for each line) to each line of a file. I would prefer to use SED or AWK for this activity and take advantage of UUIDGEN executable on my linux box. I cannot figure out how to generate the the UUID for each line and append it.I have tried:awk '{print system(uuidgen) $1} myfile.csv\nsed -i -- 's/^/$(uuidgen)/g' myfile.csv\nAnd many other variations that didn't work. Can this be done with SED or AWK, or should I be investigating another solution that is not shell script based?Sincerely,\nStephen.", "I have a file like this:[profile.one]\nusername=sam\npassword=secret\nemail=something\n\n[profile.two]\nusername=kate\npassword=secret\nemail=something\n\n[profile.three]\nusername=mary\npassword=secret\nemail=something\nI want to create a shell script that changes the password in [profile.two]. The new password will be a variable (triggered by another shell script. For example the new password will appear as $1.I know I should use sed, but after that I'm struggling to work out the syntax.", "I have a file like this:[profile.one]\nusername=sam\npassword=secret\nemail=something\n\n[profile.two]\nusername=kate\npassword=secret\nemail=something\n\n[profile.three]\nusername=mary\npassword=secret\nemail=something\nI want to create a shell script that changes the password in [profile.two]. The new password will be a variable (triggered by another shell script. For example the new password will appear as $1.I know I should use sed, but after that I'm struggling to work out the syntax.", "I have a file like this:[profile.one]\nusername=sam\npassword=secret\nemail=something\n\n[profile.two]\nusername=kate\npassword=secret\nemail=something\n\n[profile.three]\nusername=mary\npassword=secret\nemail=something\nI want to create a shell script that changes the password in [profile.two]. The new password will be a variable (triggered by another shell script. For example the new password will appear as $1.I know I should use sed, but after that I'm struggling to work out the syntax.", "I have a file like this:[profile.one]\nusername=sam\npassword=secret\nemail=something\n\n[profile.two]\nusername=kate\npassword=secret\nemail=something\n\n[profile.three]\nusername=mary\npassword=secret\nemail=something\nI want to create a shell script that changes the password in [profile.two]. The new password will be a variable (triggered by another shell script. For example the new password will appear as $1.I know I should use sed, but after that I'm struggling to work out the syntax.", "I'm stuck in using sed command.\nI try to get my network address using sed command.\nMy host is like$ hostname -I\n192.168.11.12\nI want to get only \"192.168.11.\" from the address above.\nI triedhostname -I | sed -E  's/([0-9]{1,3}\\.)([0-9]{1,3}.)([0-9]{1,3}\\.)([0-9]{1,3})$/\\1\\2\\3/'\nBut it doesn't work and I get192.168.11.12\nEven thoughecho \"192.168.11.12\" | sed -E  's/([0-9]{1,3}\\.)([0-9]{1,3}.)([0-9]{1,3}\\.)([0-9]{1,3})$/\\1\\2\\3/'\nworks properly.\nDoes anyone know what is wrong?My environment: Ubuntu 22.04.3 LTS", "I have the following data, and I need to put it all into one line.I have this:22791\n\n;\n\n14336\n\n;\n\n22821\n\n;\n\n34653\n\n;\n\n21491\n\n;\n\n25522\n\n;\n\n33238\n\n;\nI need this:22791;14336;22821;34653;21491;25522;33238;\nEDITNone of these commands is working perfectly.Most of them let the data look like this:22791\n\n;14336\n\n;22821\n\n;34653\n\n;21491\n\n;25522\n", "I have the following data, and I need to put it all into one line.I have this:22791\n\n;\n\n14336\n\n;\n\n22821\n\n;\n\n34653\n\n;\n\n21491\n\n;\n\n25522\n\n;\n\n33238\n\n;\nI need this:22791;14336;22821;34653;21491;25522;33238;\nEDITNone of these commands is working perfectly.Most of them let the data look like this:22791\n\n;14336\n\n;22821\n\n;34653\n\n;21491\n\n;25522\n", "I have the following data, and I need to put it all into one line.I have this:22791\n\n;\n\n14336\n\n;\n\n22821\n\n;\n\n34653\n\n;\n\n21491\n\n;\n\n25522\n\n;\n\n33238\n\n;\nI need this:22791;14336;22821;34653;21491;25522;33238;\nEDITNone of these commands is working perfectly.Most of them let the data look like this:22791\n\n;14336\n\n;22821\n\n;34653\n\n;21491\n\n;25522\n", "I have the following data, and I need to put it all into one line.I have this:22791\n\n;\n\n14336\n\n;\n\n22821\n\n;\n\n34653\n\n;\n\n21491\n\n;\n\n25522\n\n;\n\n33238\n\n;\nI need this:22791;14336;22821;34653;21491;25522;33238;\nEDITNone of these commands is working perfectly.Most of them let the data look like this:22791\n\n;14336\n\n;22821\n\n;34653\n\n;21491\n\n;25522\n", "I have the following data, and I need to put it all into one line.I have this:22791\n\n;\n\n14336\n\n;\n\n22821\n\n;\n\n34653\n\n;\n\n21491\n\n;\n\n25522\n\n;\n\n33238\n\n;\nI need this:22791;14336;22821;34653;21491;25522;33238;\nEDITNone of these commands is working perfectly.Most of them let the data look like this:22791\n\n;14336\n\n;22821\n\n;34653\n\n;21491\n\n;25522\n", "I have the following data, and I need to put it all into one line.I have this:22791\n\n;\n\n14336\n\n;\n\n22821\n\n;\n\n34653\n\n;\n\n21491\n\n;\n\n25522\n\n;\n\n33238\n\n;\nI need this:22791;14336;22821;34653;21491;25522;33238;\nEDITNone of these commands is working perfectly.Most of them let the data look like this:22791\n\n;14336\n\n;22821\n\n;34653\n\n;21491\n\n;25522\n", "I have the following data, and I need to put it all into one line.I have this:22791\n\n;\n\n14336\n\n;\n\n22821\n\n;\n\n34653\n\n;\n\n21491\n\n;\n\n25522\n\n;\n\n33238\n\n;\nI need this:22791;14336;22821;34653;21491;25522;33238;\nEDITNone of these commands is working perfectly.Most of them let the data look like this:22791\n\n;14336\n\n;22821\n\n;34653\n\n;21491\n\n;25522\n", "I have the following data, and I need to put it all into one line.I have this:22791\n\n;\n\n14336\n\n;\n\n22821\n\n;\n\n34653\n\n;\n\n21491\n\n;\n\n25522\n\n;\n\n33238\n\n;\nI need this:22791;14336;22821;34653;21491;25522;33238;\nEDITNone of these commands is working perfectly.Most of them let the data look like this:22791\n\n;14336\n\n;22821\n\n;34653\n\n;21491\n\n;25522\n", "I have the following data, and I need to put it all into one line.I have this:22791\n\n;\n\n14336\n\n;\n\n22821\n\n;\n\n34653\n\n;\n\n21491\n\n;\n\n25522\n\n;\n\n33238\n\n;\nI need this:22791;14336;22821;34653;21491;25522;33238;\nEDITNone of these commands is working perfectly.Most of them let the data look like this:22791\n\n;14336\n\n;22821\n\n;34653\n\n;21491\n\n;25522\n", "I have the following data, and I need to put it all into one line.I have this:22791\n\n;\n\n14336\n\n;\n\n22821\n\n;\n\n34653\n\n;\n\n21491\n\n;\n\n25522\n\n;\n\n33238\n\n;\nI need this:22791;14336;22821;34653;21491;25522;33238;\nEDITNone of these commands is working perfectly.Most of them let the data look like this:22791\n\n;14336\n\n;22821\n\n;34653\n\n;21491\n\n;25522\n", "I have the following data, and I need to put it all into one line.I have this:22791\n\n;\n\n14336\n\n;\n\n22821\n\n;\n\n34653\n\n;\n\n21491\n\n;\n\n25522\n\n;\n\n33238\n\n;\nI need this:22791;14336;22821;34653;21491;25522;33238;\nEDITNone of these commands is working perfectly.Most of them let the data look like this:22791\n\n;14336\n\n;22821\n\n;34653\n\n;21491\n\n;25522\n", "I have the following data, and I need to put it all into one line.I have this:22791\n\n;\n\n14336\n\n;\n\n22821\n\n;\n\n34653\n\n;\n\n21491\n\n;\n\n25522\n\n;\n\n33238\n\n;\nI need this:22791;14336;22821;34653;21491;25522;33238;\nEDITNone of these commands is working perfectly.Most of them let the data look like this:22791\n\n;14336\n\n;22821\n\n;34653\n\n;21491\n\n;25522\n", "I have the following data, and I need to put it all into one line.I have this:22791\n\n;\n\n14336\n\n;\n\n22821\n\n;\n\n34653\n\n;\n\n21491\n\n;\n\n25522\n\n;\n\n33238\n\n;\nI need this:22791;14336;22821;34653;21491;25522;33238;\nEDITNone of these commands is working perfectly.Most of them let the data look like this:22791\n\n;14336\n\n;22821\n\n;34653\n\n;21491\n\n;25522\n", "I have the following data, and I need to put it all into one line.I have this:22791\n\n;\n\n14336\n\n;\n\n22821\n\n;\n\n34653\n\n;\n\n21491\n\n;\n\n25522\n\n;\n\n33238\n\n;\nI need this:22791;14336;22821;34653;21491;25522;33238;\nEDITNone of these commands is working perfectly.Most of them let the data look like this:22791\n\n;14336\n\n;22821\n\n;34653\n\n;21491\n\n;25522\n", "I have the following data, and I need to put it all into one line.I have this:22791\n\n;\n\n14336\n\n;\n\n22821\n\n;\n\n34653\n\n;\n\n21491\n\n;\n\n25522\n\n;\n\n33238\n\n;\nI need this:22791;14336;22821;34653;21491;25522;33238;\nEDITNone of these commands is working perfectly.Most of them let the data look like this:22791\n\n;14336\n\n;22821\n\n;34653\n\n;21491\n\n;25522\n", "I have the following data, and I need to put it all into one line.I have this:22791\n\n;\n\n14336\n\n;\n\n22821\n\n;\n\n34653\n\n;\n\n21491\n\n;\n\n25522\n\n;\n\n33238\n\n;\nI need this:22791;14336;22821;34653;21491;25522;33238;\nEDITNone of these commands is working perfectly.Most of them let the data look like this:22791\n\n;14336\n\n;22821\n\n;34653\n\n;21491\n\n;25522\n", "I have the following data, and I need to put it all into one line.I have this:22791\n\n;\n\n14336\n\n;\n\n22821\n\n;\n\n34653\n\n;\n\n21491\n\n;\n\n25522\n\n;\n\n33238\n\n;\nI need this:22791;14336;22821;34653;21491;25522;33238;\nEDITNone of these commands is working perfectly.Most of them let the data look like this:22791\n\n;14336\n\n;22821\n\n;34653\n\n;21491\n\n;25522\n", "I have the following data, and I need to put it all into one line.I have this:22791\n\n;\n\n14336\n\n;\n\n22821\n\n;\n\n34653\n\n;\n\n21491\n\n;\n\n25522\n\n;\n\n33238\n\n;\nI need this:22791;14336;22821;34653;21491;25522;33238;\nEDITNone of these commands is working perfectly.Most of them let the data look like this:22791\n\n;14336\n\n;22821\n\n;34653\n\n;21491\n\n;25522\n", "I have the following data, and I need to put it all into one line.I have this:22791\n\n;\n\n14336\n\n;\n\n22821\n\n;\n\n34653\n\n;\n\n21491\n\n;\n\n25522\n\n;\n\n33238\n\n;\nI need this:22791;14336;22821;34653;21491;25522;33238;\nEDITNone of these commands is working perfectly.Most of them let the data look like this:22791\n\n;14336\n\n;22821\n\n;34653\n\n;21491\n\n;25522\n", "I have the following data, and I need to put it all into one line.I have this:22791\n\n;\n\n14336\n\n;\n\n22821\n\n;\n\n34653\n\n;\n\n21491\n\n;\n\n25522\n\n;\n\n33238\n\n;\nI need this:22791;14336;22821;34653;21491;25522;33238;\nEDITNone of these commands is working perfectly.Most of them let the data look like this:22791\n\n;14336\n\n;22821\n\n;34653\n\n;21491\n\n;25522\n", "I would like to reverse the complete text from the file.\nSay if the file contains:  com.e.h/float\nI want to get output as:  float/h.e.com \nI have tried the command:  rev file.txt\nbut I have got all the reverse output: taolf/h.e.moc\nIs there a way I can get the desired output. Do let me know. Thank you.\nHere is teh link of teh sample file: Sample Text", "I would like to reverse the complete text from the file.\nSay if the file contains:  com.e.h/float\nI want to get output as:  float/h.e.com \nI have tried the command:  rev file.txt\nbut I have got all the reverse output: taolf/h.e.moc\nIs there a way I can get the desired output. Do let me know. Thank you.\nHere is teh link of teh sample file: Sample Text", "I would like to reverse the complete text from the file.\nSay if the file contains:  com.e.h/float\nI want to get output as:  float/h.e.com \nI have tried the command:  rev file.txt\nbut I have got all the reverse output: taolf/h.e.moc\nIs there a way I can get the desired output. Do let me know. Thank you.\nHere is teh link of teh sample file: Sample Text", "I would like to reverse the complete text from the file.\nSay if the file contains:  com.e.h/float\nI want to get output as:  float/h.e.com \nI have tried the command:  rev file.txt\nbut I have got all the reverse output: taolf/h.e.moc\nIs there a way I can get the desired output. Do let me know. Thank you.\nHere is teh link of teh sample file: Sample Text", "I would like to reverse the complete text from the file.\nSay if the file contains:  com.e.h/float\nI want to get output as:  float/h.e.com \nI have tried the command:  rev file.txt\nbut I have got all the reverse output: taolf/h.e.moc\nIs there a way I can get the desired output. Do let me know. Thank you.\nHere is teh link of teh sample file: Sample Text", "I would like to reverse the complete text from the file.\nSay if the file contains:  com.e.h/float\nI want to get output as:  float/h.e.com \nI have tried the command:  rev file.txt\nbut I have got all the reverse output: taolf/h.e.moc\nIs there a way I can get the desired output. Do let me know. Thank you.\nHere is teh link of teh sample file: Sample Text", "I have inherited this sed script snippet that attempts to remove certain empty spaces:s/[\\s\\t]*|/|/g\ns/|[\\s\\t]*/|/g\ns/[\\s] *$//g\ns/^|/null|/g\nthat operates on a file that is around 1Gb large. This script runs for 2 hours on our unix server. Any ideas how to speed it up? Notes that the \\s stands for a space and \\t stands for a tab, the actual script uses the actual space and tab and not those symbolsThe input file is a pipe delimited file and is located locally not on the network. The 4 lines are in a file executed with sed -f", "I have inherited this sed script snippet that attempts to remove certain empty spaces:s/[\\s\\t]*|/|/g\ns/|[\\s\\t]*/|/g\ns/[\\s] *$//g\ns/^|/null|/g\nthat operates on a file that is around 1Gb large. This script runs for 2 hours on our unix server. Any ideas how to speed it up? Notes that the \\s stands for a space and \\t stands for a tab, the actual script uses the actual space and tab and not those symbolsThe input file is a pipe delimited file and is located locally not on the network. The 4 lines are in a file executed with sed -f", "I have inherited this sed script snippet that attempts to remove certain empty spaces:s/[\\s\\t]*|/|/g\ns/|[\\s\\t]*/|/g\ns/[\\s] *$//g\ns/^|/null|/g\nthat operates on a file that is around 1Gb large. This script runs for 2 hours on our unix server. Any ideas how to speed it up? Notes that the \\s stands for a space and \\t stands for a tab, the actual script uses the actual space and tab and not those symbolsThe input file is a pipe delimited file and is located locally not on the network. The 4 lines are in a file executed with sed -f", "I have inherited this sed script snippet that attempts to remove certain empty spaces:s/[\\s\\t]*|/|/g\ns/|[\\s\\t]*/|/g\ns/[\\s] *$//g\ns/^|/null|/g\nthat operates on a file that is around 1Gb large. This script runs for 2 hours on our unix server. Any ideas how to speed it up? Notes that the \\s stands for a space and \\t stands for a tab, the actual script uses the actual space and tab and not those symbolsThe input file is a pipe delimited file and is located locally not on the network. The 4 lines are in a file executed with sed -f", "I have inherited this sed script snippet that attempts to remove certain empty spaces:s/[\\s\\t]*|/|/g\ns/|[\\s\\t]*/|/g\ns/[\\s] *$//g\ns/^|/null|/g\nthat operates on a file that is around 1Gb large. This script runs for 2 hours on our unix server. Any ideas how to speed it up? Notes that the \\s stands for a space and \\t stands for a tab, the actual script uses the actual space and tab and not those symbolsThe input file is a pipe delimited file and is located locally not on the network. The 4 lines are in a file executed with sed -f", "I have inherited this sed script snippet that attempts to remove certain empty spaces:s/[\\s\\t]*|/|/g\ns/|[\\s\\t]*/|/g\ns/[\\s] *$//g\ns/^|/null|/g\nthat operates on a file that is around 1Gb large. This script runs for 2 hours on our unix server. Any ideas how to speed it up? Notes that the \\s stands for a space and \\t stands for a tab, the actual script uses the actual space and tab and not those symbolsThe input file is a pipe delimited file and is located locally not on the network. The 4 lines are in a file executed with sed -f", "I have inherited this sed script snippet that attempts to remove certain empty spaces:s/[\\s\\t]*|/|/g\ns/|[\\s\\t]*/|/g\ns/[\\s] *$//g\ns/^|/null|/g\nthat operates on a file that is around 1Gb large. This script runs for 2 hours on our unix server. Any ideas how to speed it up? Notes that the \\s stands for a space and \\t stands for a tab, the actual script uses the actual space and tab and not those symbolsThe input file is a pipe delimited file and is located locally not on the network. The 4 lines are in a file executed with sed -f", "I have inherited this sed script snippet that attempts to remove certain empty spaces:s/[\\s\\t]*|/|/g\ns/|[\\s\\t]*/|/g\ns/[\\s] *$//g\ns/^|/null|/g\nthat operates on a file that is around 1Gb large. This script runs for 2 hours on our unix server. Any ideas how to speed it up? Notes that the \\s stands for a space and \\t stands for a tab, the actual script uses the actual space and tab and not those symbolsThe input file is a pipe delimited file and is located locally not on the network. The 4 lines are in a file executed with sed -f", "I have inherited this sed script snippet that attempts to remove certain empty spaces:s/[\\s\\t]*|/|/g\ns/|[\\s\\t]*/|/g\ns/[\\s] *$//g\ns/^|/null|/g\nthat operates on a file that is around 1Gb large. This script runs for 2 hours on our unix server. Any ideas how to speed it up? Notes that the \\s stands for a space and \\t stands for a tab, the actual script uses the actual space and tab and not those symbolsThe input file is a pipe delimited file and is located locally not on the network. The 4 lines are in a file executed with sed -f", "I have inherited this sed script snippet that attempts to remove certain empty spaces:s/[\\s\\t]*|/|/g\ns/|[\\s\\t]*/|/g\ns/[\\s] *$//g\ns/^|/null|/g\nthat operates on a file that is around 1Gb large. This script runs for 2 hours on our unix server. Any ideas how to speed it up? Notes that the \\s stands for a space and \\t stands for a tab, the actual script uses the actual space and tab and not those symbolsThe input file is a pipe delimited file and is located locally not on the network. The 4 lines are in a file executed with sed -f", "I try to convert filenames and remove special chars and whitespaces.\nFor some reasons my SED regex don't work if I declare dash and slashes not to be replaced.Input: /path/to/file 20-456 (1).jpg expected output: /path/to/file_20-456_1.jpgExample:echo \"/path/to/file 20-456 (1).jpg\" | sed -e 's/ /_/g' -e 's/[^0-9a-zA-Z\\.\\_\\-\\/]//g'Output:/path/to/file_20456_1.jpgSo the dash isn't in.\nWhen I try this command:echo \"/path/to/file 20-456 (1).jpg\" | sed -e 's/ /_/g' -e 's/[^0-9a-zA-Z\\.\\_\\-]//g'Output:pathtofile_20-456_1.jpgthe dash is there but without the directory slashes I can't move the files.\nI wonder why the replacment with dash didn't work anymore if I add \\/ into regex pattern.Any suggestions?", "Good Day!I have files in Ubuntu like:\nZAF_MM_CYCLE_K051.XLS\nZAF_MM_CYCLE_K052.XLS\nZAF_MM_CYCLE_K053.XLS\nwhich are copy of a file \"ZAF_MM_CYCLE_K036\", the code of file is K036File contents are the sameLOADED_AGRS   ZAF_MM_CYCLE_K036\nAGG_DEFINE    200ZAF_MM_CYCLE_K036  $WERKS  K036                                          \nAGG_1521      200ZAF_MM_CYCLE_K036           \nHere I have to replace the code wiith its own code according to filename.for example:file: ZAF_MM_CYCLE_K051.XLSits code is K051, and I have to replace K036 to K051, so that content of the file would be:LOADED_AGRS   ZAF_MM_CYCLE_K051\nAGG_DEFINE    200ZAF_MM_CYCLE_K051  $WERKS  K051                                          \nAGG_1521      200ZAF_MM_CYCLE_K051       \nCan anyone help out, please?", "Good Day!I have files in Ubuntu like:\nZAF_MM_CYCLE_K051.XLS\nZAF_MM_CYCLE_K052.XLS\nZAF_MM_CYCLE_K053.XLS\nwhich are copy of a file \"ZAF_MM_CYCLE_K036\", the code of file is K036File contents are the sameLOADED_AGRS   ZAF_MM_CYCLE_K036\nAGG_DEFINE    200ZAF_MM_CYCLE_K036  $WERKS  K036                                          \nAGG_1521      200ZAF_MM_CYCLE_K036           \nHere I have to replace the code wiith its own code according to filename.for example:file: ZAF_MM_CYCLE_K051.XLSits code is K051, and I have to replace K036 to K051, so that content of the file would be:LOADED_AGRS   ZAF_MM_CYCLE_K051\nAGG_DEFINE    200ZAF_MM_CYCLE_K051  $WERKS  K051                                          \nAGG_1521      200ZAF_MM_CYCLE_K051       \nCan anyone help out, please?", "I want to replace a newline byte on a single-byte file with a sed-(mar. d\u00e9c. 05 11:45:16)--(moddgsa001.a2297:/home/marc/avirer)-\n[root] # ls -l\ntotal 4\n-rw-r--r--. 1 root root 1  5 d\u00e9c.  11:45 saut-de-ligne_UTF-8\n-(mar. d\u00e9c. 05 11:53:52)--(moddgsa001.a2297:/home/marc/avirer)-\n[root] # od -h saut-de-ligne_UTF-8\n0000000 000a\n0000001\n-(mar. d\u00e9c. 05 11:53:57)--(moddgsa001.a2297:/home/marc/avirer)-\n[root] #  sed -i 's/\\x0a/\\x25/g' saut-de-ligne_UTF-8\n-(mar. d\u00e9c. 05 11:54:06)--(moddgsa001.a2297:/home/marc/avirer)-\n[root] # od -h saut-de-ligne_UTF-8\n0000000 000a\n0000001\nBut this does nothing. I don't understand. Any ideas?"], "chosen": ["\nAssuming bash (and maybe other shells will work too):\nsome_command | sed $'1itext\\ttext'\n\nBash will process escapes, such as \\t, inside $' ' before passing it as an arg to sed.\n", "\nYou can simply use the sed i command correctly:\nsome_command | sed '1i\\\ntext    text2'\n\nwhere, as I hope it is obvious, there is a tab between 'text' and 'text2'.  On MacOS X (10.7.2), and therefore probably on other BSD-based platforms, I was able to use:\nsome_command | sed '1i\\\ntext\\ttext2'\n\nand sed translated the \\t into a tab.\nIf sed won't interpret \\t and inserting tabs at the command line is a problem, create a shell script with an editor and run that script.\n", "\nAs most answers say, probably literal tab char is the best.\ninfo sed saying \"\\t is not portable.\" :\n...\n'\\CHAR'\n    Matches CHAR, where CHAR is one of '$', '*', '.', '[', '\\', or '^'.\n    Note that the only C-like backslash sequences that you can\n    portably assume to be interpreted are '\\n' and '\\\\'; in particular\n    '\\t' is not portable, and matches a 't' under most implementations\n    of 'sed', rather than a tab character.\n...\n\n", "\nescape the tab character: \nsed -i '/<setup>/ a \\\\tmy newly added line' <file_name>\n\nNOTE: above we have two backslashes (\\) first one is for escaping () and the next one is actual tab char (\\t)\n", "\nSed can do this, but it's awkward:\n% printf \"1\\t2\\n3\\t4\\n\" | sed '1i\\\\\nfoo bar\\\\\n'\nfoo bar\n1   2\n3   4\n$\n\n(The double backslashes are because I'm using tcsh as my shell; if you use bash, use single backslashes)\nThe space between foo and bar is a tab, which I typed by prepending it with CtrlV.  You'll also need to prepend the newlines inside your single quotes with a CtrlV.\nIt would probably be simpler/clearer to do this with awk:\n$ printf \"1\\t2\\n3\\t4\\n\" | awk 'BEGIN{printf(\"foo\\tbar\\n\");} {print;}'\n\n", "\nTo illustrate the fact the BRE syntax for sed does mention that \\t is not portable, Git 2.13 (Q2 2017) gets rid of it.\nSee commit fba275d (01 Apr 2017) by Junio C Hamano (gitster).\n(Merged by Junio C Hamano -- gitster -- in commit 3c833ca, 17 Apr 2017) \n\ncontrib/git-resurrect.sh: do not write \\t for HT in sed scripts\nJust like we did in 0d1d6e5 (\"t/t7003: replace \\t with literal tab\n  in sed expression\", 2010-08-12, Git 1.7.2.2), avoid writing \"\\t\" for HT in sed scripts, which is not portable.\n\n-   sed -ne 's~^\\([^ ]*\\) .*\\tcheckout: moving from '\"$1\"' .*~\\1~p'     \n+   sed -ne 's~^\\([^ ]*\\) .*     checkout: moving from '\"$1\"' .*~\\1~p'\n                            ^^^^\n                             |\n                        (literal tab)\n\n", "\nI found an alternate way to insert a tab by using substitution.\nsome_command | sed '1s/^/text\\ttext\\n/'\nI still do not know of a way to do it using the insert method.\n", "\nThis command replace old to new in file.txt:\nsed -i '' 's/old/new/' file.txt\n\nThis command will add a tab for new:\nsed -i '' $'s/old/\\tnew/' file.txt\n\nThis command replaces an entire string:\nsed -i '' 's/.*old.*/new/' file.txt\n\n", "\nWhat you need:\nsed -i 's/chroot.*dpkg -i/& --force-overwrite/' file\n\nSimple and efficient.\nThe & is what matched in the left part.\nResult:\nLC_ALL=C PYTHONHASHSEED=0 chroot . dpkg -i --force-overwrite --path-include=\"/usr/share/doc/*\" \"${deb_list[@]}\"\n\n", "\nUsing Perl\n~$ perl -pe 'BEGIN {$str = q(<table id=\"tfhover\" class=\"tftable\" border=\"1\">)};  \\\n             s{\\Q$str\\E}{$&\\n<tr><td>Row:1 Cell:1</td><td>Row:1 Cell:2<td><td>Row:1 Cell:3</td><td>Row:1 Cell:4</td>};'  file\n\n#OR\n\n~$ perl -pe 'BEGIN {$str = q(<table id=\"tfhover\" class=\"tftable\" border=\"1\">)};  \\\n             s{(\\Q$str\\E)}{$1\\n<tr><td>Row:1 Cell:1</td><td>Row:1 Cell:2<td><td>Row:1 Cell:3</td><td>Row:1 Cell:4</td>};'  file\n\nUsing Raku (formerly known as Perl_6)\n~$ raku -pe 'BEGIN my $str = Q[<table id=\"tfhover\" class=\"tftable\" border=\"1\">];  \\\n             s{$str} = \"$/\\n<tr><td>Row:1 Cell:1</td><td>Row:1 Cell:2<td><td>Row:1 Cell:3</td><td>Row:1 Cell:4</td>\";'  file\n\n#OR\n\n~$ raku -pe 'BEGIN my $str = Q[<table id=\"tfhover\" class=\"tftable\" border=\"1\">];  \\\n             s{($str)} = \"$0\\n<tr><td>Row:1 Cell:1</td><td>Row:1 Cell:2<td><td>Row:1 Cell:3</td><td>Row:1 Cell:4</td>\";'  file\n\n\nAbove are answers coded in Perl and Raku. In both languages $str is assigned a single-quoted (i.e. non-interpolated) target line to insert after--the OP's first line of text. So to clarify (similar to the answer by @clt60), HTML isn't being \"parsed\" here--instead a single line of HTML is matched with a literal string, and a \\n newline and new text is inserted afterwards (e.g. \\nnewtextinserted).\nThe -pe command-line flags in both Perl and Raku invoke sed-like behavior, and answers in both languages use a match or capture variable in the replacement half of the s/// operator (followed by the aforementioned \\nnewtextinserted).\n\nHere in Perl to save on backslashing custom delimiters are used, i.e. s{\u2026}{\u2026}. Same in Raku, but also the use of custom delimiters has changed somewhat: in addition to things like s!foo!bar! you can use the s{\u2026} = \"\u2026\" format. To explain from the Raku docs: \"Paired characters, like curly braces, are used only on the match portion, with the substitution given by assignment (of anything: a string, a routine call, etc.).\"\n\nIn Perl the LHS (recognition domain) of the s/// operator is effectively a double-quoted string. So to disable regex interpolation the \\Q\u2026\\E form must be used in Perl.  By comparison, note that 1). Raku escapes characters in single-quoted strings by default, 2).  Raku requires the my keyword, and 3). in Raku quoting constructs square brackets are preferable.\n\nIn Raku, Q is the plainest-of-the-plain quoting construct: even backslashes that would otherwise truncate the string are not honored (use q if you want internal backslashes escaped). Quoting  constructs are quite varied/plentiful in Raku: see the final URL at bottom.\n\n\n\nSample Input:\n<table id=\"tfhover\" class=\"tftable\" border=\"1\">\n<tr><th>HEADER1</th><th>HEADER2</th><th>HEADER3</th><th>HEADER4</th></tr>\n<tr><td>Row:1 Cell:1</td><td>Row:1 Cell:2</td><td>Row:1 Cell:3</td><td>Row:1 Cell:4</td></tr>\n</table>\n\nSample Output (all four code examples):\n<table id=\"tfhover\" class=\"tftable\" border=\"1\">\n<tr><td>Row:1 Cell:1</td><td>Row:1 Cell:2</td><td>Row:1 Cell:3</td><td>Row:1 Cell:4</td>\n<tr><th>HEADER1</th><th>HEADER2</th><th>HEADER3</th><th>HEADER4</th></tr>\n<tr><td>Row:1 Cell:1</td><td>Row:1 Cell:2</td><td>Row:1 Cell:3</td><td>Row:1 Cell:4</td></tr>\n</table>\n\n\nhttps://perldoc.perl.org/perlre\nhttps://perldoc.perl.org/functions/quotemeta\nhttps://docs.raku.org/language/regexes\nhttps://docs.raku.org/language/quoting\n", "\nYou should use a YAML parser!\n\nThe reason why you shouldn't use a text parser like sed is that the YAML format has a logical structure that is represented by special symbols and formatting (like - for sequences, or indentation for hierarchy), which is unknown to text parsers (unless you write a full YAML parser in them). YAML allows various stylings like quotes or compacting subtrees to a single line, etc. Text parsers only see that actual representation, while YAML parsers robustly operate on logical relations, regardless of the formatting.\n\nHere's an example filter that works in a number of command-line YAML processors (see below). select(.name == \"my-app\").set[] traverses to every item under a field named set, which in turn is a sibling of a field named name with the value of my-app. Each of these items is updated by select(.name == \"d.e.f\").value = 1234 and select(.name == \"a.b.c\").value = \"abc-1234\" which set the value of a field named value that by itself is a sibling of a field named name with a specified value. All of this is wrapped into a map, as the top-level structure appears to be a sequence (containing several \"apps\"), so each of them can be tested for applicability.\nmap(select(.name == \"my-app\").set[] |= (\n  select(.name == \"d.e.f\").value = 1234 |\n  select(.name == \"a.b.c\").value = \"abc-1234\"\n))\n\nUse it with mikefarah/yq as yq '\u2026' test.yaml, or with kislyuk/yq as yq -y '\u2026' test.yaml, or with itchyny/gojq as gojq --yaml-input --yaml-output '\u2026' test.yaml.\n", "\nsed 's/Hello/Greetings/' example.txt\nThis command uses the s (substitute) command to replace the first occurrence of \"Hello\" with \"Greetings\" in each line of the file. However, it doesn't modify the file itself;\n", "\nUsing this small bash script I am demonstrating .. Replace the entire line by using wildcards .* Then just replace it with version=$version_selected\nAlso I find it easier just to grep whether the file contains the string you are looking for -- Append then exit the process if it's the case, else replace with selected version.\nversion.txt\none_variable=/tmp\nversion=16.0\nanother_variable=jack\n\nversion.sh\n#!/bin/bash\n\nfile=version.txt\nversion_selected=17.56\n\n#Check to see if exists .. If not append\nif ! grep -q \"version=\" \"$file\"; then\n  echo \"version=$version_selected\" >> $file;\n  exit 1;\nfi\n\nsed -i \"s/version.*/version=$version_selected/g\" \"$file\"\n\nYour replaced contents in version.txt should be:\none_variable=/tmp\nversion=17.56\nanother_variable=jack\n\n", "\nThis job is more suitable for awk than sed.\nYou may use this much more readable solution:\nawk -v newver='18.0' '\nBEGIN{FS=OFS=\"=\"}\n$1 == \"version\" {\n   $2 = newver\n   ver = 1\n}\n1\nEND {\n   if (!ver)\n      print \"version\", newver\n}' file\n\none_variable=/tmp\nversion=18.0\nanother_variable=jack\n\nIf you want to save changes in the same file then there are 2 ways:\n\nFor gnu awk use -i inplace\n\nawk -i inplace -v newver='18.0' 'BEGIN{FS=OFS=\"=\"} $1 == \"version\" {$2 = newver; ver=1} 1; ENDFILE { if (!ver) print \"version\", newver }' file\n\n\nFor non-gnu awk use:\n\nawk -v newver='18.0' 'BEGIN{FS=OFS=\"=\"} $1 == \"version\" {$2 = newver; ver=1} 1; END { if (!ver) print \"version\", newver }' file > _tmp &&\nmy _tmp file\n\n\n", "\nThis might work for you (GNU sed):\nsed '/dummy/I!s/.*/# &\\n&/' file\n\nIf a line does not contain the word dummy, then duplicate the line with the first duplicate prepended with # .\n", "\nA couple of other techniques:\n\nprint each line without a newline, counting braces.\nawk '\n    {sub(/^\\s+/, \" \"); printf \"%s\", $0} # trims leading whitespace\n    $NF == \"{\" {level++} \n    $1 == \"}\" {level--} \n    level == 0 && NR > 1 {printf \"\\n\"}\n'\n\nltm pool /Common/foo_mim_pool { members { /Common/mim-foo-010101-1:5222 { address 10.22.1.161 } }}\nltm pool /Common/foo_ts_pool { members { /Common/ts-vx-010101-1:6698 { address 10.20.1.68 } /Common/ts-vx-010101-1:6699 { address 10.20.1.68 } /Common/ts-vx-010101-2:6698 { address 10.21.1.199 } /Common/ts-vx-010101-2:6699 { address 10.21.1.199 } } monitor /Common/ts_monitor}\n\n\nSlurp the whole file as a single string, normalize all whitespace (including newlines) to a single space, and add newlines where needed. This requires the word ltm to be constant for every record and only at the start of the record.\nawk -v RS=\"\" '{gsub(/\\s+/, \" \"); gsub(/\\} ltm /, \"}\\nltm \"); print}'\n\n\n\n", "\nThis might work for you (GNU sed):\nsed '/^ltm/{:a;N;/\\n}$/!ba;y/\\n/ /;s/\\s\\+/ /g}' file\n\nFocus on lines beginning ltm and then gather up all subsequent lines until one starting and containing } only.\nThen replace all newlines by a space and all multiple white space by a single space.\n", "\n\nwhere can the /bye/! thingy be included to this?\n\nSed is a programming language, technically. Start a block and check within.\nThe real issue is that a reads the whole next line. So you have to like start another one to close }.\nsed -e '/^#.*hello.*/I{ /bye/!a\\' -e \"new line\" -e '}' \"$input_file\"\n\nThe syntax of a command is:\na\\\ntext\n\nTechnically, there has to be newline in the sed script for text. I see a\\text works anyway, but technically it is not valid. GNU sed also allows for just a text.\nPrefer to quote variable expansion in shell. Check your scripts with shellcheck.\n", "\nThis might work for you (GNU sed):\nsed '/bye/b;/^#.*hello/a\\new line' file\n\nIf a line contains bye we are not interested so bail out.\nIf a line begins # and then contains hello add a line containing new line.\n", "\nsed -i '/GRUB_CMDLINE_LINUX/s/\"$/ scsi_mod.scan=sync\"/' /etc/default/grub\n", "\nWith GNU sed you can try:\nsed -i '/GRUB_CMDLINE_LINUX/{/\\<scsi_mod.scan=sync\"$/!s/\"$/ scsi_mod.scan=sync\"/}' /etc/default/grub\n\nIf you want to skip the additio if scsi_mod.scan=sync is anywhere in the line, not only at the end:\nsed -i '/GRUB_CMDLINE_LINUX/{/\\<scsi_mod.scan=sync\\>/!s/\"$/ scsi_mod.scan=sync\"/}' /etc/default/grub\n\n", "\nLittle quick and dirty test on a 2469120 lines text of such a sample entry give grep -PO as winner\ntime sed -n -e 's/^MsgTrace[^)]\\{4,\\})//;t M' -e 'b' -e ':M' -e 's/:.*//p' YourFile >/dev/null\nreal    0m7.61s\nuser    0m7:10s\nsys     0m0.13s\n\ntime awk -F ':' '/^MsgTrace/{ sub( /.*)/, \"\", $1); print $1}' YourFile >/dev/null\nreal    0m17.43s\nuser    0m16.19s\nsys     0m0.17s\n\ntime grep -Po  \"[a-zA-Z]\\(.*\\)\\K[a-z]+(?=:)\" YourFile >/dev/null\nreal    0m6.72s\nuser    0m6.23s\nsys     0m0.11s\n\ntime sed -n 's/[[:alpha:]]*([^)]*)\\([[:lower:]]*\\):.*/\\1/p' YourFile >/dev/null\nreal    0m17.43s\nuser    0m16.29s\nsys     0m0.12s\n\ntime grep -Po '(?<=MsgTrace\\(65/26\\)).*?(?=:)' YourFile >/dev/null\nreal    0m16.38s\nuser    0m15.22s\nsys     0m0.15s\n\nfor @EdMorton question (i redo the same original sed to have compare value in same context of machine load). The exact string is lot faster, i imagine that sed try several combination before selecting which is the longest one for all criteria where a .*l give lot more possibility than pool is full\ntime sed -n -e 's/^MsgTrace([^)]\\{3,\\})//;T' -e 's/:.*//p' YourFile >/dev/null\nreal    0m7.28s\nuser    0m6.60s\nsys     0m0.13s\n\ntime sed -n -e 's/^[[:alpha:]]*([^)]\\{3,\\})//;T' -e 's/:.*//p' YourFile >/dev/null\nreal    0m10.44s\nuser    0m9.67s\nsys     0m0.14s\n\ntime sed -n -e 's/^[[:alpha:]]*([^)]*)//;T' -e 's/:.*//p' YourFile >/dev/null\n\nreal    0m10.54s\nuser    0m9.75s\nsys     0m0.11s\n\n", "\nYou could try this:\n$ sed -n 's/[[:alpha:]]*([^)]*)\\([[:lower:]]*\\):.*/\\1/p' file\nnoop\n\nIt's portable to all POSIX seds and doesn't employ PCREs, just BREs, so the regexp matching part at least should be fast.\nAlternatively, using GNU awk for the 3rd arg to match():\n$ awk 'match($0,/[[:alpha:]]*\\([^)]*)([[:lower:]]*):/,a){print a[1]}' file\nnoop\n\n", "\nJust tweaking the syntax on your attempt, something like this should work:\nawk '(\"uuidgen\" | getline uuid) > 0 {print uuid, $0} {close(\"uuidgen\")}' myfile.csv\n\nFor example:\n$ cat file\na\nb\nc\n\n$ awk '(\"uuidgen\" | getline uuid) > 0 {print uuid, $0} {close(\"uuidgen\")}' file\n52a75bc9-e632-4258-bbc6-c944ff51727a a\n24c97c41-d0f4-4cc6-b0c9-81b6d89c5b77 b\n76de9987-a60f-4e3b-ba5e-ae976ab53c7b c\n\nThe right solution is to use other shell commands though since the awk isn't buying you anything:\n$ xargs -n 1 printf \"%s %s\\n\" $(uuidgen) < file\n763ed28c-453f-47f4-9b1b-b2f972b2cc7d a\n763ed28c-453f-47f4-9b1b-b2f972b2cc7d b\n763ed28c-453f-47f4-9b1b-b2f972b2cc7d c\n\n", "\nTry this\nawk '{ \"uuidgen\" |& getline u; print u, $1}' myfile.csv\n\nif you want to append instead of prepend change the order of print.\n", "\nUsing xargs is simpler here:\npaste -d \" \" myfile.csv <(xargs -I {} uuidgen {} < myfile.csv)\n\nThis will call uuidgen for each line of myfile.csv\n", "\nYou can use paste and GNU sed: \npaste <(sed 's/.*/uuidgen/e' file) file\nThis uses the GNU execute extension e to generate a UUID per line, then paste pastes the text back together. Use the -d paste flag to change the delimiter from the default tab, to whatever you want.\n", "\nUsing bash, this will create a file outfile.txt with a concatenated uuid:\nNOTE: Please run which bash to verify the location of your copy of bash on your system.  It may not be located in the same location used in the script below.\n#!/usr/local/bin/bash\n\nwhile IFS= read -r line\ndo\n    uuid=$(uuidgen)\n    echo \"$line $uuid\" >> outfile.txt\ndone < myfile.txt\n\nmyfile.txt:\njohn,doe\nmary,jane\nalbert,ellis\nbob,glob\nfig,newton\n\noutfile.txt\njohn,doe 46fb31a2-6bc5-4303-9783-85844a4a6583\nmary,jane a14bb565-eea0-47cd-a999-90f84cc8e1e5\nalbert,ellis cfab6e8b-00e7-420b-8fe9-f7655801c91c\nbob,glob 63a32fd1-3092-4a72-8c24-7b01c400820c\nfig,newton 63d38ad9-5553-46a4-9f24-2e19035cc40d\n\n", "\nsed doesn't understand literal strings and so any sed solution that uses regexp replacement will fail given various values of the password (unless you sanitize every replacement metacharacter and delimiter it could contain or use a solution like @potong's that reads the password from a \"file\".\nAwk, on the other hand, does understand literal strings, e.g. using any POSIX awk:\n$ cat tst.sh\n#!/usr/bin/env bash\n\npass=\"$1\" awk '\n    /^\\[/ { f=($0 == \"[profile.two]\") }\n    f && match($0,/^password=/) { $0=substr($0,RSTART,RLENGTH) ENVIRON[\"pass\"] }\n    { print }\n' file\n\n\n$ ./tst.sh '`~!@#$%^&*()_+-   ={}|[]\\:\";'\\''<>?,./'\n[profile.one]\nusername=sam\npassword=secret\nemail=something\n\n[profile.two]\nusername=kate\npassword=`~!@#$%^&*()_+-   ={}|[]\\:\";'<>?,./\nemail=something\n\n[profile.three]\nusername=mary\npassword=secret\nemail=something\n\n", "\nsed -i \"/\\[profile\\.two]/{n;n;s/secret/$1/}\" fileName\n\nNote: [ and . characters need to be escaped to match literal\n\n\nNote: the meaning of the two $1 is not the same. The $1 within the changePasswd function receives the first argument passed to the function; and $1 for changePasswd call receives the first argument passed to the script.\ntest result:\n\n", "\nawk is generally better at this sort of thing than sed.  eg\n$ foo() {\n    awk '\n    $1 == \"[profile.two]\" {gsub(\"\\npassword=[^\\n]*\", \"\\npassword=\" new_password)}1\n    ' new_password=\"$1\" RS= ORS='\\n\\n' input; }\n$ foo banana\n[profile.one]\nusername=sam\npassword=secret\nemail=something\n\n[profile.two]\nusername=kate\npassword=banana\nemail=something\n\n[profile.three]\nusername=mary\npassword=secret\nemail=something\n\nHere, I've created the function foo for the sole purpose of getting the password into $1.  It would be cleaner to use a named variable, and this is just a cheap literary trick to show how to use the command in a script.\nawk has the nice feature of allowing you to separate records on blank lines, which is done by setting RS to the empty string.  You can select the desired record by an exact match on the first field as above (here, $1 is not the parameter to the function, but is passed literally to awk which uses it to select the first field in the record), and then perform the substitution on only that record.\nIf you know the password is always on the 3rd line of the record (counting the header as a line), you can simplify a bit and just do:\nawk '$1 == \"[profile.two]\" {$3=\"password=\" new_password}1\n        ' new_password=\"$1\" RS= ORS='\\n\\n' OFS='\\n' input\n\nIn all of the above, I am assuming your data is in a file named input.\nNote that neither this nor the sed solutions are robust, and it is difficult (and probably not worth the effort) to make them so.  You might try:\n p=\"$1\" awk '$1 == \"[profile.two]\" {$3=\"password=\" ENVIRON[\"p\"]}1\n        ' RS= ORS='\\n\\n' OFS='\\n' input;\n\n", "\nThis might work for you (GNU sed):\nv=\"s}[r3t\"\n<<<\"password=$v\" sed -e '/^\\[profile\\.two\\]/,/^$/{/^password=/{r /dev/stdin' -e 'd}}' file\n\nSet a password in v.\nReplicate the password as a one line file and feed it into the sed invocation using the here-string.\nIn the sed invocation, search for a range beginning with [profile.two] and ending with an empty line (or the end of the file).\nWithin the range above, match a line with password and replace it by the line provided by the here-document then delete the current line.\nN.B. Passwords will and should contain special characters such as $*&[] etc, therefore to avoid these messing with sed itself, pass the password as a line from a separate file. In this case a here-string.\n", "\nYou are overcomplicating things.\nhostname -I |\nsed 's/\\.[^.]*$//'\n\nas in, remove the last dot and all the text after it.\nThe immediate problem with your attempt seems to have been the missing backslash before one dot, and/or the lack of a line-beginning anchor; though neither of those would be fatal if it weren't for the fact that there is apparently some invisible text (a space? Or some control character?) at the end of the hostname output. Maybe pipe it to cat -v or od -tx1 to see exactly what it prints.\n", "\ntr -d '\\n' < file.txt\n\nOr\nawk '{ printf \"%s\", $0 }' file.txt\n\nOr\nsed ':a;N;$!ba;s/\\n//g' file.txt\n\nThis page here has a bunch of other methods to remove newlines.\n", "\ntr --delete '\\n' < yourfile.txt\ntr -d '\\n' < yourfile.txt\n\nIf none of the commands posted here are working, then you have something other than a newline separating your fields. Possibly you have DOS/Windows line endings in the file (although I would expect the Perl solutions to work even in that case)?\nTry:\ntr -d \"\\n\\r\" < yourfile.txt\n\nIf that doesn't work then you're going to have to inspect your file more closely (e.g., in a hex editor) to find out what characters are actually in there that you want to remove.\n", "\nperl -p -i -e 's/\\R//g;' filename\n\nMust do the job.\n", "\nExpanding on a previous answer, this removes all new lines and saves the result to a new file (thanks to @tripleee):\ntr -d '\\n' < yourfile.txt > yourfile2.txt\n\nWhich is better than a \"useless cat\" (see comments):\ncat file.txt | tr -d '\\n' > file2.txt\n\nAlso useful for getting rid of new lines at the end of the file, e.g., created by using echo blah > file.txt.\nNote that the destination filename is different, important, otherwise you'll wipe out the original content!\n", "\npaste -sd \"\" file.txt\n\n", "\nYou can edit the file in vim:\n$ vim inputfile\n:%s/\\n//g\n\n", "\nUse\nhead -n 1 filename | od -c\n\nto figure what the offending character is.\nThen use\ntr -d '\\n' <filename\n\nfor LF, and\ntr -d '\\r\\n' <filename\n\nfor CRLF.\n", "\nUse sed with POSIX classes\nThis will remove all lines containing only whitespace (spaces & tabs) \nsed '/^[[:space:]]*$/d'\nJust take whatever you are working with and pipe it to that\nExample\ncat filename | sed '/^[[:space:]]*$/d'\n", "\nI was having the same case today. It is super easy in Vim or Neovim, and you can use gJ to join lines. For your use case, just do\n99gJ\n\nThis will join all your 99 lines. You can adjust the number 99 as needed according to how many lines to join. If just joining one line, then only gJ is good enough.\n", "\nUsing man 1 ed:\n# cf. http://wiki.bash-hackers.org/doku.php?id=howto:edit-ed \ned -s file <<< $'1,$j\\n,p'  # print to stdout \ned -s file <<< $'1,$j\\nwq'  # in-place edit\n\n", "\nNerd fact: use ASCII instead.\ntr -d '\\012' < filename.extension   \n\n(Edited cause i didn't see the friggin' answer that had same solution, only difference was that mine had ASCII)\n", "\nUsing the gedit text editor (3.18.3)\n\nClick Search\nClick Find and Replace...\nEnter \\n\\s into Find field\nLeave Replace with blank (nothing)\nCheck Regular expression box\nClick the Find button\n\nNote: this doesn't exactly address the OP's original, 7 year old problem but should help some noob linux users (like me) who find their way here from the SE's with similar \"how do I get my text all on one line\" questions.\n", "\nxargs consumes newlines as well (but adds a final trailing newline):\nxargs < file.txt | tr -d ' '\n\n", "\nIf the data is in file.txt, then:\necho $(<file.txt) | tr -d ' '\n\nThe '$(<file.txt)' reads the file and gives the contents as a series of words which 'echo' then echoes with a space between them.  The 'tr' command then deletes any spaces:\n22791;14336;22821;34653;21491;25522;33238;\n\n", "\nI usually get this use case when I'm copying a code snippet from a file and I want to paste it into a console without adding unnecessary new lines, I ended up doing a Bash alias (I called it oneline if you are curious)\nxsel -b -o | tr -d '\\n' | tr -s ' ' | xsel -b -i\n\n\nxsel -b -o reads my clipboard\n\ntr -d '\\n' removes new lines\n\ntr -s ' ' removes recurring spaces\n\nxsel -b -i pushes this back to my clipboard\n\n\nafter that I would paste the new contents of the clipboard into one line in a console or whatever.\n", "\nAssuming you only want to keep the digits and the semicolons, the following should do the trick assuming there are no major encoding issues, though it will also remove the very last \"newline\":\ntr -cd \";0-9\"\n\nYou can easily modify the above to include other characters, e.g. if you want to retain decimal points, commas, etc.\n", "\nperl -0777 -pe 's/\\n+//g' input >output\nperl -0777 -pe 'tr/\\n//d' input >output\n", "\nI would do it with awk, e.g.\nawk '/[0-9]+/ { a = a $0 \";\" } END { print a }' file.txt\n\n(a disadvantage is that a is \"accumulated\" in memory).\nEDIT\nForgot about printf! So also\nawk '/[0-9]+/ { printf \"%s;\", $0 }' file.txt\n\nor likely better, what it was already given in the other ans using awk.\n", "\nYou are missing the most obvious and fast answer especially when you need to do this in GUI in order to fix some weird word-wrap.\n\nOpen gedit\nThen Ctrl + H, then put in the Find textbox \\n and in Replace with an empty space   then fill checkbox Regular expression and voila. \n\n", "\nTo also remove the trailing newline at the end of the file\npython -c \"s=open('filename','r').read();open('filename', 'w').write(s.replace('\\n',''))\"\n\n", "\nIs it possible to use Perl?\nperl -nlE 'say reverse(split(\"([/.])\",$_))'  f\n\nThis one-liner reverses all the lines of f, according to PO's criteria.\nIf prefer a less parentesis version:\nperl -nlE 'say reverse split \"([/.])\"' f \n\n", "\nWith your shown samples please try following awk code.\necho 'com.e.h/float' |\nawk '\n  BEGIN{ FS=OFS=\"/\" }\n  {\n    num=split($1,arr,\".\")\n    val=\"\"\n    for(i=num;i>0;i--){\n       val=(val?val \".\":\"\") arr[i]\n    }\n    print $2,val\n  }\n'\n\n", "\nFor portability, this can be done using any awk (not just GNU) using substrings:\n$ awk '{\n    while (match($0,/[[:alnum:]]+/)) {\n      s=substr($0,RLENGTH+1,1) substr($0,1,RLENGTH) s;\n      $0=substr($0,RLENGTH+2)\n    } print s\n  }' <<<\"com.e.h/float\"\n\nThis steps through the string grabbing alphanumeric strings plus the following character, reversing the order of those two captured pieces, and prepending them to an output string.\n", "\nYou can use sed and tac:\nstr=$(echo 'com.e.h/float' | sed -E 's/(\\W+)/\\n\\1\\n/g' | tac | tr -d '\\n')\n\necho \"$str\"\nfloat/h.e.com\n\n\nUsing sed we insert \\n before and after all non-word characters.\nUsing tac we reverse the output lines.\nUsing tr we strip all new lines.\n\n\nIf you have gnu-awk then you can do all this in a single awk command using 4 argument split function call that populates split strings and delimiters separately:\nawk '{\n   s = \"\"\n   split($0, arr, /\\W+/, seps)\n   for (i=length(arr); i>=1; i--)\n      s = s seps[i] arr[i]\n   print s\n}' file\n\nFor non-gnu awk, you can use:\nawk '{\n   r = $0\n   i = 0\n   while (match(r, /[^a-zA-Z0-9_]+/)) {\n      a[++i] = substr(r, RSTART, RLENGTH) substr(r, 0, RSTART-1)\n      r = substr(r, RSTART+RLENGTH)\n   }\n   s = r\n   for (j=i; j>=1; j--)\n      s = s a[j]\n   print s\n}' file\n\n", "\nUsing GNU awk's split, splitting from separators . and /, define more if you wish.\n$ cat program.awk\n{\n    for(n=split($0,a,\"[./]\",s); n>=1; n--)               # split to a and s, use n from split\n        printf \"%s%s\", a[n], (n==1?ORS:s[(n-1)])         # printf it pretty\n}\n\nRun it:\n$ echo com.e.h/float | awk -f program.awk \nfloat/h.e.com\n\nEDIT:\nIf you want to run it as one-liner:\nawk '{for(n=split($0,a,\"[./]\",s); n>=1; n--); printf \"%s%s\", a[n], (n==1?ORS:s[(n-1)])}' foo.txt\n\n", "\nTry this:\necho $(echo ruof eerht owt eno | fmt -1 | tac | rev)\n\nreturns\none two three four\nAlternatively:\necho $(echo ruof eerht owt eno | rev | fmt -1 | tac)\n\nreturns\nfour three two one\n", "\nTry changing the first two lines to:\ns/[ \\t]*|[ \\t]*/|/g\n\n", "\nThe best I was able to do with sed, was this script:\ns/[\\s\\t]*|[\\s\\t]*/|/g\ns/[\\s\\t]*$//\ns/^|/null|/\n\nIn my tests, this ran about 30% faster than your sed script. The increase in performance comes from combining the first two regexen and omitting the \"g\" flag where it's not needed.\nHowever, 30% faster is only a mild improvement (it should still take about an hour and a half to run the above script on your 1GB data file). I wanted to see if I could do any better.\nIn the end, no other method I tried (awk, perl, and other approaches with sed) fared any better, except -- of course -- a plain ol' C implementation. As would be expected with C, the code is a bit verbose for posting here, but if you want a program that's likely going to be faster than any other method out there, you may want to take a look at it.\nIn my tests, the C implementation finishes in about 20% of the time it takes for your sed script. So it might take about 25 minutes or so to run on your Unix server.\nI didn't spend much time optimizing the C implementation. No doubt there are a number of places where the algorithm could be improved, but frankly, I don't know if it's possible to shave a significant amount of time beyond what it already achieves. If anything, I think it certainly places an upper limit on what kind of performance you can expect from other methods (sed, awk, perl, python, etc).\nEdit: The original version had a minor bug that caused it to possibly print the wrong thing at the end of the output (e.g. could print a \"null\" that shouldn't be there). I had some time today to take a look at it and fixed that. I also optimized away a call to strlen() that gave it another slight performance boost.\n", "\nMy testing indicated that sed can become CPU bound pretty easily on something like this.  If you have a multi-core machine you can try spawning off multiple sed processes with a script that looks something like this:\n#!/bin/sh\nINFILE=data.txt\nOUTFILE=fixed.txt\nSEDSCRIPT=script.sed\nSPLITLIMIT=`wc -l $INFILE | awk '{print $1 / 20}'`\n\nsplit -d -l $SPLITLIMT $INFILE x_\n\nfor chunk in x_??\ndo\n  sed -f $SEDSCRIPT $chunk > $chunk.out &\ndone\n\nwait \n\ncat x_??.out >> output.txt\n\nrm -f x_??\nrm -f x_??.out\n\n", "\nIt seems to me from your example that you are cleaning up white space from the beginning and end of pipe (|) delimited fields in a text file.   If I were to do this, I would change the algorithm to the following:\nfor each line\n    split the line into an array of fields\n    remove the leading and trailing white space\n    join the fields back back together as a pipe delimited line handling the empty first field correctly.\n\nI would also use a different language such as Perl or Ruby for this.\nThe advantage of this approach is that the code that cleans up the lines now handles fewer characters for each invocation and should execute much faster even though more invocations are needed.\n", "\nThis might work. I've only tested it a little.\nawk  'BEGIN {FS=\"|\"; OFS=\"|\"} {for (i=1; i<=NF; i++) gsub(\"[ \\t]\", \"\", $i); $1=$1; if ( $1 == \"\" ) $1 = \"null\"; print}'\n\n", "\nHow about Perl:\n#!/usr/bin/perl\n\nwhile(<>) {\n    s/\\s*\\|\\s*/|/g;\n    s/^\\s*//;\n    s/\\s*$//;\n    s/^\\|/null|/;\n    print;\n}\n\nEDIT: changed approach significantly.  On my machine this is almost 3x faster than your sed script.\nIf you really need the best speed possible, write a specialized C program to do this task.\n", "\nuse gawk, not sed.\nawk -vFS='|' '{for(i=1;i<=NF;i++) gsub(/ +|\\t+/,\"\",$i)}1' OFS=\"|\"  file\n\n", "\nTry doing it in one command:\nsed 's/[^|]*(|.*|).*/\\1/'\n\n", "\nHave you tried Perl?  It may be faster.\n#!/usr/local/bin/perl -p\n\ns#[\\t ]+\\|#|#g;\ns#\\|[\\t ]+#|#g;\ns#[\\t ]*$##;\ns#^\\|#null|#;\n\nEdit:  Actually, it seems to be about three times slower than the sed program.  Strange...\n", "\nThis Perl script should be much much faster\ns/\\s*|\\s*/|/go;\ns/\\s *$//o;\ns/^|/null|/o;\n\nBasically, make sure your regexes are compiled once (the 'o' flag), and no need need to use 'g' on regexes that apply only to end and beginning of line.\nAlso, [\\s\\t]* is equivalent to \\s*\n", "\nYou may get the result using string manipulation in Bash:\n#!/bin/bash\npath=\"/path/to/file 20-456 (1).jpg\"\nfldr=\"${path%/*}\"   # Get the folder\nfile=\"${path##*/}\"  # Get the file name\nfile=\"${file// /_}\" # Replace spaces with underscores in filename\necho \"$fldr/${file//[^[:alnum:]._-]/}\" # Get the result\n\nSee the online demo yielding /path/to/file_20-456_1.jpg.\nQuick notes:\n\n${path%/*} - Removes the smallest chunk up to / from the end of the path\n${path##*/} - Removes the largest text chunk from start of path to last / (including it)\n${file// /_} replaces all spaces with _ in file\n${file//[^[:alnum:]._-]/} removes all chars that are not alphanumeric, ., _ and - from file.\n\n", "\nAs Ron mentioned in the comment, you can do something like this with bash to generate the files with modified content that matches the index:\n# Iterate over the values from 036 to 051\nfor i in {036..051}; do\n  echo \"Generating 'ZAF_MM_CYCLE_K${i}.XLS'\"\n  cat > ZAF_MM_CYCLE_K${i}.XLS << EOL\nLOADED_AGRS   ZAF_MM_CYCLE_K${i}\nAGG_DEFINE    200ZAF_MM_CYCLE_K${i} $WERKS  K${i}\nAGG_1521      200ZAF_MM_CYCLE_K${i}\nEOL\ndone\n\nThe above will generate the files as described in the current directory. The cat > ZAF_MM_CYCLE_K${i}.XLS << EOL uses a heredoc to generate the file. The filename and contents use the $i variable for the names. As the for loop executes, i gets incremented, i.e. 036, 037, 038,...051 etc. which is used to generate the file name and the contents accordingly.\nIf you want to use something like sed to replace contents. Running the following in the directory where the files are should do the trick:\n# Iterate over the files and replace contents\nfor f in ZAF_MM_CYCLE_K0{36..51}.XLS; do\n\n  # Set a variable the same as the filename but strip off ZAF_MM_CYCLE_K\n  n=${f//ZAF_MM_CYCLE_K/}\n\n  # Further strip off the file extension\n  n=${n%*.XLS}\n\n  echo \"Replacing K036 in $f with ${n}\"\n\n  # Replace the contents with the number found in the file name\n  sed -i \"s|K036|${n}|g\" \"$f\"\ndone\n\nBasically, we iterate over each file, set a variable name that contains the number from the filename by stripping the ZAF_MM_CYCLE_K and the .XLS using bash parameter expansion. Once the number is deduced, use sed to replace the contents on the given file. sed -i does an in-place replacement on the original file.\nHope this helps!\n", "\nThis might work for you (GNU sed & parallel):\nparallel sed -i \\''s/K036/{=s/.*_(.*)\\.XLS$/\\1/=}/g'\\' {} ::: *.XLS\n\nBuild and execute a separate sed script for each file ending in .XLS in the current directory.\nThe sed script will replace K036 by the code following the last _ in the filename and end before the final ..\n", "\nThe line separator is not part of the text that sed operates on. Hence, you cannot replace it.\nYou can use tr to do the translation:\ntr '\\012' '\\045' < saut-de-ligne_UTF-8 > tmp\nmv tmp saut-de-ligne_UTF-8\n\n"], "rejected": ["\nEscaping the backslash with another backslash worked for me as @Noam Manos mentioned in his comment.\nsome_command | sed '1itext\\\\\\tABtext'\n\n", "\nEscaping the backslash with another backslash worked for me as @Noam Manos mentioned in his comment.\nsome_command | sed '1itext\\\\\\tABtext'\n\n", "\nEscaping the backslash with another backslash worked for me as @Noam Manos mentioned in his comment.\nsome_command | sed '1itext\\\\\\tABtext'\n\n", "\nEscaping the backslash with another backslash worked for me as @Noam Manos mentioned in his comment.\nsome_command | sed '1itext\\\\\\tABtext'\n\n", "\nEscaping the backslash with another backslash worked for me as @Noam Manos mentioned in his comment.\nsome_command | sed '1itext\\\\\\tABtext'\n\n", "\nEscaping the backslash with another backslash worked for me as @Noam Manos mentioned in his comment.\nsome_command | sed '1itext\\\\\\tABtext'\n\n", "\nEscaping the backslash with another backslash worked for me as @Noam Manos mentioned in his comment.\nsome_command | sed '1itext\\\\\\tABtext'\n\n", "\nEscaping the backslash with another backslash worked for me as @Noam Manos mentioned in his comment.\nsome_command | sed '1itext\\\\\\tABtext'\n\n", "\nYou need to escape all the special characters in the regular expression: ., $, [, ], *.\nsed -i 's|LC_ALL=C PYTHONHASHSEED=0 chroot \\. dpkg -i --path-include=\"/usr/share/doc/\\*\" \"\\${deb_list\\[@\\]}\"|LC_ALL=C PYTHONHASHSEED=0 chroot . dpkg -i --force-overwrite --path-include=\"/usr/share/doc/*\" \"${deb_list[@]}\"|' test.sh\n\n", "\nSo for the start, we have a file with the following lines, called datafile.txt\n1 some test lines here\nbut not all lines contain nubers\n3 and here is the last one\n\nand we have one bash variable $ADDED with the line content what want add\nADDED=\"==This is the new line==\"\n\nSo, add line after the first line\nADDED=\"==This is the new line==\"\n< datafile.txt sed \"1a \\\\\n$ADDED\n\"\n\nthe result:\n1 some test lines here\n==This is the new line==\nbut not all lines contain nubers\n3 and here is the last line\n\nAdd line after all lines what are starts with a number\n< datafile.txt sed \"/^[0-9]/a \\\\\n$ADDED\n\"\n\nthe result:\n1 some test lines here\n==This is the new line==\nbut not all lines contain nubers\n3 and here is the last line\n==This is the new line==\n\nAdd line to the start, so insert before first line\n< datafile.txt sed \"1i \\\\\n$ADDED\n\"\n\nresult\n==This is the new line==\n1 some test lines here\nbut not all lines contain nubers\n3 and here is the last line\n\nYou can \"substitute\" the end of the line for adding a new one\n< datafile.txt sed \"/all/s/$/\\\\\n$ADDED/\"\n\nthe above example add line after the line what contains word \"all\" by substitution\n1 some test lines here\nbut not all lines contain nubers\n==This is the new line==\n3 and here is the last line\n\nYou can even split line and add between\n< datafile.txt sed \"/all/s/\\(.*lines \\)\\(.*\\)/\\1\\\\\n$ADDED\\\\\n\\2/\"\n\nthe above will search for the line what contains the word \"all\" and split it after the word \"lines\". The result:\n1 some test lines here\nbut not all lines \n==This is the new line==\ncontain nubers\n3 and here is the last line\n\nLast thing. It is impossible to parsing HTML with regural expressions, check the link in sputnik's comment.\nBUT, that's not mean than it is impossible match some parts of HTML files. If you know what you want match (and not parse) - you can safely use regular expression for HTML too. Simply, many peoples here don't know the difference between parsing and matching.\nSo, if your html files has well known structure, e.g. you are sure than your html will the above structure all times, you can safely write:\n<your_file.html sed \"/^<tr><th>/a \\\\\n<tr><td>new Row:1 Cell:1</td><td>Row:1 Cell:2</td><td>Row:1 Cell:3</td><td>Row:1 Cell:4</td>\n\"\n\nand you will get\n<table id=\"tfhover\" class=\"tftable\" border=\"1\">\n<tr><th>HEADER1</th><th>HEADER2</th><th>HEADER3</th><th>HEADER4</th></tr>\n<tr><td>new Row:1 Cell:1</td><td>Row:1 Cell:2</td><td>Row:1 Cell:3</td><td>Row:1 Cell:4</td>\n<tr><td>Row:1 Cell:1</td><td>Row:1 Cell:2</td><td>Row:1 Cell:3</td><td>Row:1 Cell:4</td></tr>\n</table>\n\nsimply because we NOT PARSING the html code, we are only MATCHING some line patterns..\n", "\nThis might work for you (GNU sed):\nsed '/^- name:/{h;b}\n     /- name: a\\.b\\.c/{n;G;s/\\(value:\\).*my-app/\\1 abc-1234/;P;d}\n     /- name: d\\.e\\.f/{n;G;s/\\(value:\\).*my-app/\\1 1234/;P;d}' file\n\nCopy the app name into the hold space.\nIf a subsequent line contains the name a.b.c, print it and fetch the next line and append the copied app name line.\nIf that line contains value: and also my-app, replace the value with the required value and then print the first line only and delete the rest.\n", "\n\nreplace line contents having / using sed\n[...]\nit is not working due to presence of / in search string\n\nThat's one of the reasons it's not working.  Your example also has a problem related to there being quotes embedded in the target text.\nWith respect to the / characters, there are several possibilities. The easiest one that serves the general case is to use a different character for the pattern delimiter.  / is most conventional for that purpose, but you can choose any character.  The ,, |, and # are fairly common alternatives.  For example:\nsed -i \"s#ExecStart=-/sbin/agetty -o '-p -- \\\\\\\\u' --keep-baud 110200,38900,9680 %I \\$TERM#ExecStart=-/sbin/agetty 9600 %I \\$TERM#\" myunit.service\n\n(Note: I removed the g option because it's moot: the pattern will not match more than once per line anyway.)\nBut that's a bit heavy-handed.  Your input has only one ExecStart line, so that's sufficient to identify the line to edit, and you don't need to replace the whole line.  I might instead use something like this:\nsed -i '/ExecStart/ s/agetty.*/agetty 9600 %I $TERM/' myunit.service\n\nThat says: on each line matching pattern /ExecStart/, replace the longest substring starting with agetty with the string agetty 9600 %I $TERM.  That's crafted for your specific example, of course, but similar can be used on many other cases.\n", "\nWhen you don't care where the line with the version is, you can add new version at the end of the file and remove other version lines (if any).\nTwo commands with the same result, but not tested on Mac:\nsed -ni '$ s/$/\\nversion='\"${version_selected}\"'/;/^version=/!p;' infile\nsed -i '/^version=/d; $ s/$/\\nversion='\"${version_selected}\"'/' infile\n\nWith awk, without the -i inplace, you can use\nfile=$(mktemp)\nawk -v v=\"${version_selected}\" '\n  /^version=/ {next}\n  1;\n  END {print \"version=\" v}' infile > \"${file}\" && mv \"${file}\" infile\n\n", "\nWhen you don't care where the line with the version is, you can add new version at the end of the file and remove other version lines (if any).\nTwo commands with the same result, but not tested on Mac:\nsed -ni '$ s/$/\\nversion='\"${version_selected}\"'/;/^version=/!p;' infile\nsed -i '/^version=/d; $ s/$/\\nversion='\"${version_selected}\"'/' infile\n\nWith awk, without the -i inplace, you can use\nfile=$(mktemp)\nawk -v v=\"${version_selected}\" '\n  /^version=/ {next}\n  1;\n  END {print \"version=\" v}' infile > \"${file}\" && mv \"${file}\" infile\n\n", "\nUsing sed\n$ sed '/^this/I{h;s/^/# /;G}' input_file\n# This is a line\nThis is a line\n# this is another line\nthis is another line\n\nor slurping the entire input\n$ sed -z 's/this[^\\n]*\\n/# &&/Ig' input_file\n# This is a line\nThis is a line\n# this is another line\nthis is another line\n\nIf awk is an option\n$ awk '/^[Tt]his/{print \"# \"$0}1' input_file\n# This is a line\nThis is a line\n# this is another line\nthis is another line\n\n", "\nThis might be what you're trying to do, using any POSIX awk:\n$ awk '{ORS=(/^}$/ ? RS : OFS); sub(/^[[:space:]]+/,\"\")} 1' file\nltm pool /Common/foo_mim_pool { members { /Common/mim-foo-010101-1:5222 { address 10.22.1.161 } } }\nltm pool /Common/foo_ts_pool { members { /Common/ts-vx-010101-1:6698 { address 10.20.1.68 } /Common/ts-vx-010101-1:6699 { address 10.20.1.68 } /Common/ts-vx-010101-2:6698 { address 10.21.1.199 } /Common/ts-vx-010101-2:6699 { address 10.21.1.199 } } monitor /Common/ts_monitor }\n\n", "\nThis might be what you're trying to do, using any POSIX awk:\n$ awk '{ORS=(/^}$/ ? RS : OFS); sub(/^[[:space:]]+/,\"\")} 1' file\nltm pool /Common/foo_mim_pool { members { /Common/mim-foo-010101-1:5222 { address 10.22.1.161 } } }\nltm pool /Common/foo_ts_pool { members { /Common/ts-vx-010101-1:6698 { address 10.20.1.68 } /Common/ts-vx-010101-1:6699 { address 10.20.1.68 } /Common/ts-vx-010101-2:6698 { address 10.21.1.199 } /Common/ts-vx-010101-2:6699 { address 10.21.1.199 } } monitor /Common/ts_monitor }\n\n", "\nsed solution just needs braces:\nsed '\n    /^#/ {\n        /hello/ {\n            /bye/!a\\\nnew line\n        }\n    }\n' input_file >output_file\n\nIt's a bit cleaner with awk:\nawk '\n    1;\n    /^#/ && /hello/ && !/bye/ { print \"new line\" }\n' input_file >output_file\n\n", "\nsed solution just needs braces:\nsed '\n    /^#/ {\n        /hello/ {\n            /bye/!a\\\nnew line\n        }\n    }\n' input_file >output_file\n\nIt's a bit cleaner with awk:\nawk '\n    1;\n    /^#/ && /hello/ && !/bye/ { print \"new line\" }\n' input_file >output_file\n\n", "\nGiven this input file which has a couple of rainy-day cases added where scsi_mod.scan=sync is already present in a couple of locations:\n$ cat file\nGRUB_TIMEOUT=5\nGRUB_DISTRIBUTOR=\"$(sed 's, release .*$,,g' /etc/system-release)\"\nGRUB_DEFAULT=saved\nGRUB_DISABLE_SUBMENU=true\nGRUB_TERMINAL_OUTPUT=\"console\"\nGRUB_CMDLINE_LINUX=\"crashkernel=auto rd.lvm.lv=VG/LV_root rd.lvm.lv=VG/lv_swap ipv6.disable=1 rhgb quiet\"\nGRUB_CMDLINE_LINUX=\"crashkernel=auto rd.lvm.lv=VG/LV_root rd.lvm.lv=VG/lv_swap ipv6.disable=1 rhgb quiet scsi_mod.scan=sync\"\nGRUB_CMDLINE_LINUX=\"crashkernel=auto rd.lvm.lv=VG/LV_root rd.lvm.lv=VG/lv_swap ipv6.disable=1 scsi_mod.scan=sync rhgb quiet\"\nGRUB_DISABLE_RECOVERY=\"true\"\n\nthen using any awk we can see it only modifies the one line that you want to be modified:\n$ awk -v new='scsi_mod.scan=sync' '/^GRUB_CMDLINE_LINUX=/ && !index($0,new) { sub(/\"$/,\"\"); $0=$0 \" \" new \"\\\"\"} 1' file\nGRUB_TIMEOUT=5\nGRUB_DISTRIBUTOR=\"$(sed 's, release .*$,,g' /etc/system-release)\"\nGRUB_DEFAULT=saved\nGRUB_DISABLE_SUBMENU=true\nGRUB_TERMINAL_OUTPUT=\"console\"\nGRUB_CMDLINE_LINUX=\"crashkernel=auto rd.lvm.lv=VG/LV_root rd.lvm.lv=VG/lv_swap ipv6.disable=1 rhgb quiet scsi_mod.scan=sync\"\nGRUB_CMDLINE_LINUX=\"crashkernel=auto rd.lvm.lv=VG/LV_root rd.lvm.lv=VG/lv_swap ipv6.disable=1 rhgb quiet scsi_mod.scan=sync\"\nGRUB_CMDLINE_LINUX=\"crashkernel=auto rd.lvm.lv=VG/LV_root rd.lvm.lv=VG/lv_swap ipv6.disable=1 scsi_mod.scan=sync rhgb quiet\"\nGRUB_DISABLE_RECOVERY=\"true\"\n\n", "\nGiven this input file which has a couple of rainy-day cases added where scsi_mod.scan=sync is already present in a couple of locations:\n$ cat file\nGRUB_TIMEOUT=5\nGRUB_DISTRIBUTOR=\"$(sed 's, release .*$,,g' /etc/system-release)\"\nGRUB_DEFAULT=saved\nGRUB_DISABLE_SUBMENU=true\nGRUB_TERMINAL_OUTPUT=\"console\"\nGRUB_CMDLINE_LINUX=\"crashkernel=auto rd.lvm.lv=VG/LV_root rd.lvm.lv=VG/lv_swap ipv6.disable=1 rhgb quiet\"\nGRUB_CMDLINE_LINUX=\"crashkernel=auto rd.lvm.lv=VG/LV_root rd.lvm.lv=VG/lv_swap ipv6.disable=1 rhgb quiet scsi_mod.scan=sync\"\nGRUB_CMDLINE_LINUX=\"crashkernel=auto rd.lvm.lv=VG/LV_root rd.lvm.lv=VG/lv_swap ipv6.disable=1 scsi_mod.scan=sync rhgb quiet\"\nGRUB_DISABLE_RECOVERY=\"true\"\n\nthen using any awk we can see it only modifies the one line that you want to be modified:\n$ awk -v new='scsi_mod.scan=sync' '/^GRUB_CMDLINE_LINUX=/ && !index($0,new) { sub(/\"$/,\"\"); $0=$0 \" \" new \"\\\"\"} 1' file\nGRUB_TIMEOUT=5\nGRUB_DISTRIBUTOR=\"$(sed 's, release .*$,,g' /etc/system-release)\"\nGRUB_DEFAULT=saved\nGRUB_DISABLE_SUBMENU=true\nGRUB_TERMINAL_OUTPUT=\"console\"\nGRUB_CMDLINE_LINUX=\"crashkernel=auto rd.lvm.lv=VG/LV_root rd.lvm.lv=VG/lv_swap ipv6.disable=1 rhgb quiet scsi_mod.scan=sync\"\nGRUB_CMDLINE_LINUX=\"crashkernel=auto rd.lvm.lv=VG/LV_root rd.lvm.lv=VG/lv_swap ipv6.disable=1 rhgb quiet scsi_mod.scan=sync\"\nGRUB_CMDLINE_LINUX=\"crashkernel=auto rd.lvm.lv=VG/LV_root rd.lvm.lv=VG/lv_swap ipv6.disable=1 scsi_mod.scan=sync rhgb quiet\"\nGRUB_DISABLE_RECOVERY=\"true\"\n\n", "\ngrep by default returns the entire line when a match is found on a given input line.\nWhile option -o restricts the output to only that part of the line that the regex matched, that is still not enough in this case, because you want a substring of that match.\nHowever, since you're on Linux, you can use GNU grep's -P option (for support of PCREs, Perl-compatible regular expression), which allows extracting a submatch by way of features such as \\K (drop everything matched so far) and (?=...) (a look-ahead assertion that does not contribute to the match):\n$ grep -Po  \"[a-zA-Z]\\(.*\\)\\K[a-z]+(?=:)\" <<'EOF'\nMsgTrace(65/26)noop:user=xxx=INBOX:cmd=534\nImapFetchComplete(56/39)user=xxxxxxxxxx\nEOF\nnoop  # output\n\n\nOptional background information:\nEd Morton points out (in a since-deleted comment) that GNU grep's man page still calls the -P option \"highly experimental\" that may \"warn of unimplemented features\", but the option has been around for years, and in practice I have yet to see a warning or a performance problem - YMMV.  \nIn the case at hand, the above command even outperforms sed and awk solutions - see NeronLeVelu's helpful performance comparison.\nThe interesting article Ed points to discusses a potential performance problem that can surface with regex engines such as used by grep -P (via the PCRE library), Perl itself, and many other widely used (and mature) regex engines, such as in Python, Ruby, and PHP: \n\nIn short: the recursive backtracking algorithm employed by these engines can result in severe performance degradation with \"pathological\" regexes that string together long sequences of subexpressions with variable-length quantifiers, such as (a longer version of) a?a?a?a?aaaa to match aaaa.\nThe article argues that backtracking is only truly required when a regex contains backreferences, and that a different, much faster algorithm should be employed in their absence. \n\n", "\ngrep by default returns the entire line when a match is found on a given input line.\nWhile option -o restricts the output to only that part of the line that the regex matched, that is still not enough in this case, because you want a substring of that match.\nHowever, since you're on Linux, you can use GNU grep's -P option (for support of PCREs, Perl-compatible regular expression), which allows extracting a submatch by way of features such as \\K (drop everything matched so far) and (?=...) (a look-ahead assertion that does not contribute to the match):\n$ grep -Po  \"[a-zA-Z]\\(.*\\)\\K[a-z]+(?=:)\" <<'EOF'\nMsgTrace(65/26)noop:user=xxx=INBOX:cmd=534\nImapFetchComplete(56/39)user=xxxxxxxxxx\nEOF\nnoop  # output\n\n\nOptional background information:\nEd Morton points out (in a since-deleted comment) that GNU grep's man page still calls the -P option \"highly experimental\" that may \"warn of unimplemented features\", but the option has been around for years, and in practice I have yet to see a warning or a performance problem - YMMV.  \nIn the case at hand, the above command even outperforms sed and awk solutions - see NeronLeVelu's helpful performance comparison.\nThe interesting article Ed points to discusses a potential performance problem that can surface with regex engines such as used by grep -P (via the PCRE library), Perl itself, and many other widely used (and mature) regex engines, such as in Python, Ruby, and PHP: \n\nIn short: the recursive backtracking algorithm employed by these engines can result in severe performance degradation with \"pathological\" regexes that string together long sequences of subexpressions with variable-length quantifiers, such as (a longer version of) a?a?a?a?aaaa to match aaaa.\nThe article argues that backtracking is only truly required when a regex contains backreferences, and that a different, much faster algorithm should be employed in their absence. \n\n", "\nThese all seem pretty slow. Ruby can do it right quick.\nruby -r securerandom -ne 'print SecureRandom.uuid + \" \" + $_' file\n\n", "\nThese all seem pretty slow. Ruby can do it right quick.\nruby -r securerandom -ne 'print SecureRandom.uuid + \" \" + $_' file\n\n", "\nThese all seem pretty slow. Ruby can do it right quick.\nruby -r securerandom -ne 'print SecureRandom.uuid + \" \" + $_' file\n\n", "\nThese all seem pretty slow. Ruby can do it right quick.\nruby -r securerandom -ne 'print SecureRandom.uuid + \" \" + $_' file\n\n", "\nThese all seem pretty slow. Ruby can do it right quick.\nruby -r securerandom -ne 'print SecureRandom.uuid + \" \" + $_' file\n\n", "\nA simple implementation is to search from the start line to the replacement line, then in that range search and replace the replacement line.\nsed '/^\\[profile\\.two\\]/,/password=/{\n    s/password=.*/password='\"$1/;}\" file\n\nOnce this works like you hope, you can add the -i option to write the change back to the file, instead of to standard output.\nThis is inherently brittle in that $1 mustn't contain characters which are significant to sed in this context - in particular, newline or slash.\nThis looks explicitly for password= rather than hoping that it will be exactly the third line after the section heading.\n", "\nA simple implementation is to search from the start line to the replacement line, then in that range search and replace the replacement line.\nsed '/^\\[profile\\.two\\]/,/password=/{\n    s/password=.*/password='\"$1/;}\" file\n\nOnce this works like you hope, you can add the -i option to write the change back to the file, instead of to standard output.\nThis is inherently brittle in that $1 mustn't contain characters which are significant to sed in this context - in particular, newline or slash.\nThis looks explicitly for password= rather than hoping that it will be exactly the third line after the section heading.\n", "\nA simple implementation is to search from the start line to the replacement line, then in that range search and replace the replacement line.\nsed '/^\\[profile\\.two\\]/,/password=/{\n    s/password=.*/password='\"$1/;}\" file\n\nOnce this works like you hope, you can add the -i option to write the change back to the file, instead of to standard output.\nThis is inherently brittle in that $1 mustn't contain characters which are significant to sed in this context - in particular, newline or slash.\nThis looks explicitly for password= rather than hoping that it will be exactly the third line after the section heading.\n", "\nA simple implementation is to search from the start line to the replacement line, then in that range search and replace the replacement line.\nsed '/^\\[profile\\.two\\]/,/password=/{\n    s/password=.*/password='\"$1/;}\" file\n\nOnce this works like you hope, you can add the -i option to write the change back to the file, instead of to standard output.\nThis is inherently brittle in that $1 mustn't contain characters which are significant to sed in this context - in particular, newline or slash.\nThis looks explicitly for password= rather than hoping that it will be exactly the third line after the section heading.\n", "\n@Wiimm already gave a comment with an explanation: the line ends with a space.\nYou can look at echo \"<$(hostname -I)>\", the response will end with  >.\nWhen you know you always get exactly one IP-address, you can use\nhostname -i | cut -d '.' -f1,3.\nWhat do you want, when the response can be 1.2.3.4 1.2.3.5 1.2.4.1 ?\n# Show the substring from the first address\necho '1.2.3.4 1.2.3.5 1.2.4.1 ' | cut -d '.' -f1-3\n1.2.3\n\n# Show all sub-addresses (you can `| sort -u` when you want to)\n$ echo '1.2.3.4 1.2.3.5 1.2.4.1 ' | tr ' ' '\\n' | cut -d '.' -f1-3\n1.2.3\n1.2.3\n1.2.4\n\n# Other way to show the three sub-addresses\n$ echo '1.2.3.4 1.2.3.5 1.2.4.1 ' | grep -Eo '[^ .]*\\.[^ .]*\\.[^ .]*'\n\n", "\nThe fastest way I found:\n\nopen Vim by doing this in your command line\nvim inputfile\npress \":\" and input the following command to remove all newlines\n:%s/\\n//g\nInput this to also remove spaces in case some characters were spaces :%s/ //g\nmake sure to save by writing to the file with\n:w\n\nThe same format can be used to remove any other characters, and you can use a website like\nhttps://apps.timwhitlock.info/unicode/inspect\nto figure out what character you're missing.\nYou can also use this to figure out other characters you can't see and they have a tool as well.\nTool to learn of other invisible characters\n", "\nThe fastest way I found:\n\nopen Vim by doing this in your command line\nvim inputfile\npress \":\" and input the following command to remove all newlines\n:%s/\\n//g\nInput this to also remove spaces in case some characters were spaces :%s/ //g\nmake sure to save by writing to the file with\n:w\n\nThe same format can be used to remove any other characters, and you can use a website like\nhttps://apps.timwhitlock.info/unicode/inspect\nto figure out what character you're missing.\nYou can also use this to figure out other characters you can't see and they have a tool as well.\nTool to learn of other invisible characters\n", "\nThe fastest way I found:\n\nopen Vim by doing this in your command line\nvim inputfile\npress \":\" and input the following command to remove all newlines\n:%s/\\n//g\nInput this to also remove spaces in case some characters were spaces :%s/ //g\nmake sure to save by writing to the file with\n:w\n\nThe same format can be used to remove any other characters, and you can use a website like\nhttps://apps.timwhitlock.info/unicode/inspect\nto figure out what character you're missing.\nYou can also use this to figure out other characters you can't see and they have a tool as well.\nTool to learn of other invisible characters\n", "\nThe fastest way I found:\n\nopen Vim by doing this in your command line\nvim inputfile\npress \":\" and input the following command to remove all newlines\n:%s/\\n//g\nInput this to also remove spaces in case some characters were spaces :%s/ //g\nmake sure to save by writing to the file with\n:w\n\nThe same format can be used to remove any other characters, and you can use a website like\nhttps://apps.timwhitlock.info/unicode/inspect\nto figure out what character you're missing.\nYou can also use this to figure out other characters you can't see and they have a tool as well.\nTool to learn of other invisible characters\n", "\nThe fastest way I found:\n\nopen Vim by doing this in your command line\nvim inputfile\npress \":\" and input the following command to remove all newlines\n:%s/\\n//g\nInput this to also remove spaces in case some characters were spaces :%s/ //g\nmake sure to save by writing to the file with\n:w\n\nThe same format can be used to remove any other characters, and you can use a website like\nhttps://apps.timwhitlock.info/unicode/inspect\nto figure out what character you're missing.\nYou can also use this to figure out other characters you can't see and they have a tool as well.\nTool to learn of other invisible characters\n", "\nThe fastest way I found:\n\nopen Vim by doing this in your command line\nvim inputfile\npress \":\" and input the following command to remove all newlines\n:%s/\\n//g\nInput this to also remove spaces in case some characters were spaces :%s/ //g\nmake sure to save by writing to the file with\n:w\n\nThe same format can be used to remove any other characters, and you can use a website like\nhttps://apps.timwhitlock.info/unicode/inspect\nto figure out what character you're missing.\nYou can also use this to figure out other characters you can't see and they have a tool as well.\nTool to learn of other invisible characters\n", "\nThe fastest way I found:\n\nopen Vim by doing this in your command line\nvim inputfile\npress \":\" and input the following command to remove all newlines\n:%s/\\n//g\nInput this to also remove spaces in case some characters were spaces :%s/ //g\nmake sure to save by writing to the file with\n:w\n\nThe same format can be used to remove any other characters, and you can use a website like\nhttps://apps.timwhitlock.info/unicode/inspect\nto figure out what character you're missing.\nYou can also use this to figure out other characters you can't see and they have a tool as well.\nTool to learn of other invisible characters\n", "\nThe fastest way I found:\n\nopen Vim by doing this in your command line\nvim inputfile\npress \":\" and input the following command to remove all newlines\n:%s/\\n//g\nInput this to also remove spaces in case some characters were spaces :%s/ //g\nmake sure to save by writing to the file with\n:w\n\nThe same format can be used to remove any other characters, and you can use a website like\nhttps://apps.timwhitlock.info/unicode/inspect\nto figure out what character you're missing.\nYou can also use this to figure out other characters you can't see and they have a tool as well.\nTool to learn of other invisible characters\n", "\nThe fastest way I found:\n\nopen Vim by doing this in your command line\nvim inputfile\npress \":\" and input the following command to remove all newlines\n:%s/\\n//g\nInput this to also remove spaces in case some characters were spaces :%s/ //g\nmake sure to save by writing to the file with\n:w\n\nThe same format can be used to remove any other characters, and you can use a website like\nhttps://apps.timwhitlock.info/unicode/inspect\nto figure out what character you're missing.\nYou can also use this to figure out other characters you can't see and they have a tool as well.\nTool to learn of other invisible characters\n", "\nThe fastest way I found:\n\nopen Vim by doing this in your command line\nvim inputfile\npress \":\" and input the following command to remove all newlines\n:%s/\\n//g\nInput this to also remove spaces in case some characters were spaces :%s/ //g\nmake sure to save by writing to the file with\n:w\n\nThe same format can be used to remove any other characters, and you can use a website like\nhttps://apps.timwhitlock.info/unicode/inspect\nto figure out what character you're missing.\nYou can also use this to figure out other characters you can't see and they have a tool as well.\nTool to learn of other invisible characters\n", "\nThe fastest way I found:\n\nopen Vim by doing this in your command line\nvim inputfile\npress \":\" and input the following command to remove all newlines\n:%s/\\n//g\nInput this to also remove spaces in case some characters were spaces :%s/ //g\nmake sure to save by writing to the file with\n:w\n\nThe same format can be used to remove any other characters, and you can use a website like\nhttps://apps.timwhitlock.info/unicode/inspect\nto figure out what character you're missing.\nYou can also use this to figure out other characters you can't see and they have a tool as well.\nTool to learn of other invisible characters\n", "\nThe fastest way I found:\n\nopen Vim by doing this in your command line\nvim inputfile\npress \":\" and input the following command to remove all newlines\n:%s/\\n//g\nInput this to also remove spaces in case some characters were spaces :%s/ //g\nmake sure to save by writing to the file with\n:w\n\nThe same format can be used to remove any other characters, and you can use a website like\nhttps://apps.timwhitlock.info/unicode/inspect\nto figure out what character you're missing.\nYou can also use this to figure out other characters you can't see and they have a tool as well.\nTool to learn of other invisible characters\n", "\nThe fastest way I found:\n\nopen Vim by doing this in your command line\nvim inputfile\npress \":\" and input the following command to remove all newlines\n:%s/\\n//g\nInput this to also remove spaces in case some characters were spaces :%s/ //g\nmake sure to save by writing to the file with\n:w\n\nThe same format can be used to remove any other characters, and you can use a website like\nhttps://apps.timwhitlock.info/unicode/inspect\nto figure out what character you're missing.\nYou can also use this to figure out other characters you can't see and they have a tool as well.\nTool to learn of other invisible characters\n", "\nThe fastest way I found:\n\nopen Vim by doing this in your command line\nvim inputfile\npress \":\" and input the following command to remove all newlines\n:%s/\\n//g\nInput this to also remove spaces in case some characters were spaces :%s/ //g\nmake sure to save by writing to the file with\n:w\n\nThe same format can be used to remove any other characters, and you can use a website like\nhttps://apps.timwhitlock.info/unicode/inspect\nto figure out what character you're missing.\nYou can also use this to figure out other characters you can't see and they have a tool as well.\nTool to learn of other invisible characters\n", "\nThe fastest way I found:\n\nopen Vim by doing this in your command line\nvim inputfile\npress \":\" and input the following command to remove all newlines\n:%s/\\n//g\nInput this to also remove spaces in case some characters were spaces :%s/ //g\nmake sure to save by writing to the file with\n:w\n\nThe same format can be used to remove any other characters, and you can use a website like\nhttps://apps.timwhitlock.info/unicode/inspect\nto figure out what character you're missing.\nYou can also use this to figure out other characters you can't see and they have a tool as well.\nTool to learn of other invisible characters\n", "\nThe fastest way I found:\n\nopen Vim by doing this in your command line\nvim inputfile\npress \":\" and input the following command to remove all newlines\n:%s/\\n//g\nInput this to also remove spaces in case some characters were spaces :%s/ //g\nmake sure to save by writing to the file with\n:w\n\nThe same format can be used to remove any other characters, and you can use a website like\nhttps://apps.timwhitlock.info/unicode/inspect\nto figure out what character you're missing.\nYou can also use this to figure out other characters you can't see and they have a tool as well.\nTool to learn of other invisible characters\n", "\nThe fastest way I found:\n\nopen Vim by doing this in your command line\nvim inputfile\npress \":\" and input the following command to remove all newlines\n:%s/\\n//g\nInput this to also remove spaces in case some characters were spaces :%s/ //g\nmake sure to save by writing to the file with\n:w\n\nThe same format can be used to remove any other characters, and you can use a website like\nhttps://apps.timwhitlock.info/unicode/inspect\nto figure out what character you're missing.\nYou can also use this to figure out other characters you can't see and they have a tool as well.\nTool to learn of other invisible characters\n", "\nThe fastest way I found:\n\nopen Vim by doing this in your command line\nvim inputfile\npress \":\" and input the following command to remove all newlines\n:%s/\\n//g\nInput this to also remove spaces in case some characters were spaces :%s/ //g\nmake sure to save by writing to the file with\n:w\n\nThe same format can be used to remove any other characters, and you can use a website like\nhttps://apps.timwhitlock.info/unicode/inspect\nto figure out what character you're missing.\nYou can also use this to figure out other characters you can't see and they have a tool as well.\nTool to learn of other invisible characters\n", "\nThe fastest way I found:\n\nopen Vim by doing this in your command line\nvim inputfile\npress \":\" and input the following command to remove all newlines\n:%s/\\n//g\nInput this to also remove spaces in case some characters were spaces :%s/ //g\nmake sure to save by writing to the file with\n:w\n\nThe same format can be used to remove any other characters, and you can use a website like\nhttps://apps.timwhitlock.info/unicode/inspect\nto figure out what character you're missing.\nYou can also use this to figure out other characters you can't see and they have a tool as well.\nTool to learn of other invisible characters\n", "\nThe fastest way I found:\n\nopen Vim by doing this in your command line\nvim inputfile\npress \":\" and input the following command to remove all newlines\n:%s/\\n//g\nInput this to also remove spaces in case some characters were spaces :%s/ //g\nmake sure to save by writing to the file with\n:w\n\nThe same format can be used to remove any other characters, and you can use a website like\nhttps://apps.timwhitlock.info/unicode/inspect\nto figure out what character you're missing.\nYou can also use this to figure out other characters you can't see and they have a tool as well.\nTool to learn of other invisible characters\n", "\nNot sure exactly what you're going for, but this should work.\nUsing any awk:\nawk 'BEGIN {OFS=FS=\"/\"}\n    {print $2,\n     substr($1,length($1)) \".\"\n     substr($1,length($1)-2,1) \".\"\n     substr($1,1,3)}' input.txt\n\n", "\nNot sure exactly what you're going for, but this should work.\nUsing any awk:\nawk 'BEGIN {OFS=FS=\"/\"}\n    {print $2,\n     substr($1,length($1)) \".\"\n     substr($1,length($1)-2,1) \".\"\n     substr($1,1,3)}' input.txt\n\n", "\nNot sure exactly what you're going for, but this should work.\nUsing any awk:\nawk 'BEGIN {OFS=FS=\"/\"}\n    {print $2,\n     substr($1,length($1)) \".\"\n     substr($1,length($1)-2,1) \".\"\n     substr($1,1,3)}' input.txt\n\n", "\nNot sure exactly what you're going for, but this should work.\nUsing any awk:\nawk 'BEGIN {OFS=FS=\"/\"}\n    {print $2,\n     substr($1,length($1)) \".\"\n     substr($1,length($1)-2,1) \".\"\n     substr($1,1,3)}' input.txt\n\n", "\nNot sure exactly what you're going for, but this should work.\nUsing any awk:\nawk 'BEGIN {OFS=FS=\"/\"}\n    {print $2,\n     substr($1,length($1)) \".\"\n     substr($1,length($1)-2,1) \".\"\n     substr($1,1,3)}' input.txt\n\n", "\nNot sure exactly what you're going for, but this should work.\nUsing any awk:\nawk 'BEGIN {OFS=FS=\"/\"}\n    {print $2,\n     substr($1,length($1)) \".\"\n     substr($1,length($1)-2,1) \".\"\n     substr($1,1,3)}' input.txt\n\n", "\nI think the * in the regular expressions in the question and most of the answers can be a major slowdown compared to using a +. Consider the first replace in the question\ns/[\\s\\t]*|/|/g\n\nthe * matches zero or more items followed by a |, hence every | is replaced even those that do not need replacing. Changing the replace to be\ns/[\\s\\t]+|/|/g\n\nwill only change the | characters that are preceded by one or more spaces and tabs.\nI do not have sed available, but I did an experiment with Perl. On the data I used the script with the * took almost 7 times longer than the script with +.\nThe times were consistent across the runs. For the + the difference between minimum and maximum times was 4% of the average and for the * it was 3.6%. The ratio of the average times was 1::6.9 for +::*.\nDetails of experiment\nTested using an 80mb file with just over 180000 occurrences of [st]\\., these are the lowercase characters s and t.\nThe test used a batch command file with 30 of each of these two commands, alternating star and plus.\nperl -f TestPlus.pl input.ltrar > zz.oo\nperl -f TestStar.pl input.ltrar > zz.oo\n\nOne script is below, the other merely changed the * to + and star to plus.\n#! /bin/usr/perl\nuse strict;\nuse warnings;\nuse Time::HiRes qw( gettimeofday tv_interval );\n\nmy $t0 = [gettimeofday()];\nwhile(<>)\n{\n    s/[st]*\\././g;\n}\n\nmy $elapsed = tv_interval ( $t0 );\nprint STDERR \"Elapsed star $elapsed\\n\";\n\nPerl version used:\nc:\\test> perl -v\nThis is perl 5, version 16, subversion 3 (v5.16.3) built for MSWin32-x64-multi-thread\n(with 1 registered patch, see perl -V for more detail)\n\nCopyright 1987-2012, Larry Wall\n\nBinary build 1603 [296746] provided by ActiveState http://www.ActiveState.com\nBuilt Mar 13 2013 13:31:10\n\n", "\nI think the * in the regular expressions in the question and most of the answers can be a major slowdown compared to using a +. Consider the first replace in the question\ns/[\\s\\t]*|/|/g\n\nthe * matches zero or more items followed by a |, hence every | is replaced even those that do not need replacing. Changing the replace to be\ns/[\\s\\t]+|/|/g\n\nwill only change the | characters that are preceded by one or more spaces and tabs.\nI do not have sed available, but I did an experiment with Perl. On the data I used the script with the * took almost 7 times longer than the script with +.\nThe times were consistent across the runs. For the + the difference between minimum and maximum times was 4% of the average and for the * it was 3.6%. The ratio of the average times was 1::6.9 for +::*.\nDetails of experiment\nTested using an 80mb file with just over 180000 occurrences of [st]\\., these are the lowercase characters s and t.\nThe test used a batch command file with 30 of each of these two commands, alternating star and plus.\nperl -f TestPlus.pl input.ltrar > zz.oo\nperl -f TestStar.pl input.ltrar > zz.oo\n\nOne script is below, the other merely changed the * to + and star to plus.\n#! /bin/usr/perl\nuse strict;\nuse warnings;\nuse Time::HiRes qw( gettimeofday tv_interval );\n\nmy $t0 = [gettimeofday()];\nwhile(<>)\n{\n    s/[st]*\\././g;\n}\n\nmy $elapsed = tv_interval ( $t0 );\nprint STDERR \"Elapsed star $elapsed\\n\";\n\nPerl version used:\nc:\\test> perl -v\nThis is perl 5, version 16, subversion 3 (v5.16.3) built for MSWin32-x64-multi-thread\n(with 1 registered patch, see perl -V for more detail)\n\nCopyright 1987-2012, Larry Wall\n\nBinary build 1603 [296746] provided by ActiveState http://www.ActiveState.com\nBuilt Mar 13 2013 13:31:10\n\n", "\nI think the * in the regular expressions in the question and most of the answers can be a major slowdown compared to using a +. Consider the first replace in the question\ns/[\\s\\t]*|/|/g\n\nthe * matches zero or more items followed by a |, hence every | is replaced even those that do not need replacing. Changing the replace to be\ns/[\\s\\t]+|/|/g\n\nwill only change the | characters that are preceded by one or more spaces and tabs.\nI do not have sed available, but I did an experiment with Perl. On the data I used the script with the * took almost 7 times longer than the script with +.\nThe times were consistent across the runs. For the + the difference between minimum and maximum times was 4% of the average and for the * it was 3.6%. The ratio of the average times was 1::6.9 for +::*.\nDetails of experiment\nTested using an 80mb file with just over 180000 occurrences of [st]\\., these are the lowercase characters s and t.\nThe test used a batch command file with 30 of each of these two commands, alternating star and plus.\nperl -f TestPlus.pl input.ltrar > zz.oo\nperl -f TestStar.pl input.ltrar > zz.oo\n\nOne script is below, the other merely changed the * to + and star to plus.\n#! /bin/usr/perl\nuse strict;\nuse warnings;\nuse Time::HiRes qw( gettimeofday tv_interval );\n\nmy $t0 = [gettimeofday()];\nwhile(<>)\n{\n    s/[st]*\\././g;\n}\n\nmy $elapsed = tv_interval ( $t0 );\nprint STDERR \"Elapsed star $elapsed\\n\";\n\nPerl version used:\nc:\\test> perl -v\nThis is perl 5, version 16, subversion 3 (v5.16.3) built for MSWin32-x64-multi-thread\n(with 1 registered patch, see perl -V for more detail)\n\nCopyright 1987-2012, Larry Wall\n\nBinary build 1603 [296746] provided by ActiveState http://www.ActiveState.com\nBuilt Mar 13 2013 13:31:10\n\n", "\nI think the * in the regular expressions in the question and most of the answers can be a major slowdown compared to using a +. Consider the first replace in the question\ns/[\\s\\t]*|/|/g\n\nthe * matches zero or more items followed by a |, hence every | is replaced even those that do not need replacing. Changing the replace to be\ns/[\\s\\t]+|/|/g\n\nwill only change the | characters that are preceded by one or more spaces and tabs.\nI do not have sed available, but I did an experiment with Perl. On the data I used the script with the * took almost 7 times longer than the script with +.\nThe times were consistent across the runs. For the + the difference between minimum and maximum times was 4% of the average and for the * it was 3.6%. The ratio of the average times was 1::6.9 for +::*.\nDetails of experiment\nTested using an 80mb file with just over 180000 occurrences of [st]\\., these are the lowercase characters s and t.\nThe test used a batch command file with 30 of each of these two commands, alternating star and plus.\nperl -f TestPlus.pl input.ltrar > zz.oo\nperl -f TestStar.pl input.ltrar > zz.oo\n\nOne script is below, the other merely changed the * to + and star to plus.\n#! /bin/usr/perl\nuse strict;\nuse warnings;\nuse Time::HiRes qw( gettimeofday tv_interval );\n\nmy $t0 = [gettimeofday()];\nwhile(<>)\n{\n    s/[st]*\\././g;\n}\n\nmy $elapsed = tv_interval ( $t0 );\nprint STDERR \"Elapsed star $elapsed\\n\";\n\nPerl version used:\nc:\\test> perl -v\nThis is perl 5, version 16, subversion 3 (v5.16.3) built for MSWin32-x64-multi-thread\n(with 1 registered patch, see perl -V for more detail)\n\nCopyright 1987-2012, Larry Wall\n\nBinary build 1603 [296746] provided by ActiveState http://www.ActiveState.com\nBuilt Mar 13 2013 13:31:10\n\n", "\nI think the * in the regular expressions in the question and most of the answers can be a major slowdown compared to using a +. Consider the first replace in the question\ns/[\\s\\t]*|/|/g\n\nthe * matches zero or more items followed by a |, hence every | is replaced even those that do not need replacing. Changing the replace to be\ns/[\\s\\t]+|/|/g\n\nwill only change the | characters that are preceded by one or more spaces and tabs.\nI do not have sed available, but I did an experiment with Perl. On the data I used the script with the * took almost 7 times longer than the script with +.\nThe times were consistent across the runs. For the + the difference between minimum and maximum times was 4% of the average and for the * it was 3.6%. The ratio of the average times was 1::6.9 for +::*.\nDetails of experiment\nTested using an 80mb file with just over 180000 occurrences of [st]\\., these are the lowercase characters s and t.\nThe test used a batch command file with 30 of each of these two commands, alternating star and plus.\nperl -f TestPlus.pl input.ltrar > zz.oo\nperl -f TestStar.pl input.ltrar > zz.oo\n\nOne script is below, the other merely changed the * to + and star to plus.\n#! /bin/usr/perl\nuse strict;\nuse warnings;\nuse Time::HiRes qw( gettimeofday tv_interval );\n\nmy $t0 = [gettimeofday()];\nwhile(<>)\n{\n    s/[st]*\\././g;\n}\n\nmy $elapsed = tv_interval ( $t0 );\nprint STDERR \"Elapsed star $elapsed\\n\";\n\nPerl version used:\nc:\\test> perl -v\nThis is perl 5, version 16, subversion 3 (v5.16.3) built for MSWin32-x64-multi-thread\n(with 1 registered patch, see perl -V for more detail)\n\nCopyright 1987-2012, Larry Wall\n\nBinary build 1603 [296746] provided by ActiveState http://www.ActiveState.com\nBuilt Mar 13 2013 13:31:10\n\n", "\nI think the * in the regular expressions in the question and most of the answers can be a major slowdown compared to using a +. Consider the first replace in the question\ns/[\\s\\t]*|/|/g\n\nthe * matches zero or more items followed by a |, hence every | is replaced even those that do not need replacing. Changing the replace to be\ns/[\\s\\t]+|/|/g\n\nwill only change the | characters that are preceded by one or more spaces and tabs.\nI do not have sed available, but I did an experiment with Perl. On the data I used the script with the * took almost 7 times longer than the script with +.\nThe times were consistent across the runs. For the + the difference between minimum and maximum times was 4% of the average and for the * it was 3.6%. The ratio of the average times was 1::6.9 for +::*.\nDetails of experiment\nTested using an 80mb file with just over 180000 occurrences of [st]\\., these are the lowercase characters s and t.\nThe test used a batch command file with 30 of each of these two commands, alternating star and plus.\nperl -f TestPlus.pl input.ltrar > zz.oo\nperl -f TestStar.pl input.ltrar > zz.oo\n\nOne script is below, the other merely changed the * to + and star to plus.\n#! /bin/usr/perl\nuse strict;\nuse warnings;\nuse Time::HiRes qw( gettimeofday tv_interval );\n\nmy $t0 = [gettimeofday()];\nwhile(<>)\n{\n    s/[st]*\\././g;\n}\n\nmy $elapsed = tv_interval ( $t0 );\nprint STDERR \"Elapsed star $elapsed\\n\";\n\nPerl version used:\nc:\\test> perl -v\nThis is perl 5, version 16, subversion 3 (v5.16.3) built for MSWin32-x64-multi-thread\n(with 1 registered patch, see perl -V for more detail)\n\nCopyright 1987-2012, Larry Wall\n\nBinary build 1603 [296746] provided by ActiveState http://www.ActiveState.com\nBuilt Mar 13 2013 13:31:10\n\n", "\nI think the * in the regular expressions in the question and most of the answers can be a major slowdown compared to using a +. Consider the first replace in the question\ns/[\\s\\t]*|/|/g\n\nthe * matches zero or more items followed by a |, hence every | is replaced even those that do not need replacing. Changing the replace to be\ns/[\\s\\t]+|/|/g\n\nwill only change the | characters that are preceded by one or more spaces and tabs.\nI do not have sed available, but I did an experiment with Perl. On the data I used the script with the * took almost 7 times longer than the script with +.\nThe times were consistent across the runs. For the + the difference between minimum and maximum times was 4% of the average and for the * it was 3.6%. The ratio of the average times was 1::6.9 for +::*.\nDetails of experiment\nTested using an 80mb file with just over 180000 occurrences of [st]\\., these are the lowercase characters s and t.\nThe test used a batch command file with 30 of each of these two commands, alternating star and plus.\nperl -f TestPlus.pl input.ltrar > zz.oo\nperl -f TestStar.pl input.ltrar > zz.oo\n\nOne script is below, the other merely changed the * to + and star to plus.\n#! /bin/usr/perl\nuse strict;\nuse warnings;\nuse Time::HiRes qw( gettimeofday tv_interval );\n\nmy $t0 = [gettimeofday()];\nwhile(<>)\n{\n    s/[st]*\\././g;\n}\n\nmy $elapsed = tv_interval ( $t0 );\nprint STDERR \"Elapsed star $elapsed\\n\";\n\nPerl version used:\nc:\\test> perl -v\nThis is perl 5, version 16, subversion 3 (v5.16.3) built for MSWin32-x64-multi-thread\n(with 1 registered patch, see perl -V for more detail)\n\nCopyright 1987-2012, Larry Wall\n\nBinary build 1603 [296746] provided by ActiveState http://www.ActiveState.com\nBuilt Mar 13 2013 13:31:10\n\n", "\nI think the * in the regular expressions in the question and most of the answers can be a major slowdown compared to using a +. Consider the first replace in the question\ns/[\\s\\t]*|/|/g\n\nthe * matches zero or more items followed by a |, hence every | is replaced even those that do not need replacing. Changing the replace to be\ns/[\\s\\t]+|/|/g\n\nwill only change the | characters that are preceded by one or more spaces and tabs.\nI do not have sed available, but I did an experiment with Perl. On the data I used the script with the * took almost 7 times longer than the script with +.\nThe times were consistent across the runs. For the + the difference between minimum and maximum times was 4% of the average and for the * it was 3.6%. The ratio of the average times was 1::6.9 for +::*.\nDetails of experiment\nTested using an 80mb file with just over 180000 occurrences of [st]\\., these are the lowercase characters s and t.\nThe test used a batch command file with 30 of each of these two commands, alternating star and plus.\nperl -f TestPlus.pl input.ltrar > zz.oo\nperl -f TestStar.pl input.ltrar > zz.oo\n\nOne script is below, the other merely changed the * to + and star to plus.\n#! /bin/usr/perl\nuse strict;\nuse warnings;\nuse Time::HiRes qw( gettimeofday tv_interval );\n\nmy $t0 = [gettimeofday()];\nwhile(<>)\n{\n    s/[st]*\\././g;\n}\n\nmy $elapsed = tv_interval ( $t0 );\nprint STDERR \"Elapsed star $elapsed\\n\";\n\nPerl version used:\nc:\\test> perl -v\nThis is perl 5, version 16, subversion 3 (v5.16.3) built for MSWin32-x64-multi-thread\n(with 1 registered patch, see perl -V for more detail)\n\nCopyright 1987-2012, Larry Wall\n\nBinary build 1603 [296746] provided by ActiveState http://www.ActiveState.com\nBuilt Mar 13 2013 13:31:10\n\n", "\nI think the * in the regular expressions in the question and most of the answers can be a major slowdown compared to using a +. Consider the first replace in the question\ns/[\\s\\t]*|/|/g\n\nthe * matches zero or more items followed by a |, hence every | is replaced even those that do not need replacing. Changing the replace to be\ns/[\\s\\t]+|/|/g\n\nwill only change the | characters that are preceded by one or more spaces and tabs.\nI do not have sed available, but I did an experiment with Perl. On the data I used the script with the * took almost 7 times longer than the script with +.\nThe times were consistent across the runs. For the + the difference between minimum and maximum times was 4% of the average and for the * it was 3.6%. The ratio of the average times was 1::6.9 for +::*.\nDetails of experiment\nTested using an 80mb file with just over 180000 occurrences of [st]\\., these are the lowercase characters s and t.\nThe test used a batch command file with 30 of each of these two commands, alternating star and plus.\nperl -f TestPlus.pl input.ltrar > zz.oo\nperl -f TestStar.pl input.ltrar > zz.oo\n\nOne script is below, the other merely changed the * to + and star to plus.\n#! /bin/usr/perl\nuse strict;\nuse warnings;\nuse Time::HiRes qw( gettimeofday tv_interval );\n\nmy $t0 = [gettimeofday()];\nwhile(<>)\n{\n    s/[st]*\\././g;\n}\n\nmy $elapsed = tv_interval ( $t0 );\nprint STDERR \"Elapsed star $elapsed\\n\";\n\nPerl version used:\nc:\\test> perl -v\nThis is perl 5, version 16, subversion 3 (v5.16.3) built for MSWin32-x64-multi-thread\n(with 1 registered patch, see perl -V for more detail)\n\nCopyright 1987-2012, Larry Wall\n\nBinary build 1603 [296746] provided by ActiveState http://www.ActiveState.com\nBuilt Mar 13 2013 13:31:10\n\n", "\nI think the * in the regular expressions in the question and most of the answers can be a major slowdown compared to using a +. Consider the first replace in the question\ns/[\\s\\t]*|/|/g\n\nthe * matches zero or more items followed by a |, hence every | is replaced even those that do not need replacing. Changing the replace to be\ns/[\\s\\t]+|/|/g\n\nwill only change the | characters that are preceded by one or more spaces and tabs.\nI do not have sed available, but I did an experiment with Perl. On the data I used the script with the * took almost 7 times longer than the script with +.\nThe times were consistent across the runs. For the + the difference between minimum and maximum times was 4% of the average and for the * it was 3.6%. The ratio of the average times was 1::6.9 for +::*.\nDetails of experiment\nTested using an 80mb file with just over 180000 occurrences of [st]\\., these are the lowercase characters s and t.\nThe test used a batch command file with 30 of each of these two commands, alternating star and plus.\nperl -f TestPlus.pl input.ltrar > zz.oo\nperl -f TestStar.pl input.ltrar > zz.oo\n\nOne script is below, the other merely changed the * to + and star to plus.\n#! /bin/usr/perl\nuse strict;\nuse warnings;\nuse Time::HiRes qw( gettimeofday tv_interval );\n\nmy $t0 = [gettimeofday()];\nwhile(<>)\n{\n    s/[st]*\\././g;\n}\n\nmy $elapsed = tv_interval ( $t0 );\nprint STDERR \"Elapsed star $elapsed\\n\";\n\nPerl version used:\nc:\\test> perl -v\nThis is perl 5, version 16, subversion 3 (v5.16.3) built for MSWin32-x64-multi-thread\n(with 1 registered patch, see perl -V for more detail)\n\nCopyright 1987-2012, Larry Wall\n\nBinary build 1603 [296746] provided by ActiveState http://www.ActiveState.com\nBuilt Mar 13 2013 13:31:10\n\n", "\nWith your shown samples and attempts, please try following awk code.\necho \"/path/to/file 20-456 (1).jpg\" | \nawk 'BEGIN{FS=OFS=\"/\"} {gsub(/ /,\"_\",$NF);gsub(/-|\\(|\\)/,\"\",$NF)} 1'\n\nExplanation: Simple explanation would be, by echo printing value /path/to/file 20-456 (1).jpg as a standard input to awk program. In awk program, setting FS and OFS to / in BEGIN section. Then in main program using gsub to globally substitute space with _ in last field($NF) and then globally substitute - OR ( OR ) with NULL in last field and then mentioning 1 will print that line.\n", "\nIf all the files contain K036 the below script will help you.\n#!/bin/bash\ndirectory=\"/path/to/file\"\n\ncd \"$directory\"\n\nfor file in ZAF_MM_CYCLE_K*.xls; do\n\n    code=$(echo \"$file\" | cut -d'_' -f4 | cut -d'.' -f1)\n\n    sed -i \"s/K036/$code/g\" \"$file\"\n\n\n    echo \"Code replaced in $file\"\ndone\n\nwhere the\n\necho \"$file\" | cut -d'_' -f4 | cut -d'.' -f1\n\nwill extract the file name k051 from the filename\n\nsed -i \"s/K036/$code/g\" \"$file\"\n\nwill replace the old value with new one\nSo this would help you in your case.\n", "\nIf all the files contain K036 the below script will help you.\n#!/bin/bash\ndirectory=\"/path/to/file\"\n\ncd \"$directory\"\n\nfor file in ZAF_MM_CYCLE_K*.xls; do\n\n    code=$(echo \"$file\" | cut -d'_' -f4 | cut -d'.' -f1)\n\n    sed -i \"s/K036/$code/g\" \"$file\"\n\n\n    echo \"Code replaced in $file\"\ndone\n\nwhere the\n\necho \"$file\" | cut -d'_' -f4 | cut -d'.' -f1\n\nwill extract the file name k051 from the filename\n\nsed -i \"s/K036/$code/g\" \"$file\"\n\nwill replace the old value with new one\nSo this would help you in your case.\n", "\nsed works on lines that end in \\x0a, the character is not part of the string it acts on.\nPerl to the rescue!\nperl -i -pe 's/\\x0a/\\x25/' saut-de-ligne_UTF-8\n\n"]}