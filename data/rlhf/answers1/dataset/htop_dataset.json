{"prompt": ["top and htop are commonly used tools to monitor processes and computer resources, but why is the status of top itself always R (in the S column of the top)? For example, here is a screenshot of the top command:top - 12:42:33 up  2:48,  1 user,  load average: 0,11, 0,17, 0,17\nTasks: 319 total,   1 running, 318 sleeping,   0 stopped,   0 zombie\n%Cpu(s):  1,1 us,  0,1 sy,  0,0 ni, 98,8 id,  0,0 wa,  0,0 hi,  0,0 si,  0,0 st\nMiB Mem :  15968,5 total,   4031,8 free,   2196,1 used,   9740,7 buff/cache\nMiB Swap: 122069,0 total, 122069,0 free,      0,0 used.  13325,4 avail Mem \n\n    PID USER      PR  NI    VIRT    RES    SHR S  %CPU  %MEM     TIME+ COMMAND\n   2264 xxxxxx    20   0 2784640 320344 184092 S   6,0   2,0   9:14.83 Web Content\n   2195 xxxxxx    20   0 3996144 481160 197788 S   2,7   2,9   7:46.13 firefox\n   1704 root      20   0  227712 101204  82140 S   1,3   0,6   3:26.54 Xorg\n   2993 xxxxxx    20   0  817416  54452  41724 S   1,0   0,3   0:04.27 gnome-terminal-\n   1856 xxxxxx    20   0 4521152 385832 123440 S   0,7   2,4   2:39.79 gnome-shell\n   1202 root     -51   0       0      0      0 S   0,3   0,0   0:52.07 irq/44-nvidia\n   5048 xxxxxx    20   0   11980   3888   3132 R   0,3   0,0   0:00.12 top\n      1 root      20   0  167972  11864   8480 S   0,0   0,1   0:03.91 systemd\n      2 root      20   0       0      0      0 S   0,0   0,0   0:00.00 kthreadd\n      3 root       0 -20       0      0      0 I   0,0   0,0   0:00.00 rcu_gp\n      4 root       0 -20       0      0      0 I   0,0   0,0   0:00.00 rcu_par_gp\n      6 root       0 -20       0      0      0 I   0,0   0,0   0:00.00 kworker/0:0H-kblockd\n      9 root       0 -20       0      0      0 I   0,0   0,0   0:00.00 mm_percpu_wq\n     10 root      20   0       0      0      0 S   0,0   0,0   0:00.09 ksoftirqd/0\n     11 root      20   0       0      0      0 I   0,0   0,0   0:01.49 rcu_sched\n     12 root      rt   0       0      0      0 S   0,0   0,0   0:00.02 migration/0\n     13 root     -51   0       0      0      0 S   0,0   0,0   0:00.00 idle_inject/0\n\nFrom the source code of top (procps/top), it gets process statuses from the file /proc/<pid>/stat, while the status of top, for most of the time, is S (sleeping) if it is continuously printed with the following command:watch -n.1 \"cat /proc/<top-pid>/stat | grep -o \\\"[S|R]\\\"\"\n", "I am a bit confused about what the tool \"htop\" shows as cpu usage and average load. I was asked to have a look at a webserver which is performing incredibly slow.\nI googled a bit and always found the statement that everyting above 1.00 in average load is terrible when you only have one cpu in the machine.However, my \"htop\" experience looks like this:\nhtop screenshotCan someone please tell me what exactly is going on here? Is this bad or do I misunderstand everything?Thank you for your help.", "I have a node application that uses Socket.IO for the messaging. And I run it usingnode --expose_gc /path/to/app.jsNow, when I check on the htop utility, I noticed that instead of 1, I am getting multiple processes of the same command.Can someone, in noob terms, explain to me why and what is going on here? I'm also worried that it may consume unexpected memory/cpu usage too."], "chosen": ["\nThis is one example of the so called observer effect popularized by the physicist Werner Heisenberg: he stated that the act of observing a system inevitably alters its state. Hence, when top/htop observed their proper state, they can't see themselves sleeping ;-)\n", "\nThe htop screenshot is showing you each of the cores of the CPU and the usage for each. What you really want to be looking at are the processes and how much CPU they are consuming.\nThere's an article here which explains it in more detail: http://www.thegeekstuff.com/2011/09/linux-htop-examples\nGoodluck!\n", "\nsocket.io is just a library that hooks into a web server and listens for certain incoming requests (those requests that initiate a webSocket/socket.io connection).  Once a socket.io connection is initiated, it just uses normal socket programming to send/receive messages.\nIt does not start up any additional processes by itself.\nYour multiple processes are either because you accidentally started your own app multiple times without shutting it down or there is something else in your app that is starting up multiple processes.  socket.io does not do that.\n"], "rejected": ["\nWell... if you are running top (or htop), and top (or htop) gets its own status from /proc/self/stat... then it must be running, otherwise how would it be possible that it got its status while not running? The sole fact that a process is reading its own status means that the status must be running at the time of reading.\nYou can try this with other programs too, if you want:\n$ cat /proc/self/stat\n32482 (cat) R ...\n$ head /proc/self/stat\n32491 (head) R ...\n$ tail /proc/self/stat\n32497 (tail) R ...\n$ less /proc/self/stat\n32503 (less) R ...\n\n", "\nIn your screenshot the CPU usage bars are colored in green and red. Press '?' in htop for a help screen to show up. From there you will see that green color is for a normal priority userspace applications CPU usage and the red color is for kernel threads.\nBasically, in your screenshot all the CPU cores are 100% busy and most of the time they spend in the kernel.\nYes, this is bad. Further investigation is needed to tell what exactly is going on here.\n", "\nsocket.io does not fork or spawn any child processes.\nusually sub processes that run node.js are spawned via cluster module but socket.io does no such thing.\nit just adds a handler on top of a http server.\n"]}