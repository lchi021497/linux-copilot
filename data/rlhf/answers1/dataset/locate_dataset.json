{"prompt": ["Heloo,\nI am new in linux. I am trying to display the last updates of \u00b4mlocate\u00b4. So that when I use the locate command it finds items according to the last update of \u00b4mlocate\u00b4.How can I do it?Thanks for your reponse,\nGerard", "I have been searching for a command that will return files from the current directory which contain a string in the filename. I have seen locate and find commands that can find files beginning with something first_word* or ending with something *.jpg. How can I return a list of files which contain a string in the filename? For example, if 2012-06-04-touch-multiple-files-in-linux.markdown was a file in the current directory. How could I return this file and others containing the string touch? Using a command such as find '/touch/'", "I have been searching for a command that will return files from the current directory which contain a string in the filename. I have seen locate and find commands that can find files beginning with something first_word* or ending with something *.jpg. How can I return a list of files which contain a string in the filename? For example, if 2012-06-04-touch-multiple-files-in-linux.markdown was a file in the current directory. How could I return this file and others containing the string touch? Using a command such as find '/touch/'", "I have been searching for a command that will return files from the current directory which contain a string in the filename. I have seen locate and find commands that can find files beginning with something first_word* or ending with something *.jpg. How can I return a list of files which contain a string in the filename? For example, if 2012-06-04-touch-multiple-files-in-linux.markdown was a file in the current directory. How could I return this file and others containing the string touch? Using a command such as find '/touch/'", "I have been searching for a command that will return files from the current directory which contain a string in the filename. I have seen locate and find commands that can find files beginning with something first_word* or ending with something *.jpg. How can I return a list of files which contain a string in the filename? For example, if 2012-06-04-touch-multiple-files-in-linux.markdown was a file in the current directory. How could I return this file and others containing the string touch? Using a command such as find '/touch/'", "I have been searching for a command that will return files from the current directory which contain a string in the filename. I have seen locate and find commands that can find files beginning with something first_word* or ending with something *.jpg. How can I return a list of files which contain a string in the filename? For example, if 2012-06-04-touch-multiple-files-in-linux.markdown was a file in the current directory. How could I return this file and others containing the string touch? Using a command such as find '/touch/'", "I have been searching for a command that will return files from the current directory which contain a string in the filename. I have seen locate and find commands that can find files beginning with something first_word* or ending with something *.jpg. How can I return a list of files which contain a string in the filename? For example, if 2012-06-04-touch-multiple-files-in-linux.markdown was a file in the current directory. How could I return this file and others containing the string touch? Using a command such as find '/touch/'", "I have been searching for a command that will return files from the current directory which contain a string in the filename. I have seen locate and find commands that can find files beginning with something first_word* or ending with something *.jpg. How can I return a list of files which contain a string in the filename? For example, if 2012-06-04-touch-multiple-files-in-linux.markdown was a file in the current directory. How could I return this file and others containing the string touch? Using a command such as find '/touch/'", "I did a good bit of searching and testing on my own, but I can't seem to find the best way to achieve this goal. I would like to have a bash one liner that will find a script on the machine, execute the script and have the ability to add switches or needed information in my case to execute the script successfully.To get a little more specific, I am in Kali Linux and I run the locate command like so:\nlocate pattern_create\nwhich returns: \n/usr/share/metasploit-framework/tools/pattern_create.rb\nSo I thought about piping this into xargs to run the script like so:\nlocate pattern_create | xargs ruby\nbut of course I could not specify the options I need to that would run the script successfully, which would be:\nruby /usr/share/metasploit-framework/tools/pattern_create.rb 2700\nI came up with a work around, but I feel that it's somewhat sloppy and this could be done easier, and that's where I hope I could get any input/feedback.I found out I can run:\npattern_create=$(locate pattern_create) && ruby $pattern_create 2700\nto get exactly what I need, but then I am dealing with environment variables which I would not want a bunch of when doing this often. I was hoping to figure this out with xargs or maybe and even cleaner way if possible. I know this can be done easily with find -exec, but that won't work in my case where I don't where the script is stored.Any help would be awesome, I appreciate everyone's time. Thank you.", "Been working on some custom ISO for Ubuntu, so I have lots of different mounts, etc. I wanted to scan across everything to find all of the initrd.img* files, but I'm getting clocked by \"features\" in the find command. locate command won't work because this stuff is not installed.developer@developer-u32-dev-VM:/$ sudo find -iname *initrd.img*\nfind: paths must precede expression: initrd.img.old\nUsage: find [-H] [-L] [-P] [-Olevel] [-D help|tree|search|stat|rates|opt|exec] [path...] [expression]\ndeveloper@developer-u32-dev-VM:/$ sudo find -iname *initrd.img-*\n./boot/initrd.img-3.19.0-25-generic\n./boot/initrd.img-3.19.0-15-generic\n./boot/initrd.img-3.19.0-23-generic\nAs you can see I can use find to identify the physical files, but I need to locate all of the initrd.img links.How does one go about this?", "From what I understand there is a cron job that runs on unix systems that cache the filesystem to make quicker calls (or something like that) What is that process called and where is that database stored? "], "chosen": ["\nThanks! That was exactly my question.\nHow about if I need to retrieve the last 10 updates for example?\nBR,\nGerard\n", "\nUse grep as follows:\ngrep -R \"touch\" .\n\n-R means recurse. If you would rather not go into the subdirectories, then skip it.\n-i means \"ignore case\". You might find this worth a try as well.\n", "\nUse find:\nfind . -maxdepth 1 -name \"*string*\" -print\nIt will find all files in the current directory (delete maxdepth 1 if you want it recursive) containing \"string\" and will print it on the screen.\nIf you want to avoid file containing ':', you can type:\nfind . -maxdepth 1 -name \"*string*\" ! -name \"*:*\" -print\nIf you want to use grep (but I think it's not necessary as far as you don't want to check file content) you can use:\nls | grep touch\nBut, I repeat, find is a better and cleaner solution for your task.\n", "\nThe -maxdepth option should be before the -name option, like below.,\nfind . -maxdepth 1 -name \"string\" -print\n\n", "\nfind $HOME -name \"hello.c\" -print\n\nThis will search the whole $HOME (i.e. /home/username/) system for any files named \u201chello.c\u201d and display their pathnames:\n/Users/user/Downloads/hello.c\n/Users/user/hello.c\n\nHowever, it will not match HELLO.C or HellO.C. To match is case insensitive pass the -iname option as follows:\nfind $HOME -iname \"hello.c\" -print\n\nSample outputs:\n/Users/user/Downloads/hello.c\n/Users/user/Downloads/Y/Hello.C\n/Users/user/Downloads/Z/HELLO.c\n/Users/user/hello.c\n\nPass the -type f option to only search for files:\nfind /dir/to/search -type f -iname \"fooBar.conf.sample\" -print\nfind $HOME -type f -iname \"fooBar.conf.sample\" -print\n\nThe -iname works either on GNU or BSD (including OS X) version find command. If your version of find command does not supports -iname, try the following syntax using grep command:\nfind $HOME | grep -i \"hello.c\"\nfind $HOME -name \"*\" -print | grep -i \"hello.c\"\n\nOR try\nfind $HOME -name '[hH][eE][lL][lL][oO].[cC]' -print\n\nSample outputs:\n/Users/user/Downloads/Z/HELLO.C\n/Users/user/Downloads/Z/HEllO.c\n/Users/user/Downloads/hello.c\n/Users/user/hello.c\n\n", "\nIf the string is at the beginning of the name, you can do this\n$ compgen -f .bash\n.bashrc\n.bash_profile\n.bash_prompt\n\n", "\nAn alternative to the many solutions already provided is making use of the glob **.  When you use bash with the option globstar (shopt -s globstar) or you make use of zsh, you can just use the glob ** for this.\n**/bar\n\ndoes a recursive directory search for files named bar (potentially including the file bar in the current directory). Remark that this cannot be combined with other forms of globbing within the same path segment; in that case, the * operators revert to their usual effect.\nNote that there is a subtle difference between zsh and bash here. While bash will traverse soft-links to directories, zsh will not. For this you have to use the glob ***/ in zsh.\n", "\nfind / -exec grep -lR \"{test-string}\" {} \\;\n\n", "\nYou can do:\nruby $(locate pattern_create)\n\nBut be aware that if there are multiple lines returned by locate, then this may not do what you wanted.\n", "\nQuote your pattern. The shell is globbing it. Change\nsudo find -iname *initrd.img*\n\nto\nsudo find -iname \"*initrd.img*\"\n\n", "\nThis applies for os X 10.10 \nThe actual database is: \n/var/db/locate.database\"\nNAME\n     locate.updatedb -- update locate database\nSYNOPSIS\n     /usr/libexec/locate.updatedb\nDESCRIPTION\n     The locate.updatedb utility updates the database used by locate(1).  It\n     is typically run once a week by the\n     /System/Library/LaunchDaemons/com.apple.locate.plist job.\n The contents of the newly built database can be controlled by the\n /etc/locate.rc file.\n\nENVIRONMENT\n     LOCATE_CONFIG            path to the configuration file\nFILES\n     /var/db/locate.database  the default database\n     /etc/locate.rc           the configuration file\nSEE ALSO\n     locate(1), launchd(8)\n"], "rejected": ["\nI think you mean last update to database. \nmlocate -S  |  head -1   | cut -d' ' -f2 | tr -d ':'  | xargs ls -ltr | cut -d' ' -f6-8\n\nDemo: \n$mlocate -S  |  head -1   | cut -d' ' -f2 | tr -d ':'  | xargs ls -ltr | cut -d' ' -f6-8\nMar 30 04:28\n$\n\n", "\ngrep -R \"somestring\" | cut -d \":\" -f 1\n\n", "\ngrep -R \"somestring\" | cut -d \":\" -f 1\n\n", "\ngrep -R \"somestring\" | cut -d \":\" -f 1\n\n", "\ngrep -R \"somestring\" | cut -d \":\" -f 1\n\n", "\ngrep -R \"somestring\" | cut -d \":\" -f 1\n\n", "\ngrep -R \"somestring\" | cut -d \":\" -f 1\n\n", "\ngrep -R \"somestring\" | cut -d \":\" -f 1\n\n", "\nThis is a dangerous thing to do as you do not know what locate will return and you could end up executing arbitrary scripts.  I suggest that you use an intermediate script which will protect against the unexpected, such as finding no scripts or finding more than one.\n#! /bin/sh\n#\nif [ $# -eq 0 ]\nthen\n    echo >&2 \"Usage: $0 script arguments\"\n    exit -1\nfi\nscript=$(locate $1)\nnumfound=$(locate $1 | wc -l)\nshift\nif [ $numfound -eq 1 ]\nthen\n    # Only run the script if exactly one match is found\n    ruby $script $*\nelif [ $numfound -eq 0 ]\nthen\n    echo \"No matching scripts found\" >&2\n    exit -1\nelse\n    echo \"Too many scripts found - $script\" >&2\n    exit -1\nfi\n\n", "\nTo find all symlinks pointing to initrd.img\n$ find -lname \\*initrd.img*\n\n", "\nIt's called updatedb, docs here: http://linux.die.net/man/8/updatedb\n"]}