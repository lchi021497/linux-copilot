{"prompt": ["For child processes, the wait() and waitpid() functions can be used to suspends  execution  of  the current process until a child has exited. But this function can not be used for non-child processes. Is there another function, which can wait for exit of any process ?", "For child processes, the wait() and waitpid() functions can be used to suspends  execution  of  the current process until a child has exited. But this function can not be used for non-child processes. Is there another function, which can wait for exit of any process ?", "For child processes, the wait() and waitpid() functions can be used to suspends  execution  of  the current process until a child has exited. But this function can not be used for non-child processes. Is there another function, which can wait for exit of any process ?", "For child processes, the wait() and waitpid() functions can be used to suspends  execution  of  the current process until a child has exited. But this function can not be used for non-child processes. Is there another function, which can wait for exit of any process ?", "For child processes, the wait() and waitpid() functions can be used to suspends  execution  of  the current process until a child has exited. But this function can not be used for non-child processes. Is there another function, which can wait for exit of any process ?", "For child processes, the wait() and waitpid() functions can be used to suspends  execution  of  the current process until a child has exited. But this function can not be used for non-child processes. Is there another function, which can wait for exit of any process ?", "For child processes, the wait() and waitpid() functions can be used to suspends  execution  of  the current process until a child has exited. But this function can not be used for non-child processes. Is there another function, which can wait for exit of any process ?", "For child processes, the wait() and waitpid() functions can be used to suspends  execution  of  the current process until a child has exited. But this function can not be used for non-child processes. Is there another function, which can wait for exit of any process ?", "For child processes, the wait() and waitpid() functions can be used to suspends  execution  of  the current process until a child has exited. But this function can not be used for non-child processes. Is there another function, which can wait for exit of any process ?", "For child processes, the wait() and waitpid() functions can be used to suspends  execution  of  the current process until a child has exited. But this function can not be used for non-child processes. Is there another function, which can wait for exit of any process ?", "For child processes, the wait() and waitpid() functions can be used to suspends  execution  of  the current process until a child has exited. But this function can not be used for non-child processes. Is there another function, which can wait for exit of any process ?", "For child processes, the wait() and waitpid() functions can be used to suspends  execution  of  the current process until a child has exited. But this function can not be used for non-child processes. Is there another function, which can wait for exit of any process ?", "For child processes, the wait() and waitpid() functions can be used to suspends  execution  of  the current process until a child has exited. But this function can not be used for non-child processes. Is there another function, which can wait for exit of any process ?", "I recently posted a question asking if it was possible to prevent PID's from being re-used.So far the answer appears to be no. (Which is fine.)However, the user Diego Torres Milano added an answer to that question, and my question here is in regards to that answer.Diego answered,\nIf you are afraid of reusing PID's, which won't happen if you wait as\n  other answers explain, you can use\necho 4194303 > /proc/sys/kernel/pid_max\n\nto decrease your fear ;-)\nI don't actually understand why Diego has used the number 4194303 here, but that's another question.My understanding was that I had a problem with the following code:for pid in \"${PIDS[@]}\"\ndo\n    wait $pid\ndone\nThe problem being that I have multiple PIDs in an array, and that the for loop will run the wait command sequentially with each PID in the array, however I cannot predict that the processes will finish in the same order that their PIDs are stored in this array.ie; the following could happen:\nStart waiting for PID in array index 0\nProcess with PID in index 1 of array terminates\nNew job(s) run on system, resulting in PID which is stored in index 1 of PID array being reused for another process\nwait terminates as PID in array index 0 exits\nStart waiting for PID in array index 0, except this is now a different process and we have no idea what it is\nThe process which was run which re-used the PID which wait is currently waiting for never terminates. Perhaps it is the PID of a mail server or something which a system admin has started.\nwait keeps waiting until the next serious linux bug is found and the system is rebooted or there is a power outage\nDiego said:\nwhich won't happen if you wait as other answers explain\nie; that the situation I have described above cannot happen.Is Diego correct?\nIf so, why can the situation I discribed above not occur?\nOr is Diego not correct?\nIf so, well, then I post a new question later today...\nAdditional notesIt has occured to me that this question might be confusing, unless you are aware that the PID's are PID's of processes launched in the background. ie;my_function &\nPID=\"$!\"\nPIDS+=($PID)\n", "I recently posted a question asking if it was possible to prevent PID's from being re-used.So far the answer appears to be no. (Which is fine.)However, the user Diego Torres Milano added an answer to that question, and my question here is in regards to that answer.Diego answered,\nIf you are afraid of reusing PID's, which won't happen if you wait as\n  other answers explain, you can use\necho 4194303 > /proc/sys/kernel/pid_max\n\nto decrease your fear ;-)\nI don't actually understand why Diego has used the number 4194303 here, but that's another question.My understanding was that I had a problem with the following code:for pid in \"${PIDS[@]}\"\ndo\n    wait $pid\ndone\nThe problem being that I have multiple PIDs in an array, and that the for loop will run the wait command sequentially with each PID in the array, however I cannot predict that the processes will finish in the same order that their PIDs are stored in this array.ie; the following could happen:\nStart waiting for PID in array index 0\nProcess with PID in index 1 of array terminates\nNew job(s) run on system, resulting in PID which is stored in index 1 of PID array being reused for another process\nwait terminates as PID in array index 0 exits\nStart waiting for PID in array index 0, except this is now a different process and we have no idea what it is\nThe process which was run which re-used the PID which wait is currently waiting for never terminates. Perhaps it is the PID of a mail server or something which a system admin has started.\nwait keeps waiting until the next serious linux bug is found and the system is rebooted or there is a power outage\nDiego said:\nwhich won't happen if you wait as other answers explain\nie; that the situation I have described above cannot happen.Is Diego correct?\nIf so, why can the situation I discribed above not occur?\nOr is Diego not correct?\nIf so, well, then I post a new question later today...\nAdditional notesIt has occured to me that this question might be confusing, unless you are aware that the PID's are PID's of processes launched in the background. ie;my_function &\nPID=\"$!\"\nPIDS+=($PID)\n", "I recently posted a question asking if it was possible to prevent PID's from being re-used.So far the answer appears to be no. (Which is fine.)However, the user Diego Torres Milano added an answer to that question, and my question here is in regards to that answer.Diego answered,\nIf you are afraid of reusing PID's, which won't happen if you wait as\n  other answers explain, you can use\necho 4194303 > /proc/sys/kernel/pid_max\n\nto decrease your fear ;-)\nI don't actually understand why Diego has used the number 4194303 here, but that's another question.My understanding was that I had a problem with the following code:for pid in \"${PIDS[@]}\"\ndo\n    wait $pid\ndone\nThe problem being that I have multiple PIDs in an array, and that the for loop will run the wait command sequentially with each PID in the array, however I cannot predict that the processes will finish in the same order that their PIDs are stored in this array.ie; the following could happen:\nStart waiting for PID in array index 0\nProcess with PID in index 1 of array terminates\nNew job(s) run on system, resulting in PID which is stored in index 1 of PID array being reused for another process\nwait terminates as PID in array index 0 exits\nStart waiting for PID in array index 0, except this is now a different process and we have no idea what it is\nThe process which was run which re-used the PID which wait is currently waiting for never terminates. Perhaps it is the PID of a mail server or something which a system admin has started.\nwait keeps waiting until the next serious linux bug is found and the system is rebooted or there is a power outage\nDiego said:\nwhich won't happen if you wait as other answers explain\nie; that the situation I have described above cannot happen.Is Diego correct?\nIf so, why can the situation I discribed above not occur?\nOr is Diego not correct?\nIf so, well, then I post a new question later today...\nAdditional notesIt has occured to me that this question might be confusing, unless you are aware that the PID's are PID's of processes launched in the background. ie;my_function &\nPID=\"$!\"\nPIDS+=($PID)\n", "I'm am trying to use the fork method to call a different program and wait until it completes,\nI tried to check what is the problem and it seems that the wait function doesn't wait to the childReturns and it makes doesn't print the answer.\n(the assignment was to loop compare method until ctrl+c )the program I call is a comparator that compares 2  strings.the problem is that the wait func doesn't wait for the child\nthe compile is GCC#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n#include <unistd.h>\n#include <sys/wait.h>\n\n#define LINELEN (80)\n\nchar *mygets(char *buf, int len);\nchar *progName(char *prog);\nint main(int argc, char *argv[])\n{\n    char *args[3];\n    char str1[LINELEN + 1];\n    char str2[LINELEN + 1];\n    int childReturns;\n    if (argc != 2)\n        return -1;\n\n    char *prog = progName(argv[1]);\n    if (prog == NULL)\n        return -1;\n    args[0] = prog;\n    while (1)\n    {\n        printf(\"Enter string:\");\n        if (mygets(str1, LINELEN) == NULL)\n            break;\n        printf(\"Enter  string:\");\n        if (mygets(str2, LINELEN) == NULL)\n            break;\n        args[1] = str1;\n        args[2] = str2;\n        int processId = fork();\n        if (processId == 0)\n            execvp(prog, args);\n        else\n        {\n            wait(&childReturns); // Wait for the child\n            printf(\"Child  code is %d\\n\", WEXITSTATUS(childReturns));\n        }\n    }\n    free(prog);\n    return 0;\n}\nchar *progName(char *prog)\n{\n    char *filePath = (char *)malloc(strlen(prog) + 3);\n    if (!filePath)\n        return NULL;\n    strcpy(filePath, \"./\");\n    strcat(filePath, prog);\n    return filePath;\n}\n\nchar *mygets(char *buf, int len)\n{\n    char *retval;\n\n    retval = fgets(buf, len, stdin);\n    buf[len] = '\\0';\n    if (buf[strlen(buf) - 1] == 10) /* trim \\r */\n        buf[strlen(buf) - 1] = '\\0';\n    else if (retval)\n        while (getchar() != '\\n')\n            ; /* get to eol */\n\n    return retval;\n} ```\n", "I'm am trying to use the fork method to call a different program and wait until it completes,\nI tried to check what is the problem and it seems that the wait function doesn't wait to the childReturns and it makes doesn't print the answer.\n(the assignment was to loop compare method until ctrl+c )the program I call is a comparator that compares 2  strings.the problem is that the wait func doesn't wait for the child\nthe compile is GCC#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n#include <unistd.h>\n#include <sys/wait.h>\n\n#define LINELEN (80)\n\nchar *mygets(char *buf, int len);\nchar *progName(char *prog);\nint main(int argc, char *argv[])\n{\n    char *args[3];\n    char str1[LINELEN + 1];\n    char str2[LINELEN + 1];\n    int childReturns;\n    if (argc != 2)\n        return -1;\n\n    char *prog = progName(argv[1]);\n    if (prog == NULL)\n        return -1;\n    args[0] = prog;\n    while (1)\n    {\n        printf(\"Enter string:\");\n        if (mygets(str1, LINELEN) == NULL)\n            break;\n        printf(\"Enter  string:\");\n        if (mygets(str2, LINELEN) == NULL)\n            break;\n        args[1] = str1;\n        args[2] = str2;\n        int processId = fork();\n        if (processId == 0)\n            execvp(prog, args);\n        else\n        {\n            wait(&childReturns); // Wait for the child\n            printf(\"Child  code is %d\\n\", WEXITSTATUS(childReturns));\n        }\n    }\n    free(prog);\n    return 0;\n}\nchar *progName(char *prog)\n{\n    char *filePath = (char *)malloc(strlen(prog) + 3);\n    if (!filePath)\n        return NULL;\n    strcpy(filePath, \"./\");\n    strcat(filePath, prog);\n    return filePath;\n}\n\nchar *mygets(char *buf, int len)\n{\n    char *retval;\n\n    retval = fgets(buf, len, stdin);\n    buf[len] = '\\0';\n    if (buf[strlen(buf) - 1] == 10) /* trim \\r */\n        buf[strlen(buf) - 1] = '\\0';\n    else if (retval)\n        while (getchar() != '\\n')\n            ; /* get to eol */\n\n    return retval;\n} ```\n", "I am new to processes in linux and c. \nI am using this straightforward example:#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n\nint main(int argc, const char * argv[]) {\n\npid_t child_pid_or_zero = fork(); //fork returns twice\n\nif(child_pid_or_zero < 0)\n{\n    //if fork returns a number smaller than zero, something wrong happened\n    perror(\"Something wrong happened\\n\");\n    exit(-1);\n}\n\nif(child_pid_or_zero > 0)\n{\n    //if fork returns a number greater than zero, this is the parent process\n    printf(\"I'm the parent, my pid is: %d\\t My child pid is %d\\n\", getpid(), child_pid_or_zero);\n    wait(NULL);\n}\n\nelse\n{\n    //this means that fork now returned 0, the child process is running\n    printf(\"I am the child with pid: %d\\t My parent pid is: %d\\n\",child_pid_or_zero, getppid());\n\n}\n\n\nreturn 0;\n}\nIf I were to omit the wait() method in the \nif(child_pid_or_zero > 0)\nWhat would happen? I tried this myself, and apparently, there was no immediate difference. Do we always need to use a wait(), or does this only apply when the child is supposed to perform heavy calculations etc ?Thanks in advance.", "I am new to processes in linux and c. \nI am using this straightforward example:#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n\nint main(int argc, const char * argv[]) {\n\npid_t child_pid_or_zero = fork(); //fork returns twice\n\nif(child_pid_or_zero < 0)\n{\n    //if fork returns a number smaller than zero, something wrong happened\n    perror(\"Something wrong happened\\n\");\n    exit(-1);\n}\n\nif(child_pid_or_zero > 0)\n{\n    //if fork returns a number greater than zero, this is the parent process\n    printf(\"I'm the parent, my pid is: %d\\t My child pid is %d\\n\", getpid(), child_pid_or_zero);\n    wait(NULL);\n}\n\nelse\n{\n    //this means that fork now returned 0, the child process is running\n    printf(\"I am the child with pid: %d\\t My parent pid is: %d\\n\",child_pid_or_zero, getppid());\n\n}\n\n\nreturn 0;\n}\nIf I were to omit the wait() method in the \nif(child_pid_or_zero > 0)\nWhat would happen? I tried this myself, and apparently, there was no immediate difference. Do we always need to use a wait(), or does this only apply when the child is supposed to perform heavy calculations etc ?Thanks in advance.", "The two child processes perform sorting by different methods. I want the parent process to wait until at least one child process terminates. This code is not giving me the required output.#include <stdio.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n\n\nint main(int argc, char *argv[])\n{\n    pid_t pid1, pid2;\n    int status;\n    pid1 = fork();\n    pid2 = fork();\n    if(pid1==0 && pid2 !=0)\n    {\n        //first child performing selection sort\n        exit(0);\n    }\n    if(pid1>0 && pid2 > 0)\n    {\n        wait(&status);\n        if(WIFEXITED(status))\n        {\n            printf(\"Parent process executed %d\\n\",WEXITSTATUS(status));\n        }\n    }\n    if(pid1>0 && pid2 ==0)\n    {\n        //second child performing bubble sort\n        \n        exit(0);\n    }\n    \n}\n", "I was looking at a didactical example, and I saw that my professor used this syntax to print the exit value of a child process:wait(&value);\nprintf(\"last two bytes of value are %d - %d\\n\",(value>>8)&255,value&255); \nThe \"value\" variable is defined as an int, and the wait() is used by the parent to wait the child process generated through a \"fork()\". The child can be terminated by a signal or it terminates by itself after a fixed amount of time.\nFrom what I've understood, since the variable \"value\" is an int it has 4 bytes, but the exit code of a \"exit(int)\" is written in just one of the four bytes. If the process is not terminated by an exit(), but instead from a signal, in another of those four bytes I recive the code of that signal.\nSo I guess that the fact that I have \"(value>>8)\" is due to this use of the bytes, but what I don't understand is why I use the syntax with \"&255\" to print those values.", "I was looking at a didactical example, and I saw that my professor used this syntax to print the exit value of a child process:wait(&value);\nprintf(\"last two bytes of value are %d - %d\\n\",(value>>8)&255,value&255); \nThe \"value\" variable is defined as an int, and the wait() is used by the parent to wait the child process generated through a \"fork()\". The child can be terminated by a signal or it terminates by itself after a fixed amount of time.\nFrom what I've understood, since the variable \"value\" is an int it has 4 bytes, but the exit code of a \"exit(int)\" is written in just one of the four bytes. If the process is not terminated by an exit(), but instead from a signal, in another of those four bytes I recive the code of that signal.\nSo I guess that the fact that I have \"(value>>8)\" is due to this use of the bytes, but what I don't understand is why I use the syntax with \"&255\" to print those values.", "I am trying to make a program containing 2 pipes, and in my program, the child will run first, the parent will run at the end.\nThe result shows that Child 2, then Child1, and keep pending.\nIt seems my parent is still waiting for some child process to be finished, but I only got 2 child process in this program~ Please help me :) Thanks!#include <stdio.h>\n#include <unistd.h>\n#include <assert.h>\n#include <fcntl.h>\n#include <sys/types.h>\n\nint main(void)\n{\n    int pipefd[2];\n    int pipefd2[2];\n    int rv= pipe(pipefd);\n    assert(rv > -1);\n    int cid = fork();\n    assert(cid > -1);\n    int status;\n    if( cid > 0 ){\n        //waitpid(cid,NULL,0);\n        printf(\"P %d %d\\n\",getpid(),getppid());\n        wait(NULL);\n        printf(\"Parent \\n\");\n        close(0);\n        dup(pipefd[0]);\n        close(pipefd[0]);\n        close(pipefd[1]);\n\n        char *const wc_argv[] = {\"wc\", \"-l\", NULL};\n        execvp(\"wc\", wc_argv);\n        //Parent - Redirect stdout to the write end of the pipe, and execute \"ls -l\"\n\n    }else{\n        int rv1= pipe(pipefd2);\n        assert(rv1 > -1);\n        int cid1 = fork();\n        assert(cid1 > -1);\n\n        if(cid1>0){\n            printf(\"C1 %d %d\\n\",getpid(),getppid());\n            wait(NULL);\n            printf(\"Child1\\n\");\n            //Child 1 (parent of child 2)\n            close(0);\n            dup(pipefd[0]);\n            close(1);\n            dup(pipefd2[1]);\n            close(pipefd[0]);\n            close(pipefd[1]);\n            close(pipefd2[0]);\n            close(pipefd2[1]);\n            char *const grep_argv[] = {\"grep\", \"D\", NULL};\n            execvp(\"grep\", grep_argv);\n        }else{\n            printf(\"C2 %d %d\\n\",getpid(),getppid());\n            printf(\"Child2\\n\");\n            //Child 2 (child of child 1)\n            close(1);\n            dup(pipefd2[1]);\n            close(pipefd2[0]);\n            close(pipefd2[1]);\n            close(pipefd[0]);\n            close(pipefd[1]);\n            char *const ls_argv[] = {\"ls\", \"-l\", NULL};\n            execvp(\"ls\", ls_argv);\n\n        }\n\n    }\n}\n", "I am trying to make a program containing 2 pipes, and in my program, the child will run first, the parent will run at the end.\nThe result shows that Child 2, then Child1, and keep pending.\nIt seems my parent is still waiting for some child process to be finished, but I only got 2 child process in this program~ Please help me :) Thanks!#include <stdio.h>\n#include <unistd.h>\n#include <assert.h>\n#include <fcntl.h>\n#include <sys/types.h>\n\nint main(void)\n{\n    int pipefd[2];\n    int pipefd2[2];\n    int rv= pipe(pipefd);\n    assert(rv > -1);\n    int cid = fork();\n    assert(cid > -1);\n    int status;\n    if( cid > 0 ){\n        //waitpid(cid,NULL,0);\n        printf(\"P %d %d\\n\",getpid(),getppid());\n        wait(NULL);\n        printf(\"Parent \\n\");\n        close(0);\n        dup(pipefd[0]);\n        close(pipefd[0]);\n        close(pipefd[1]);\n\n        char *const wc_argv[] = {\"wc\", \"-l\", NULL};\n        execvp(\"wc\", wc_argv);\n        //Parent - Redirect stdout to the write end of the pipe, and execute \"ls -l\"\n\n    }else{\n        int rv1= pipe(pipefd2);\n        assert(rv1 > -1);\n        int cid1 = fork();\n        assert(cid1 > -1);\n\n        if(cid1>0){\n            printf(\"C1 %d %d\\n\",getpid(),getppid());\n            wait(NULL);\n            printf(\"Child1\\n\");\n            //Child 1 (parent of child 2)\n            close(0);\n            dup(pipefd[0]);\n            close(1);\n            dup(pipefd2[1]);\n            close(pipefd[0]);\n            close(pipefd[1]);\n            close(pipefd2[0]);\n            close(pipefd2[1]);\n            char *const grep_argv[] = {\"grep\", \"D\", NULL};\n            execvp(\"grep\", grep_argv);\n        }else{\n            printf(\"C2 %d %d\\n\",getpid(),getppid());\n            printf(\"Child2\\n\");\n            //Child 2 (child of child 1)\n            close(1);\n            dup(pipefd2[1]);\n            close(pipefd2[0]);\n            close(pipefd2[1]);\n            close(pipefd[0]);\n            close(pipefd[1]);\n            char *const ls_argv[] = {\"ls\", \"-l\", NULL};\n            execvp(\"ls\", ls_argv);\n\n        }\n\n    }\n}\n", "I have this code that requires a parent to fork 3 children. \nHow do you know (and) where to put the \"wait()\" statement to kill\nzombie processes?\nWhat is the command to view zombie processes if you have Linux\nvirtual box?\nmain(){\n\n pid_t child;\n printf(\"-----------------------------------\\n\");\n about(\"Parent\");\n printf(\"Now ..  Forking !!\\n\");\n child = fork();\n int i=0;\n\n for (i=0; i<3; i++){\n    if (child < 0) {\n        perror (\"Unable to fork\");\n        break;\n    } \n    else if (child == 0){\n        printf (\"creating child #%d\\n\", (i+1));\n        about (\"Child\");\n        break;\n    }\n\n    else{\n        child = fork();\n    }\n  } \n}       \n\nvoid about(char * msg){\n\n pid_t me;\n pid_t oldone;\n\n me = getpid();\n oldone = getppid();\n\n printf(\"***[%s] PID = %d   PPID = %d.\\n\", msg, me, oldone);\n\n}\n\n", "I have this code that requires a parent to fork 3 children. \nHow do you know (and) where to put the \"wait()\" statement to kill\nzombie processes?\nWhat is the command to view zombie processes if you have Linux\nvirtual box?\nmain(){\n\n pid_t child;\n printf(\"-----------------------------------\\n\");\n about(\"Parent\");\n printf(\"Now ..  Forking !!\\n\");\n child = fork();\n int i=0;\n\n for (i=0; i<3; i++){\n    if (child < 0) {\n        perror (\"Unable to fork\");\n        break;\n    } \n    else if (child == 0){\n        printf (\"creating child #%d\\n\", (i+1));\n        about (\"Child\");\n        break;\n    }\n\n    else{\n        child = fork();\n    }\n  } \n}       \n\nvoid about(char * msg){\n\n pid_t me;\n pid_t oldone;\n\n me = getpid();\n oldone = getppid();\n\n printf(\"***[%s] PID = %d   PPID = %d.\\n\", msg, me, oldone);\n\n}\n\n", "I have this code that requires a parent to fork 3 children. \nHow do you know (and) where to put the \"wait()\" statement to kill\nzombie processes?\nWhat is the command to view zombie processes if you have Linux\nvirtual box?\nmain(){\n\n pid_t child;\n printf(\"-----------------------------------\\n\");\n about(\"Parent\");\n printf(\"Now ..  Forking !!\\n\");\n child = fork();\n int i=0;\n\n for (i=0; i<3; i++){\n    if (child < 0) {\n        perror (\"Unable to fork\");\n        break;\n    } \n    else if (child == 0){\n        printf (\"creating child #%d\\n\", (i+1));\n        about (\"Child\");\n        break;\n    }\n\n    else{\n        child = fork();\n    }\n  } \n}       \n\nvoid about(char * msg){\n\n pid_t me;\n pid_t oldone;\n\n me = getpid();\n oldone = getppid();\n\n printf(\"***[%s] PID = %d   PPID = %d.\\n\", msg, me, oldone);\n\n}\n\n", "I am trying to solve an issue with automating a series of scripts used in my workplace. I am a beginner so I apologise for what most likely will be an easy question (hopefully), I have read the literature but it didn't quite make sense to me.Essentially I have a bash script that runs a python script and an R script that needs to be run in order, currently running the code the R script begins before the python is finished and I have been told here than I cannot use the shell wait function as my python script launches child processes and shell wait cannot be used to wait on grandchild processes. Thats fine, so the solution offered was to make the python and R script wait on their own child processes so that when they exit, the the bash script can properly run in order. Unfortunately I cannot figure out the proper nomenclature of this in my python script.Here's what i have:cmd = \"python %s/create_keyfile.py %s %s %s %s\" %(input, input, input, \ninput, input)    \nprint cmd  \nos.system(cmd)\n\ncmd = \"python %s/uneak_name_plus_barcode_v2.py %s %s %s %s\" %(input, \ninput, input, input, input)  \nprint cmd  \nos.system(cmd)\n\ncmd = \"python %s/run_production_mode.py  %s %s %s %s %s\" %(input, input, \ninput, input, input, input)  \nprint cmd  \nos.system(cmd)\nWhere 'input' is actual inputs in my code, I probably just cant share exactly what we are doing :)So essentially I am trying to figure out the best way of having the whole script wait on these three scripts before exiting."], "chosen": ["\nNothing equivalent to wait().  The usual practice is to poll using kill(pid, 0) and looking for return value -1 and errno of ESRCH to indicate that the process is gone.\nUpdate: Since linux kernel 5.3 there is a pidfd_open syscall, which creates an fd for a given pid, which can be polled to get notification when pid has exited.\n", "\nSo far I've found three ways to do this on Linux:\n\nPolling: you check for the existence of the process every so often, either by using kill or by testing for the existence of /proc/$pid, as in most of the other answers\nUse the ptrace system call to attach to the process like a debugger so you get notified when it exits, as in a3nm's answer\nUse the netlink interface to listen for PROC_EVENT_EXIT messages - this way the kernel tells your program every time a process exits and you just wait for the right process ID. I've only seen this described in one place on the internet.\n\nShameless plug: I'm working on a program (open source of course; GPLv2) that does any of the three.\n", "\nOn BSDs and OS X, you can use kqueue with EVFILT_PROC+NOTE_EXIT to do exactly that. No polling required. Unfortunately there's no Linux equivalent.\n", "\nYou could also create a socket or a FIFO and read on them. The FIFO is especially simple: Connect the standard output of your child with the FIFO and read. The read will block until the child exits (for any reason) or until it emits some data. So you'll need a little loop to discard the unwanted text data.\nIf you have access to the source of the child, open the FIFO for writing when it starts and then simply forget about it. The OS will clean the open file descriptor when the child terminates and your waiting \"parent\" process will wake up.\nNow this might be a process which you didn't start or own. In that case, you can replace the binary executable with a script that starts the real binary but also adds monitoring as explained above.\n", "\nHere is a way to wait for any process (not necessarily a child) in linux to exit (or get killed) without polling:\nUsing inotify to wait for the /proc'pid' to be deleted would be the perfect solution, but unfortunately inotify does not work with pseudo file systems like /proc.\nHowever we can use it with the executable file of the process.\nWhile the process still exists, this file is being held open.\nSo we can use inotify with IN_CLOSE_NOWRITE to block until the file is closed.\nOf course it can be closed for other reasons (e.g. if another process with the same executable exits) so we have to filter those events by other means.\nWe can use kill(pid, 0), but that can't guarantee if it is still the same process. If we are really paranoid about this, we can do something else.\nHere is a way that should be 100% safe against pid-reuse trouble: we open the pseudo directory /proc/'pid', and keep it open until we are done. If a new process is created in the meantime with the same pid, the directory file descriptor that we hold will still refer to the original one (or become invalid, if the old process cease to exist), but will NEVER refer the new process with the reused pid. Then we can check if the original process still exists by checking, for example, if the file \"cmdline\" exists in the directory with openat(). When a process exits or is killed, those pseudo files cease to exist too, so openat() will fail.\nhere is an example code:\n// return -1 on error, or 0 if everything went well\nint wait_for_pid(int pid)\n{\n    char path[32];\n    int in_fd = inotify_init();\n    sprintf(path, \"/proc/%i/exe\", pid);\n    if (inotify_add_watch(in_fd, path, IN_CLOSE_NOWRITE) < 0) {\n        close(in_fd);\n        return -1;\n    }\n    sprintf(path, \"/proc/%i\", pid);\n    int dir_fd = open(path, 0);\n    if (dir_fd < 0) {\n        close(in_fd);\n        return -1;\n    }\n\n    int res = 0;\n    while (1) {\n        struct inotify_event event;\n        if (read(in_fd, &event, sizeof(event)) < 0) {\n            res = -1;\n            break;\n        }\n        int f = openat(dir_fd, \"fd\", 0);\n        if (f < 0) break;\n        close(f);\n    }\n\n    close(dir_fd);\n    close(in_fd);\n    return res;\n}\n\n", "\nYou could attach to the process with ptrace(2). From the shell, strace -p PID >/dev/null 2>&1 seems to work. This avoid the busy-waiting, though it will slow down the traced process, and will not work on all processes (only yours, which is a bit better than only child processes).\n", "\nNone I am aware of. Apart from the solution from chaos, you can use semaphores if you can change the program you want to wait for.\nThe library functions are sem_open(3), sem_init(3), sem_wait(3), ... \nsem_wait(3) performs a wait, so you don\u00b4t have to do busy waiting as in chaos\u00b4 solution. Of course, using semaphores makes your programs more complex and it may not be worth the trouble.\n", "\nMaybe it could be possible to wait for /proc/[pid] or /proc/[pid]/[something] to disappear?\nThere are poll() and other file event waiting functions, maybe that could help?\n", "\nSince linux kernel 5.3 there is a pidfd_open syscall, which creates an fd for a given pid, which can be polled to get notification when pid has exited.\n", "\nPR_SET_PDEATHSIG can be used to wait for parent process termination\n", "\nMy solution (using inotifywait)\nThis is based on linux's /proc filesystem.\nMy need was to start a 2nd (overall) backup, once containers backups is done. Containers backups is started by cron.\nWatching for cron tasks\nread -r wpid < <(ps -C backup.sh ho pid)\nls -l /proc/$wpid/fd\n\ntotal 0\nlr-x------ 1 user user 64  1 ao\u00fb 09:13 0 -> pipe:[455151052]\nlrwx------ 1 user user 64  1 ao\u00fb 09:13 1 -> /tmp/#41418 (deleted)\nlrwx------ 1 user user 64  1 ao\u00fb 09:13 2 -> /tmp/#41418 (deleted)\n\nWhere deleted entries was created by cron. But even if deleted, you could watch for file descriptor directly:\ninotifywait  /proc/$wpid/fd/1\n\n/proc/511945/fd/1 CLOSE_WRITE,CLOSE \n\nor\ninotifywait  /proc/$wpid/fd/0\n\n/proc/511945/fd/0 CLOSE_NOWRITE,CLOSE \n\nNote: My overall backup is run as root user! If no this could require sudo because command is run under cron session!\nSame session\nJust test: In a 1st window, hit:\nsleep 0.42m <<<'' >/dev/null 2>&1\n\nThen in another window:\nread -r wpid < <(ps -C sleep wwho pid,cmd| sed 's/ sleep 0\\.42m$//p;d')\nls -l /proc/$wpid/fd\n\ntotal 0\nlr-x------ 1 user user 64  1 ao\u00fb 09:38 0 -> pipe:[455288137]\nl-wx------ 1 user user 64  1 ao\u00fb 09:38 1 -> /dev/null\nl-wx------ 1 user user 64  1 ao\u00fb 09:38 2 -> /dev/null\n\nDon't try to watch for 1 or 2! Because they point to /dev/null, any process acessing to them will trig inotifywait.\ninotifywait  /proc/$wpid/fd/0\n/proc/531119/fd/0 CLOSE_NOWRITE,CLOSE\n\nElapsed time in seconds\n1st window:\nsleep 0.42m <<<'' >/dev/null 2>&1\n\n2nd window:\nread -r wpid < <(ps -C sleep wwho pid,cmd| sed 's/ sleep 0\\.42m$//p;d')\nstartedAt=$(ps ho lstart $wpid | date -f - +%s)\ninotifywait  /proc/$wpid/fd/0;echo $((EPOCHSECONDS-startedAt))\n\n/proc/533967/fd/0 CLOSE_NOWRITE,CLOSE \n25\n\nConclusion.\nUsing inotifywait seem to be a good solution, mostly watching for command's standard input (fd/0). But this must be tested case by case.\n", "\nSimply poll values number 22 and 2 of the /proc/[PID]/stat.\nThe value 2 contains name of the executable and 22 contains start time.\nIf they change, some other process has taken the same (freed) PID. Thus the method is very reliable.\n", "\nYou can use eBPF to achieve this.\nThe bcc toolkit implements many excellent monitoring capabilities based on eBPF. Among them, exitsnoop traces process termination, showing the command name and reason for termination,\neither an exit or a fatal signal.\n   It catches processes of all users, processes in containers,  as  well  as  processes  that\n   become zombie.\n\n   This  works by tracing the kernel sched_process_exit() function using dynamic tracing, and\n   will need updating to match any changes to this function.\n\n   Since this uses BPF, only the root user can use this tool.\n\nYou can refer to this tool for related implementation.\nYou can get more information about this tool from the link below\uff1a\n\nGithub repo: tools/exitsnoop: Trace process termination (exit and fatal signals). Examples.\nLinux Extended BPF (eBPF) Tracing Tools\nubuntu manpages: exitsnoop-bpfcc\n\nYou can first install this tool and use it to see if it meets your needs, and then refer to its implementation for coding, or use some of the libraries it provides to implement your own functions.\nexitsnoop examples:\n   Trace all process termination\n          # exitsnoop\n\n   Trace all process termination, and include timestamps:\n          # exitsnoop -t\n\n   Exclude successful exits, only include non-zero exit codes and fatal signals:\n          # exitsnoop -x\n\n   Trace PID 181 only:\n          # exitsnoop -p 181\n\n   Label each output line with 'EXIT':\n          # exitsnoop --label EXIT\n\n\nAnother option\nWait for a (non-child) process' exit using Linux's PROC_EVENTS\nReference project:\nhttps://github.com/stormc/waitforpid\nmentioned in the project\uff1a\n\nWait for a (non-child) process' exit using Linux's PROC_EVENTS. Thanks\nto the CAP_NET_ADMIN POSIX capability permitted to the waitforpid\nbinary, it does not need to be set suid root. You need a Linux kernel\nhaving CONFIG_PROC_EVENTS enabled.\n\n", "\nStarting with Bash 5.1, there is now an additional way of waiting for and handling multiple background jobs thanks to the introduction of wait -p.\nHere's an example:\n#!/usr/bin/env bash\nfor ((i=0; i < 10; i++)); do\n    secs=$((RANDOM % 10)); code=$((RANDOM % 256))\n    (sleep ${secs}; exit ${code}) &\n    echo \"Started background job (pid: $!, sleep: ${secs}, code: ${code})\"\ndone\n\nwhile true; do\n    wait -n -p pid; code=$?\n    [[ -z \"${pid}\" ]] && break\n    echo \"Background job ${pid} finished with code ${code}\"\ndone\n\nThe novelty here is that you now know exactly which one of the background jobs finished.\n", "\nLet's go through your options.\nWait for all background jobs, unconditionally\nfor i in 1 2 3 4 5; do\n    cmd &\ndone\nwait\n\nThis has the benefit of being simple, but you can't keep your machine busy. If you want to start new jobs as old ones complete, you can't. You machine gets less and less utilized until all the background jobs complete, at which point you can start a new batch of jobs.\nRelated is the ability to wait for a subset of jobs by passing multiple arguments to wait:\nunrelated_job &\nfor i in 1 2 3 4 5; do\n  cmd & pids+=($!)\ndone\nwait \"${pids[@]}\"   # Does not wait for unrelated_job, though\n\nWait for individual jobs in arbitrary order\nfor i in 1 2 3 4 5; do\n   cmd & pids+=($!)\ndone\n\nfor pid in \"${pids[@]}\"; do\n   wait \"$pid\"\n   # do something when a job completes\ndone\n\nThis has the benefit of letting you do work after a job completes, but\nstill has the problem that jobs other than $pid might complete first, leaving your machine underutilized until $pid actually completes. You  do, however, still get the exit status for each individual job, even if it completes before you actually wait for it.\nWait for the next job to complete (bash 4.3 or later)\nfor i in 1 2 3 4 5; do\n   cmd & pids+=($!)\ndone\n\nfor pid in \"${pids[@]}\"; do\n   wait -n\n   # do something when a job completes\ndone\n\nHere, you can wait until a job completes, which means you can keep your machine as busy as possible. The only problem is, you don't necessarily know which job completed, without using jobs to get the list of active processes and comparing it to pids.\nOther options?\nThe shell by itself is not an ideal platform for doing job distribution, which is why there are a multitude of programs designed for managing batch jobs: xargs, parallel, slurm, qsub, etc.\n", "\nThis is old, but the scenario presented where a deferred wait waits for some random unrelated process due to pid collision hasn't been directly addressed.\nIt's not possible at the kernel level. The way it works there is that prior to the parent process calling wait(2)\u00b9, the child process still exists. Because the child still exists, linux will run out of pids rather than reuse it. This manifests at times with so called zombie or \"defunct\" processes - these are children which have exited but have yet to be \"reaped\" by their parent.\nNow, at the shell level you don't have to call wait(1)\u00b9 for child processes to be reaped - bash does this automatically. I haven't confirmed, but when you run wait $pid for a child pid which exited long ago, I would wager bash realises it has already reaped that child and returns the information immediately rather than waiting for anything.\n\u00b9 the wait(N) notation is a convention used to disambiguate between API layers - N refers to the section of the manual a command/function is located in. In this case we have:\n\nwait(2): the syscall - see man 2 wait\nwait(1): the shell command - see man 1 wait or help wait\n\nIf you want to know what lives in each manual section, try man N intro.\n", "\nfork() system call duplicates the mother process. The resulting child process and the parent process will have their own address spaces. So child process can not modify childReturns variable of the parent.\nAdditionally, wait(NULL) waits for child processes to end.\n", "\nTry chaining these lines:\n        if (processId == 0)\n            execvp(prog, args);\n        else\n\nTo these:\n        if (processId == 0) {\n            execvp(prog, args);\n            perror(prog);\n            abort();\n        } else\n\nAlso, note that WEXITSTATUS, is only valid if WIFEXITTED() is true.   In this case, when your child process abort()'s, it will not be true.\nSo\n            wait(&childReturns); // Wait for the child\n            printf(\"Child  code is %d\\n\", \n\nneeds a bit more work, like:\n     if (WIFEXITTED(childReturns)) {\n         printf(\"Child code is %d\\n\", WEXITSTATUS(childReturns));\n     } else if (WIFSIGNALED(childReturns)) {\n         printf(\"Child killed by signal %d\\n\", WTERMSIG(childReturns);\n     } else {\n         printf(\"Child suffered %#x\\n\", childReturns);\n     }\n\nBut, your real problem is why is execvp() failing?   Look carefully at how big your args array is. Does it match the documentation?\n", "\nThe system call wait(2) is typically used to find if the child process's state has changed (i.e. whether it's still running, exited, etc).\nAnother purpose is to avoid \"zombie\" processes. If parent process doesn't wait on the child process and the child process exits before the parent process then it becomes a \"zombie\" process. So, a wait() call is used to \"reap\" the process and release the system resources associated with the process. \nImagine if the parent process is a long running one and creates several child processes at regular intervals then all the zombie processes will have entries in the process table which is an unncessary use of system resources.\n", "\nafter the fork, you'll have two independent process. \nwhit the wait() call, you tell the parent process to wait the child process to terminate. \nIn this example, nothing changes since the two process are not interacting with each other, so the parent can just exit after creating the child and printing the string, but in the scenario where the parent has to wait the child to do some operations and then maybe return some values to the parent, it becomes useful! \n", "\nWhen you do fork(), you have a new child process starts running at the same point with the parent process. So you should make sure that only parent process calls the second fork().\nKey: fork() will return 0 on child process.\nHere is the way to do that:\nCode\n#include <stdio.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <errno.h>\n\nint main(void)\n{\n    int status;\n    pid_t ret, pid1, pid2;\n\n    pid1 = fork();\n    if (pid1 == 0) {\n        // First child performing selection sort\n        printf(\"Do selection sort here...\\n\");\n        sleep(5);\n\n        printf(\"Selection sort finished\\n\");\n        exit(0);\n    }\n\n\n    pid2 = fork();\n    if (pid2 == 0) {\n        // Second child performing bubble sort\n        printf(\"Do bubble sort here...\\n\");\n        sleep(2);\n\n        printf(\"Bubble sort finished\\n\");\n        // The parent must get exit code 100 from this\n        exit(100);\n    }\n\n\n    // Parent process waits until at least one child process terminates\n    do {\n\n        status = 0;\n        ret = wait(&status);\n        if (WIFEXITED(status)) {\n            printf(\"Child process %d has exited with exit code: %d\\n\",\n                   ret, WEXITSTATUS(status));\n            break;\n        }\n\n        if (ret < 0) {\n            printf(\"wait() error: %s\\n\", strerror(errno));\n            break;\n        }\n\n        /* If we reach here, child may be traced or continued. */\n    } while (1);\n\n    printf(\"Parent has finished its waiting state...\\n\");\n    return 0;\n}\n\nCompile and Run\nammarfaizi2@integral:/tmp$ gcc -Wall -Wextra test.c -o test\nammarfaizi2@integral:/tmp$ ./test\nDo bubble sort here...\nDo selection sort here...\nBubble sort finished\nChild process 143748 has exited with exit code: 100\nParent has finished its waiting state...\nammarfaizi2@integral:/tmp$ Selection sort finished\n\nIn this case, when a child process terminates (at least one), the parent will stop to wait. So you see \"Selection sort finished\" after the parent process terminates, because we simulate selection sort as 5 seconds work, and bubble sort as 3 seconds work.\n", "\nOk, so there is some bit operations are going on:\nImagine you have 32 bit integer:\n0101 0101 1011 0101 1101 1010 1111 1101\n1: (value>>8)&255 this will perform two operations: shift to the right 8 times, then \"and\" operation. After shift:\n0000 0000 0101 0101 1011 0101 1101 1010\nAfter \"and\" :\n0000 0000 0000 0000 0000 0000 1101 1010.\nThis is the value of the first eight bits on the final result.\n\nvalue&255: this will perform \"and\" again, and you have:\n\n0000 0000 0000 0000 0000 0000 1111 1101\nThis is the last 8 bits of the result.\nTL:DR\nvalue&255 Will zero out the first 24 bits of the 32 bit value.\n", "\nsome_int & 255 (as well as some_int & 0xFF for which it is even more obvious) means just \"take least byte and zero everything else\". So the code just prints out byte 1 and byte 0 of the process status code.\nI don't get why does your professor even bother with the thing though.\nIf you need the return code of a child process you should use the standard WEXITSTATUS() macro and other standard macros for other statuses instead.\nIf you are using Linux then man 3 wait should give you complete description for of all of the available macros if you ever need them.\n", "\nOMG!! Thanks ALL\nThis is my first time posting a question in stack overflow.\nI cant believe you guys are so helpful, thank you so much\nand i have solved my problem right now.\nI can believe I just made a really simple mistake, which is in Child1\n        close(0);\n        dup(pipefd2[0]);\n        close(1);\n        dup(pipefd[1]);\n\nOriginal, my program will run parent first, then i want to modify it, then i just thought exchanging the child 2 and parent, everything will be fine, but i forgot to modify the content of child1.\nAnyways, you guys are so helpful, and hope you guys stay safe and keep going on our it adventure :)\n", "\nThere are multiple issues with your code.  I pointed out some minor matters in comments, but the ones mainly likely to be responsible for the misbehavior you describe are:\n\nChild 1 and the parent both redirect pipefd[0] to their standard inputs.  Probably you want child 1 to redirect pipefd2[0] to its standard input instead, but you definitely don't want the two to have the same standard input.\n\nChild 1 redirects its standard output to pipefd2[1], the other end of which pipe will be its standard input once you correct the previous issue.  You appear to instead want to redirect to pipefd[1], which presently is not served at all.\n\nChild 1 waits for child 2 before it proceeds.  This is non-idiomatic and risky, for you will get a deadlock if child 2 fills the buffer of the second pipe, and therefore blocks before terminating.  Pipes are data conduits. Although they do have internal buffers, this should be regarded as an implementation detail.  It is incorrect to rely on pipes for buffering.  The correct model is that data is consumed from the pipe's read end concurrently with data being written to the pipe's write end.\n\nThe parent waits for child 1 before it proceeds.  As with child 1's wait, this is risky and non-idiomatic.\n\n\nAdditionally, as @IanAbott remarked in comments, with the way you are arranging the pipes, child 1 waiting for child 2 will reliably produce deadlock.  The latter execs a program that will read its standard input to the end, but it will not see EOF on its input until the other ends of the pipe is closed, and that is never closed because child 1 waits on child 2 to finish before it proceeds.  I see no necessity for the waits -- neither child 1's nor the parent's -- they could and should just be removed.\n", "\n\nHow do you know (and) where to put the \"wait()\" statement to kill\n  zombie processes?\n\nYou can use wait() anywhere in the parent process, and when the child process terminates it'll be removed from the system. Where to put it is up to you, in your specific case you probably want to put it immediately after the child = fork(); line so that the parent process won't resume its execution until its child has exited.\n\nWhat is the command to view zombie processes if you have Linux virtual box?\n\nYou can use the ps aux command to view all processes in the system (including zombie processes), and the STAT column will be equal to Z if the process is a zombie. An example output would be:\nUSER      PID    %CPU %MEM VSZ  RSS TTY      STAT START   TIME COMMAND\ndaniel    1000   0.0  0.0  0    0   ??       Z    17:15   0:00 command\n\n", "\n\nHow do you know (and) where to put the \"wait()\" statement to kill\n  zombie processes?\n\nIf your parent spawns only a small, fixed number of children; does not care when or whether they stop, resume, or finish; and itself exits quickly, then you do not need to use wait() or waitpid() to clean up the child processes.  The init process (pid 1) takes responsibility for orphaned child processes, and will clean them up when they finish.\nUnder any other circumstances, however, you must wait() for child processes.  Doing so frees up resources, ensures that the child has finished, and allows you to obtain the child's exit status.  Via waitpid() you can also be notified when a child is stopped or resumed by a signal, if you so wish.\nAs for where to perform the wait,\n\nYou must ensure that only the parent wait()s.\nYou should wait at or before the earliest point where you need the child to have finished (but not before forking), OR\nif you don't care when or whether the child finishes, but you need to clean up resources, then you can periodically call waitpid(-1, NULL, WNOHANG) to collect a zombie child if there is one, without blocking if there isn't any.\n\nIn particular, you must not wait() (unconditionally) immediately after fork()ing because parent and child run the same code.  You must use the return value of fork() to determine whether you are in the child (return value == 0), or in the parent (any other return value).  Furthermore, the parent must wait() only if forking was successful, in which case fork() returns the child's pid, which is always greater than zero.  A return value less than zero indicates failure to fork.\nYour program doesn't really need to wait() because it spawns exactly four (not three) children, then exits.  However, if you wanted the parent to have at most one live child at any time, then you could write it like this:\nint main() {\n    pid_t child;\n    int i;\n\n    printf(\"-----------------------------------\\n\");\n    about(\"Parent\");\n\n    for (i = 0; i < 3; i++) {\n        printf(\"Now ..  Forking !!\\n\");\n        child = fork();\n\n        if (child < 0) {\n            perror (\"Unable to fork\");\n            break;\n        } else if (child == 0) {\n            printf (\"In child #%d\\n\", (i+1));\n            about (\"Child\");\n            break;\n        } else {\n            /* in parent */\n            if (waitpid(child, NULL, 0) < 0) {\n                perror(\"Failed to collect child process\");\n                break;\n            }\n        }\n    }\n\n    return 0;\n}\n\nIf the parent exits before one or more of its children, which can happen if it does not wait, then the child will thereafter see its parent process being pid 1.\nOthers have already answered how to get a zombie process list via th ps command.  You may also be able to see zombies via top.  With your original code you are unlikely to catch a glimpse of zombies, however, because the parent process exits very quickly, and init will then clean up the zombies it leaves behind.\n", "\n\nHow do you know (and) where to put the \"wait()\" statement to kill\n  zombie processes?\n\nYou can register a signal handler for SIGCHLD that sets a global volatile sig_atomic_t flag = 0 variable to 1. Then, at some convenient place in your program, test whether flag is set to 1, and, if so, set it back to 0 and afterwards (for otherwise you might miss a signal) call waitpid(-1, NULL, WNOHANG) in a loop until it tells you that no more processes are to be waited for. Note that the signal will interrupt system calls with EINTR, which is a good condition to check for the value of flag. If you use an indefinitely blocking system call like select(), you might want to specify a timeout after which you check for flag, since otherwise you might miss a signal that was raised after your last waitpid() call but before entering the indefinitely blocking system call. An alternative to this kludge is to use pselect().\n", "\nUse subprocess.check_call() not os.system()\nsubprocess.check_call() will block your main Python script's execution until the function has returned a value.\nDocumentation for check_call() here\nThe subprocess module should always be used instead of os.system() for subprocess management and execution.\n"], "rejected": ["\nAppricate @Hongli's answer for macOS with kqueue. I implement it with swift\n/// Wait any pids, including non-child pid. Block until all pids exit.\n/// - Parameters:\n///   - timeout: wait until interval, nil means no timeout\n/// - Throws: WaitOtherPidError\n/// - Returns: isTimeout\nfunc waitOtherPids(_ pids: [Int32], timeout: TimeInterval? = nil) throws -> Bool {\n    \n    // create a kqueue\n    let kq = kqueue()\n    if kq == -1 {\n        throw WaitOtherPidError.createKqueueFailed(String(cString: strerror(errno)!))\n    }\n    \n    // input\n    // multiple changes is OR relation, kevent will return if any is match\n    var changes: [Darwin.kevent] = pids.map({ pid in\n        Darwin.kevent.init(ident: UInt(pid), filter: Int16(EVFILT_PROC), flags: UInt16(EV_ADD | EV_ENABLE), fflags: NOTE_EXIT, data: 0, udata: nil)\n    })\n    \n    let timeoutDeadline = timeout.map({ Date(timeIntervalSinceNow: $0)})\n    let remainTimeout: () ->timespec? = {\n        if let deadline = timeoutDeadline {\n            let d = max(deadline.timeIntervalSinceNow, 0)\n            let fractionalPart = d - TimeInterval(Int(d))\n            return timespec(tv_sec: Int(d), tv_nsec: Int(fractionalPart * 1000 * 1000 * 1000))\n        } else {\n            return nil\n        }\n    }\n    \n    // output\n    var events = changes.map{ _ in Darwin.kevent.init() }\n    \n    while !changes.isEmpty {\n        \n        // watch changes\n        // sync method\n        let numOfEvent: Int32\n        if var timeout = remainTimeout() {\n            numOfEvent = kevent(kq, changes, Int32(changes.count), &events, Int32(events.count), &timeout);\n        } else {\n            numOfEvent = kevent(kq, changes, Int32(changes.count), &events, Int32(events.count), nil);\n        }\n        \n        if numOfEvent < 0 {\n            throw WaitOtherPidError.keventFailed(String(cString: strerror(errno)!))\n        }\n        if numOfEvent == 0 {\n            // timeout. Return directly.\n            return true\n        }\n        \n        // handle the result\n        let realEvents = events[0..<Int(numOfEvent)]\n        let handledPids = Set(realEvents.map({ $0.ident }))\n        changes = changes.filter({ c in\n            !handledPids.contains(c.ident)\n        })\n\n        for event in realEvents {\n            if Int32(event.flags) & EV_ERROR > 0 { // @see 'man kevent'\n                let errorCode = event.data\n                if errorCode == ESRCH {\n                    // \"The specified process to attach to does not exist\"\n                    // ingored\n                } else {\n                    print(\"[Error] kevent result failed with code \\(errorCode), pid \\(event.ident)\")\n                }\n            } else {\n                // succeeded event, pid exit\n            }\n        }\n    }\n    return false\n}\nenum WaitOtherPidError: Error {\n    case createKqueueFailed(String)\n    case keventFailed(String)\n}\n\n\n", "\nAppricate @Hongli's answer for macOS with kqueue. I implement it with swift\n/// Wait any pids, including non-child pid. Block until all pids exit.\n/// - Parameters:\n///   - timeout: wait until interval, nil means no timeout\n/// - Throws: WaitOtherPidError\n/// - Returns: isTimeout\nfunc waitOtherPids(_ pids: [Int32], timeout: TimeInterval? = nil) throws -> Bool {\n    \n    // create a kqueue\n    let kq = kqueue()\n    if kq == -1 {\n        throw WaitOtherPidError.createKqueueFailed(String(cString: strerror(errno)!))\n    }\n    \n    // input\n    // multiple changes is OR relation, kevent will return if any is match\n    var changes: [Darwin.kevent] = pids.map({ pid in\n        Darwin.kevent.init(ident: UInt(pid), filter: Int16(EVFILT_PROC), flags: UInt16(EV_ADD | EV_ENABLE), fflags: NOTE_EXIT, data: 0, udata: nil)\n    })\n    \n    let timeoutDeadline = timeout.map({ Date(timeIntervalSinceNow: $0)})\n    let remainTimeout: () ->timespec? = {\n        if let deadline = timeoutDeadline {\n            let d = max(deadline.timeIntervalSinceNow, 0)\n            let fractionalPart = d - TimeInterval(Int(d))\n            return timespec(tv_sec: Int(d), tv_nsec: Int(fractionalPart * 1000 * 1000 * 1000))\n        } else {\n            return nil\n        }\n    }\n    \n    // output\n    var events = changes.map{ _ in Darwin.kevent.init() }\n    \n    while !changes.isEmpty {\n        \n        // watch changes\n        // sync method\n        let numOfEvent: Int32\n        if var timeout = remainTimeout() {\n            numOfEvent = kevent(kq, changes, Int32(changes.count), &events, Int32(events.count), &timeout);\n        } else {\n            numOfEvent = kevent(kq, changes, Int32(changes.count), &events, Int32(events.count), nil);\n        }\n        \n        if numOfEvent < 0 {\n            throw WaitOtherPidError.keventFailed(String(cString: strerror(errno)!))\n        }\n        if numOfEvent == 0 {\n            // timeout. Return directly.\n            return true\n        }\n        \n        // handle the result\n        let realEvents = events[0..<Int(numOfEvent)]\n        let handledPids = Set(realEvents.map({ $0.ident }))\n        changes = changes.filter({ c in\n            !handledPids.contains(c.ident)\n        })\n\n        for event in realEvents {\n            if Int32(event.flags) & EV_ERROR > 0 { // @see 'man kevent'\n                let errorCode = event.data\n                if errorCode == ESRCH {\n                    // \"The specified process to attach to does not exist\"\n                    // ingored\n                } else {\n                    print(\"[Error] kevent result failed with code \\(errorCode), pid \\(event.ident)\")\n                }\n            } else {\n                // succeeded event, pid exit\n            }\n        }\n    }\n    return false\n}\nenum WaitOtherPidError: Error {\n    case createKqueueFailed(String)\n    case keventFailed(String)\n}\n\n\n", "\nAppricate @Hongli's answer for macOS with kqueue. I implement it with swift\n/// Wait any pids, including non-child pid. Block until all pids exit.\n/// - Parameters:\n///   - timeout: wait until interval, nil means no timeout\n/// - Throws: WaitOtherPidError\n/// - Returns: isTimeout\nfunc waitOtherPids(_ pids: [Int32], timeout: TimeInterval? = nil) throws -> Bool {\n    \n    // create a kqueue\n    let kq = kqueue()\n    if kq == -1 {\n        throw WaitOtherPidError.createKqueueFailed(String(cString: strerror(errno)!))\n    }\n    \n    // input\n    // multiple changes is OR relation, kevent will return if any is match\n    var changes: [Darwin.kevent] = pids.map({ pid in\n        Darwin.kevent.init(ident: UInt(pid), filter: Int16(EVFILT_PROC), flags: UInt16(EV_ADD | EV_ENABLE), fflags: NOTE_EXIT, data: 0, udata: nil)\n    })\n    \n    let timeoutDeadline = timeout.map({ Date(timeIntervalSinceNow: $0)})\n    let remainTimeout: () ->timespec? = {\n        if let deadline = timeoutDeadline {\n            let d = max(deadline.timeIntervalSinceNow, 0)\n            let fractionalPart = d - TimeInterval(Int(d))\n            return timespec(tv_sec: Int(d), tv_nsec: Int(fractionalPart * 1000 * 1000 * 1000))\n        } else {\n            return nil\n        }\n    }\n    \n    // output\n    var events = changes.map{ _ in Darwin.kevent.init() }\n    \n    while !changes.isEmpty {\n        \n        // watch changes\n        // sync method\n        let numOfEvent: Int32\n        if var timeout = remainTimeout() {\n            numOfEvent = kevent(kq, changes, Int32(changes.count), &events, Int32(events.count), &timeout);\n        } else {\n            numOfEvent = kevent(kq, changes, Int32(changes.count), &events, Int32(events.count), nil);\n        }\n        \n        if numOfEvent < 0 {\n            throw WaitOtherPidError.keventFailed(String(cString: strerror(errno)!))\n        }\n        if numOfEvent == 0 {\n            // timeout. Return directly.\n            return true\n        }\n        \n        // handle the result\n        let realEvents = events[0..<Int(numOfEvent)]\n        let handledPids = Set(realEvents.map({ $0.ident }))\n        changes = changes.filter({ c in\n            !handledPids.contains(c.ident)\n        })\n\n        for event in realEvents {\n            if Int32(event.flags) & EV_ERROR > 0 { // @see 'man kevent'\n                let errorCode = event.data\n                if errorCode == ESRCH {\n                    // \"The specified process to attach to does not exist\"\n                    // ingored\n                } else {\n                    print(\"[Error] kevent result failed with code \\(errorCode), pid \\(event.ident)\")\n                }\n            } else {\n                // succeeded event, pid exit\n            }\n        }\n    }\n    return false\n}\nenum WaitOtherPidError: Error {\n    case createKqueueFailed(String)\n    case keventFailed(String)\n}\n\n\n", "\nAppricate @Hongli's answer for macOS with kqueue. I implement it with swift\n/// Wait any pids, including non-child pid. Block until all pids exit.\n/// - Parameters:\n///   - timeout: wait until interval, nil means no timeout\n/// - Throws: WaitOtherPidError\n/// - Returns: isTimeout\nfunc waitOtherPids(_ pids: [Int32], timeout: TimeInterval? = nil) throws -> Bool {\n    \n    // create a kqueue\n    let kq = kqueue()\n    if kq == -1 {\n        throw WaitOtherPidError.createKqueueFailed(String(cString: strerror(errno)!))\n    }\n    \n    // input\n    // multiple changes is OR relation, kevent will return if any is match\n    var changes: [Darwin.kevent] = pids.map({ pid in\n        Darwin.kevent.init(ident: UInt(pid), filter: Int16(EVFILT_PROC), flags: UInt16(EV_ADD | EV_ENABLE), fflags: NOTE_EXIT, data: 0, udata: nil)\n    })\n    \n    let timeoutDeadline = timeout.map({ Date(timeIntervalSinceNow: $0)})\n    let remainTimeout: () ->timespec? = {\n        if let deadline = timeoutDeadline {\n            let d = max(deadline.timeIntervalSinceNow, 0)\n            let fractionalPart = d - TimeInterval(Int(d))\n            return timespec(tv_sec: Int(d), tv_nsec: Int(fractionalPart * 1000 * 1000 * 1000))\n        } else {\n            return nil\n        }\n    }\n    \n    // output\n    var events = changes.map{ _ in Darwin.kevent.init() }\n    \n    while !changes.isEmpty {\n        \n        // watch changes\n        // sync method\n        let numOfEvent: Int32\n        if var timeout = remainTimeout() {\n            numOfEvent = kevent(kq, changes, Int32(changes.count), &events, Int32(events.count), &timeout);\n        } else {\n            numOfEvent = kevent(kq, changes, Int32(changes.count), &events, Int32(events.count), nil);\n        }\n        \n        if numOfEvent < 0 {\n            throw WaitOtherPidError.keventFailed(String(cString: strerror(errno)!))\n        }\n        if numOfEvent == 0 {\n            // timeout. Return directly.\n            return true\n        }\n        \n        // handle the result\n        let realEvents = events[0..<Int(numOfEvent)]\n        let handledPids = Set(realEvents.map({ $0.ident }))\n        changes = changes.filter({ c in\n            !handledPids.contains(c.ident)\n        })\n\n        for event in realEvents {\n            if Int32(event.flags) & EV_ERROR > 0 { // @see 'man kevent'\n                let errorCode = event.data\n                if errorCode == ESRCH {\n                    // \"The specified process to attach to does not exist\"\n                    // ingored\n                } else {\n                    print(\"[Error] kevent result failed with code \\(errorCode), pid \\(event.ident)\")\n                }\n            } else {\n                // succeeded event, pid exit\n            }\n        }\n    }\n    return false\n}\nenum WaitOtherPidError: Error {\n    case createKqueueFailed(String)\n    case keventFailed(String)\n}\n\n\n", "\nAppricate @Hongli's answer for macOS with kqueue. I implement it with swift\n/// Wait any pids, including non-child pid. Block until all pids exit.\n/// - Parameters:\n///   - timeout: wait until interval, nil means no timeout\n/// - Throws: WaitOtherPidError\n/// - Returns: isTimeout\nfunc waitOtherPids(_ pids: [Int32], timeout: TimeInterval? = nil) throws -> Bool {\n    \n    // create a kqueue\n    let kq = kqueue()\n    if kq == -1 {\n        throw WaitOtherPidError.createKqueueFailed(String(cString: strerror(errno)!))\n    }\n    \n    // input\n    // multiple changes is OR relation, kevent will return if any is match\n    var changes: [Darwin.kevent] = pids.map({ pid in\n        Darwin.kevent.init(ident: UInt(pid), filter: Int16(EVFILT_PROC), flags: UInt16(EV_ADD | EV_ENABLE), fflags: NOTE_EXIT, data: 0, udata: nil)\n    })\n    \n    let timeoutDeadline = timeout.map({ Date(timeIntervalSinceNow: $0)})\n    let remainTimeout: () ->timespec? = {\n        if let deadline = timeoutDeadline {\n            let d = max(deadline.timeIntervalSinceNow, 0)\n            let fractionalPart = d - TimeInterval(Int(d))\n            return timespec(tv_sec: Int(d), tv_nsec: Int(fractionalPart * 1000 * 1000 * 1000))\n        } else {\n            return nil\n        }\n    }\n    \n    // output\n    var events = changes.map{ _ in Darwin.kevent.init() }\n    \n    while !changes.isEmpty {\n        \n        // watch changes\n        // sync method\n        let numOfEvent: Int32\n        if var timeout = remainTimeout() {\n            numOfEvent = kevent(kq, changes, Int32(changes.count), &events, Int32(events.count), &timeout);\n        } else {\n            numOfEvent = kevent(kq, changes, Int32(changes.count), &events, Int32(events.count), nil);\n        }\n        \n        if numOfEvent < 0 {\n            throw WaitOtherPidError.keventFailed(String(cString: strerror(errno)!))\n        }\n        if numOfEvent == 0 {\n            // timeout. Return directly.\n            return true\n        }\n        \n        // handle the result\n        let realEvents = events[0..<Int(numOfEvent)]\n        let handledPids = Set(realEvents.map({ $0.ident }))\n        changes = changes.filter({ c in\n            !handledPids.contains(c.ident)\n        })\n\n        for event in realEvents {\n            if Int32(event.flags) & EV_ERROR > 0 { // @see 'man kevent'\n                let errorCode = event.data\n                if errorCode == ESRCH {\n                    // \"The specified process to attach to does not exist\"\n                    // ingored\n                } else {\n                    print(\"[Error] kevent result failed with code \\(errorCode), pid \\(event.ident)\")\n                }\n            } else {\n                // succeeded event, pid exit\n            }\n        }\n    }\n    return false\n}\nenum WaitOtherPidError: Error {\n    case createKqueueFailed(String)\n    case keventFailed(String)\n}\n\n\n", "\nAppricate @Hongli's answer for macOS with kqueue. I implement it with swift\n/// Wait any pids, including non-child pid. Block until all pids exit.\n/// - Parameters:\n///   - timeout: wait until interval, nil means no timeout\n/// - Throws: WaitOtherPidError\n/// - Returns: isTimeout\nfunc waitOtherPids(_ pids: [Int32], timeout: TimeInterval? = nil) throws -> Bool {\n    \n    // create a kqueue\n    let kq = kqueue()\n    if kq == -1 {\n        throw WaitOtherPidError.createKqueueFailed(String(cString: strerror(errno)!))\n    }\n    \n    // input\n    // multiple changes is OR relation, kevent will return if any is match\n    var changes: [Darwin.kevent] = pids.map({ pid in\n        Darwin.kevent.init(ident: UInt(pid), filter: Int16(EVFILT_PROC), flags: UInt16(EV_ADD | EV_ENABLE), fflags: NOTE_EXIT, data: 0, udata: nil)\n    })\n    \n    let timeoutDeadline = timeout.map({ Date(timeIntervalSinceNow: $0)})\n    let remainTimeout: () ->timespec? = {\n        if let deadline = timeoutDeadline {\n            let d = max(deadline.timeIntervalSinceNow, 0)\n            let fractionalPart = d - TimeInterval(Int(d))\n            return timespec(tv_sec: Int(d), tv_nsec: Int(fractionalPart * 1000 * 1000 * 1000))\n        } else {\n            return nil\n        }\n    }\n    \n    // output\n    var events = changes.map{ _ in Darwin.kevent.init() }\n    \n    while !changes.isEmpty {\n        \n        // watch changes\n        // sync method\n        let numOfEvent: Int32\n        if var timeout = remainTimeout() {\n            numOfEvent = kevent(kq, changes, Int32(changes.count), &events, Int32(events.count), &timeout);\n        } else {\n            numOfEvent = kevent(kq, changes, Int32(changes.count), &events, Int32(events.count), nil);\n        }\n        \n        if numOfEvent < 0 {\n            throw WaitOtherPidError.keventFailed(String(cString: strerror(errno)!))\n        }\n        if numOfEvent == 0 {\n            // timeout. Return directly.\n            return true\n        }\n        \n        // handle the result\n        let realEvents = events[0..<Int(numOfEvent)]\n        let handledPids = Set(realEvents.map({ $0.ident }))\n        changes = changes.filter({ c in\n            !handledPids.contains(c.ident)\n        })\n\n        for event in realEvents {\n            if Int32(event.flags) & EV_ERROR > 0 { // @see 'man kevent'\n                let errorCode = event.data\n                if errorCode == ESRCH {\n                    // \"The specified process to attach to does not exist\"\n                    // ingored\n                } else {\n                    print(\"[Error] kevent result failed with code \\(errorCode), pid \\(event.ident)\")\n                }\n            } else {\n                // succeeded event, pid exit\n            }\n        }\n    }\n    return false\n}\nenum WaitOtherPidError: Error {\n    case createKqueueFailed(String)\n    case keventFailed(String)\n}\n\n\n", "\nAppricate @Hongli's answer for macOS with kqueue. I implement it with swift\n/// Wait any pids, including non-child pid. Block until all pids exit.\n/// - Parameters:\n///   - timeout: wait until interval, nil means no timeout\n/// - Throws: WaitOtherPidError\n/// - Returns: isTimeout\nfunc waitOtherPids(_ pids: [Int32], timeout: TimeInterval? = nil) throws -> Bool {\n    \n    // create a kqueue\n    let kq = kqueue()\n    if kq == -1 {\n        throw WaitOtherPidError.createKqueueFailed(String(cString: strerror(errno)!))\n    }\n    \n    // input\n    // multiple changes is OR relation, kevent will return if any is match\n    var changes: [Darwin.kevent] = pids.map({ pid in\n        Darwin.kevent.init(ident: UInt(pid), filter: Int16(EVFILT_PROC), flags: UInt16(EV_ADD | EV_ENABLE), fflags: NOTE_EXIT, data: 0, udata: nil)\n    })\n    \n    let timeoutDeadline = timeout.map({ Date(timeIntervalSinceNow: $0)})\n    let remainTimeout: () ->timespec? = {\n        if let deadline = timeoutDeadline {\n            let d = max(deadline.timeIntervalSinceNow, 0)\n            let fractionalPart = d - TimeInterval(Int(d))\n            return timespec(tv_sec: Int(d), tv_nsec: Int(fractionalPart * 1000 * 1000 * 1000))\n        } else {\n            return nil\n        }\n    }\n    \n    // output\n    var events = changes.map{ _ in Darwin.kevent.init() }\n    \n    while !changes.isEmpty {\n        \n        // watch changes\n        // sync method\n        let numOfEvent: Int32\n        if var timeout = remainTimeout() {\n            numOfEvent = kevent(kq, changes, Int32(changes.count), &events, Int32(events.count), &timeout);\n        } else {\n            numOfEvent = kevent(kq, changes, Int32(changes.count), &events, Int32(events.count), nil);\n        }\n        \n        if numOfEvent < 0 {\n            throw WaitOtherPidError.keventFailed(String(cString: strerror(errno)!))\n        }\n        if numOfEvent == 0 {\n            // timeout. Return directly.\n            return true\n        }\n        \n        // handle the result\n        let realEvents = events[0..<Int(numOfEvent)]\n        let handledPids = Set(realEvents.map({ $0.ident }))\n        changes = changes.filter({ c in\n            !handledPids.contains(c.ident)\n        })\n\n        for event in realEvents {\n            if Int32(event.flags) & EV_ERROR > 0 { // @see 'man kevent'\n                let errorCode = event.data\n                if errorCode == ESRCH {\n                    // \"The specified process to attach to does not exist\"\n                    // ingored\n                } else {\n                    print(\"[Error] kevent result failed with code \\(errorCode), pid \\(event.ident)\")\n                }\n            } else {\n                // succeeded event, pid exit\n            }\n        }\n    }\n    return false\n}\nenum WaitOtherPidError: Error {\n    case createKqueueFailed(String)\n    case keventFailed(String)\n}\n\n\n", "\nAppricate @Hongli's answer for macOS with kqueue. I implement it with swift\n/// Wait any pids, including non-child pid. Block until all pids exit.\n/// - Parameters:\n///   - timeout: wait until interval, nil means no timeout\n/// - Throws: WaitOtherPidError\n/// - Returns: isTimeout\nfunc waitOtherPids(_ pids: [Int32], timeout: TimeInterval? = nil) throws -> Bool {\n    \n    // create a kqueue\n    let kq = kqueue()\n    if kq == -1 {\n        throw WaitOtherPidError.createKqueueFailed(String(cString: strerror(errno)!))\n    }\n    \n    // input\n    // multiple changes is OR relation, kevent will return if any is match\n    var changes: [Darwin.kevent] = pids.map({ pid in\n        Darwin.kevent.init(ident: UInt(pid), filter: Int16(EVFILT_PROC), flags: UInt16(EV_ADD | EV_ENABLE), fflags: NOTE_EXIT, data: 0, udata: nil)\n    })\n    \n    let timeoutDeadline = timeout.map({ Date(timeIntervalSinceNow: $0)})\n    let remainTimeout: () ->timespec? = {\n        if let deadline = timeoutDeadline {\n            let d = max(deadline.timeIntervalSinceNow, 0)\n            let fractionalPart = d - TimeInterval(Int(d))\n            return timespec(tv_sec: Int(d), tv_nsec: Int(fractionalPart * 1000 * 1000 * 1000))\n        } else {\n            return nil\n        }\n    }\n    \n    // output\n    var events = changes.map{ _ in Darwin.kevent.init() }\n    \n    while !changes.isEmpty {\n        \n        // watch changes\n        // sync method\n        let numOfEvent: Int32\n        if var timeout = remainTimeout() {\n            numOfEvent = kevent(kq, changes, Int32(changes.count), &events, Int32(events.count), &timeout);\n        } else {\n            numOfEvent = kevent(kq, changes, Int32(changes.count), &events, Int32(events.count), nil);\n        }\n        \n        if numOfEvent < 0 {\n            throw WaitOtherPidError.keventFailed(String(cString: strerror(errno)!))\n        }\n        if numOfEvent == 0 {\n            // timeout. Return directly.\n            return true\n        }\n        \n        // handle the result\n        let realEvents = events[0..<Int(numOfEvent)]\n        let handledPids = Set(realEvents.map({ $0.ident }))\n        changes = changes.filter({ c in\n            !handledPids.contains(c.ident)\n        })\n\n        for event in realEvents {\n            if Int32(event.flags) & EV_ERROR > 0 { // @see 'man kevent'\n                let errorCode = event.data\n                if errorCode == ESRCH {\n                    // \"The specified process to attach to does not exist\"\n                    // ingored\n                } else {\n                    print(\"[Error] kevent result failed with code \\(errorCode), pid \\(event.ident)\")\n                }\n            } else {\n                // succeeded event, pid exit\n            }\n        }\n    }\n    return false\n}\nenum WaitOtherPidError: Error {\n    case createKqueueFailed(String)\n    case keventFailed(String)\n}\n\n\n", "\nAppricate @Hongli's answer for macOS with kqueue. I implement it with swift\n/// Wait any pids, including non-child pid. Block until all pids exit.\n/// - Parameters:\n///   - timeout: wait until interval, nil means no timeout\n/// - Throws: WaitOtherPidError\n/// - Returns: isTimeout\nfunc waitOtherPids(_ pids: [Int32], timeout: TimeInterval? = nil) throws -> Bool {\n    \n    // create a kqueue\n    let kq = kqueue()\n    if kq == -1 {\n        throw WaitOtherPidError.createKqueueFailed(String(cString: strerror(errno)!))\n    }\n    \n    // input\n    // multiple changes is OR relation, kevent will return if any is match\n    var changes: [Darwin.kevent] = pids.map({ pid in\n        Darwin.kevent.init(ident: UInt(pid), filter: Int16(EVFILT_PROC), flags: UInt16(EV_ADD | EV_ENABLE), fflags: NOTE_EXIT, data: 0, udata: nil)\n    })\n    \n    let timeoutDeadline = timeout.map({ Date(timeIntervalSinceNow: $0)})\n    let remainTimeout: () ->timespec? = {\n        if let deadline = timeoutDeadline {\n            let d = max(deadline.timeIntervalSinceNow, 0)\n            let fractionalPart = d - TimeInterval(Int(d))\n            return timespec(tv_sec: Int(d), tv_nsec: Int(fractionalPart * 1000 * 1000 * 1000))\n        } else {\n            return nil\n        }\n    }\n    \n    // output\n    var events = changes.map{ _ in Darwin.kevent.init() }\n    \n    while !changes.isEmpty {\n        \n        // watch changes\n        // sync method\n        let numOfEvent: Int32\n        if var timeout = remainTimeout() {\n            numOfEvent = kevent(kq, changes, Int32(changes.count), &events, Int32(events.count), &timeout);\n        } else {\n            numOfEvent = kevent(kq, changes, Int32(changes.count), &events, Int32(events.count), nil);\n        }\n        \n        if numOfEvent < 0 {\n            throw WaitOtherPidError.keventFailed(String(cString: strerror(errno)!))\n        }\n        if numOfEvent == 0 {\n            // timeout. Return directly.\n            return true\n        }\n        \n        // handle the result\n        let realEvents = events[0..<Int(numOfEvent)]\n        let handledPids = Set(realEvents.map({ $0.ident }))\n        changes = changes.filter({ c in\n            !handledPids.contains(c.ident)\n        })\n\n        for event in realEvents {\n            if Int32(event.flags) & EV_ERROR > 0 { // @see 'man kevent'\n                let errorCode = event.data\n                if errorCode == ESRCH {\n                    // \"The specified process to attach to does not exist\"\n                    // ingored\n                } else {\n                    print(\"[Error] kevent result failed with code \\(errorCode), pid \\(event.ident)\")\n                }\n            } else {\n                // succeeded event, pid exit\n            }\n        }\n    }\n    return false\n}\nenum WaitOtherPidError: Error {\n    case createKqueueFailed(String)\n    case keventFailed(String)\n}\n\n\n", "\nAppricate @Hongli's answer for macOS with kqueue. I implement it with swift\n/// Wait any pids, including non-child pid. Block until all pids exit.\n/// - Parameters:\n///   - timeout: wait until interval, nil means no timeout\n/// - Throws: WaitOtherPidError\n/// - Returns: isTimeout\nfunc waitOtherPids(_ pids: [Int32], timeout: TimeInterval? = nil) throws -> Bool {\n    \n    // create a kqueue\n    let kq = kqueue()\n    if kq == -1 {\n        throw WaitOtherPidError.createKqueueFailed(String(cString: strerror(errno)!))\n    }\n    \n    // input\n    // multiple changes is OR relation, kevent will return if any is match\n    var changes: [Darwin.kevent] = pids.map({ pid in\n        Darwin.kevent.init(ident: UInt(pid), filter: Int16(EVFILT_PROC), flags: UInt16(EV_ADD | EV_ENABLE), fflags: NOTE_EXIT, data: 0, udata: nil)\n    })\n    \n    let timeoutDeadline = timeout.map({ Date(timeIntervalSinceNow: $0)})\n    let remainTimeout: () ->timespec? = {\n        if let deadline = timeoutDeadline {\n            let d = max(deadline.timeIntervalSinceNow, 0)\n            let fractionalPart = d - TimeInterval(Int(d))\n            return timespec(tv_sec: Int(d), tv_nsec: Int(fractionalPart * 1000 * 1000 * 1000))\n        } else {\n            return nil\n        }\n    }\n    \n    // output\n    var events = changes.map{ _ in Darwin.kevent.init() }\n    \n    while !changes.isEmpty {\n        \n        // watch changes\n        // sync method\n        let numOfEvent: Int32\n        if var timeout = remainTimeout() {\n            numOfEvent = kevent(kq, changes, Int32(changes.count), &events, Int32(events.count), &timeout);\n        } else {\n            numOfEvent = kevent(kq, changes, Int32(changes.count), &events, Int32(events.count), nil);\n        }\n        \n        if numOfEvent < 0 {\n            throw WaitOtherPidError.keventFailed(String(cString: strerror(errno)!))\n        }\n        if numOfEvent == 0 {\n            // timeout. Return directly.\n            return true\n        }\n        \n        // handle the result\n        let realEvents = events[0..<Int(numOfEvent)]\n        let handledPids = Set(realEvents.map({ $0.ident }))\n        changes = changes.filter({ c in\n            !handledPids.contains(c.ident)\n        })\n\n        for event in realEvents {\n            if Int32(event.flags) & EV_ERROR > 0 { // @see 'man kevent'\n                let errorCode = event.data\n                if errorCode == ESRCH {\n                    // \"The specified process to attach to does not exist\"\n                    // ingored\n                } else {\n                    print(\"[Error] kevent result failed with code \\(errorCode), pid \\(event.ident)\")\n                }\n            } else {\n                // succeeded event, pid exit\n            }\n        }\n    }\n    return false\n}\nenum WaitOtherPidError: Error {\n    case createKqueueFailed(String)\n    case keventFailed(String)\n}\n\n\n", "\nAppricate @Hongli's answer for macOS with kqueue. I implement it with swift\n/// Wait any pids, including non-child pid. Block until all pids exit.\n/// - Parameters:\n///   - timeout: wait until interval, nil means no timeout\n/// - Throws: WaitOtherPidError\n/// - Returns: isTimeout\nfunc waitOtherPids(_ pids: [Int32], timeout: TimeInterval? = nil) throws -> Bool {\n    \n    // create a kqueue\n    let kq = kqueue()\n    if kq == -1 {\n        throw WaitOtherPidError.createKqueueFailed(String(cString: strerror(errno)!))\n    }\n    \n    // input\n    // multiple changes is OR relation, kevent will return if any is match\n    var changes: [Darwin.kevent] = pids.map({ pid in\n        Darwin.kevent.init(ident: UInt(pid), filter: Int16(EVFILT_PROC), flags: UInt16(EV_ADD | EV_ENABLE), fflags: NOTE_EXIT, data: 0, udata: nil)\n    })\n    \n    let timeoutDeadline = timeout.map({ Date(timeIntervalSinceNow: $0)})\n    let remainTimeout: () ->timespec? = {\n        if let deadline = timeoutDeadline {\n            let d = max(deadline.timeIntervalSinceNow, 0)\n            let fractionalPart = d - TimeInterval(Int(d))\n            return timespec(tv_sec: Int(d), tv_nsec: Int(fractionalPart * 1000 * 1000 * 1000))\n        } else {\n            return nil\n        }\n    }\n    \n    // output\n    var events = changes.map{ _ in Darwin.kevent.init() }\n    \n    while !changes.isEmpty {\n        \n        // watch changes\n        // sync method\n        let numOfEvent: Int32\n        if var timeout = remainTimeout() {\n            numOfEvent = kevent(kq, changes, Int32(changes.count), &events, Int32(events.count), &timeout);\n        } else {\n            numOfEvent = kevent(kq, changes, Int32(changes.count), &events, Int32(events.count), nil);\n        }\n        \n        if numOfEvent < 0 {\n            throw WaitOtherPidError.keventFailed(String(cString: strerror(errno)!))\n        }\n        if numOfEvent == 0 {\n            // timeout. Return directly.\n            return true\n        }\n        \n        // handle the result\n        let realEvents = events[0..<Int(numOfEvent)]\n        let handledPids = Set(realEvents.map({ $0.ident }))\n        changes = changes.filter({ c in\n            !handledPids.contains(c.ident)\n        })\n\n        for event in realEvents {\n            if Int32(event.flags) & EV_ERROR > 0 { // @see 'man kevent'\n                let errorCode = event.data\n                if errorCode == ESRCH {\n                    // \"The specified process to attach to does not exist\"\n                    // ingored\n                } else {\n                    print(\"[Error] kevent result failed with code \\(errorCode), pid \\(event.ident)\")\n                }\n            } else {\n                // succeeded event, pid exit\n            }\n        }\n    }\n    return false\n}\nenum WaitOtherPidError: Error {\n    case createKqueueFailed(String)\n    case keventFailed(String)\n}\n\n\n", "\nAppricate @Hongli's answer for macOS with kqueue. I implement it with swift\n/// Wait any pids, including non-child pid. Block until all pids exit.\n/// - Parameters:\n///   - timeout: wait until interval, nil means no timeout\n/// - Throws: WaitOtherPidError\n/// - Returns: isTimeout\nfunc waitOtherPids(_ pids: [Int32], timeout: TimeInterval? = nil) throws -> Bool {\n    \n    // create a kqueue\n    let kq = kqueue()\n    if kq == -1 {\n        throw WaitOtherPidError.createKqueueFailed(String(cString: strerror(errno)!))\n    }\n    \n    // input\n    // multiple changes is OR relation, kevent will return if any is match\n    var changes: [Darwin.kevent] = pids.map({ pid in\n        Darwin.kevent.init(ident: UInt(pid), filter: Int16(EVFILT_PROC), flags: UInt16(EV_ADD | EV_ENABLE), fflags: NOTE_EXIT, data: 0, udata: nil)\n    })\n    \n    let timeoutDeadline = timeout.map({ Date(timeIntervalSinceNow: $0)})\n    let remainTimeout: () ->timespec? = {\n        if let deadline = timeoutDeadline {\n            let d = max(deadline.timeIntervalSinceNow, 0)\n            let fractionalPart = d - TimeInterval(Int(d))\n            return timespec(tv_sec: Int(d), tv_nsec: Int(fractionalPart * 1000 * 1000 * 1000))\n        } else {\n            return nil\n        }\n    }\n    \n    // output\n    var events = changes.map{ _ in Darwin.kevent.init() }\n    \n    while !changes.isEmpty {\n        \n        // watch changes\n        // sync method\n        let numOfEvent: Int32\n        if var timeout = remainTimeout() {\n            numOfEvent = kevent(kq, changes, Int32(changes.count), &events, Int32(events.count), &timeout);\n        } else {\n            numOfEvent = kevent(kq, changes, Int32(changes.count), &events, Int32(events.count), nil);\n        }\n        \n        if numOfEvent < 0 {\n            throw WaitOtherPidError.keventFailed(String(cString: strerror(errno)!))\n        }\n        if numOfEvent == 0 {\n            // timeout. Return directly.\n            return true\n        }\n        \n        // handle the result\n        let realEvents = events[0..<Int(numOfEvent)]\n        let handledPids = Set(realEvents.map({ $0.ident }))\n        changes = changes.filter({ c in\n            !handledPids.contains(c.ident)\n        })\n\n        for event in realEvents {\n            if Int32(event.flags) & EV_ERROR > 0 { // @see 'man kevent'\n                let errorCode = event.data\n                if errorCode == ESRCH {\n                    // \"The specified process to attach to does not exist\"\n                    // ingored\n                } else {\n                    print(\"[Error] kevent result failed with code \\(errorCode), pid \\(event.ident)\")\n                }\n            } else {\n                // succeeded event, pid exit\n            }\n        }\n    }\n    return false\n}\nenum WaitOtherPidError: Error {\n    case createKqueueFailed(String)\n    case keventFailed(String)\n}\n\n\n", "\nAppricate @Hongli's answer for macOS with kqueue. I implement it with swift\n/// Wait any pids, including non-child pid. Block until all pids exit.\n/// - Parameters:\n///   - timeout: wait until interval, nil means no timeout\n/// - Throws: WaitOtherPidError\n/// - Returns: isTimeout\nfunc waitOtherPids(_ pids: [Int32], timeout: TimeInterval? = nil) throws -> Bool {\n    \n    // create a kqueue\n    let kq = kqueue()\n    if kq == -1 {\n        throw WaitOtherPidError.createKqueueFailed(String(cString: strerror(errno)!))\n    }\n    \n    // input\n    // multiple changes is OR relation, kevent will return if any is match\n    var changes: [Darwin.kevent] = pids.map({ pid in\n        Darwin.kevent.init(ident: UInt(pid), filter: Int16(EVFILT_PROC), flags: UInt16(EV_ADD | EV_ENABLE), fflags: NOTE_EXIT, data: 0, udata: nil)\n    })\n    \n    let timeoutDeadline = timeout.map({ Date(timeIntervalSinceNow: $0)})\n    let remainTimeout: () ->timespec? = {\n        if let deadline = timeoutDeadline {\n            let d = max(deadline.timeIntervalSinceNow, 0)\n            let fractionalPart = d - TimeInterval(Int(d))\n            return timespec(tv_sec: Int(d), tv_nsec: Int(fractionalPart * 1000 * 1000 * 1000))\n        } else {\n            return nil\n        }\n    }\n    \n    // output\n    var events = changes.map{ _ in Darwin.kevent.init() }\n    \n    while !changes.isEmpty {\n        \n        // watch changes\n        // sync method\n        let numOfEvent: Int32\n        if var timeout = remainTimeout() {\n            numOfEvent = kevent(kq, changes, Int32(changes.count), &events, Int32(events.count), &timeout);\n        } else {\n            numOfEvent = kevent(kq, changes, Int32(changes.count), &events, Int32(events.count), nil);\n        }\n        \n        if numOfEvent < 0 {\n            throw WaitOtherPidError.keventFailed(String(cString: strerror(errno)!))\n        }\n        if numOfEvent == 0 {\n            // timeout. Return directly.\n            return true\n        }\n        \n        // handle the result\n        let realEvents = events[0..<Int(numOfEvent)]\n        let handledPids = Set(realEvents.map({ $0.ident }))\n        changes = changes.filter({ c in\n            !handledPids.contains(c.ident)\n        })\n\n        for event in realEvents {\n            if Int32(event.flags) & EV_ERROR > 0 { // @see 'man kevent'\n                let errorCode = event.data\n                if errorCode == ESRCH {\n                    // \"The specified process to attach to does not exist\"\n                    // ingored\n                } else {\n                    print(\"[Error] kevent result failed with code \\(errorCode), pid \\(event.ident)\")\n                }\n            } else {\n                // succeeded event, pid exit\n            }\n        }\n    }\n    return false\n}\nenum WaitOtherPidError: Error {\n    case createKqueueFailed(String)\n    case keventFailed(String)\n}\n\n\n", "\nGive this a try. It works without having to memoize the backgrounded PIDs (by using jobs -p), preserves exit codes, and exits early if one task fails.\nwhile (($(jobs -p | wc -l) > 0)); do\n  if wait -n; then\n    :\n  else\n    ret=$?\n    jobs -p | xargs -n1 kill 2>/dev/null\n    wait\n    exit $ret\n  fi\ndone\n\nThe if wait -n; then : ensures that you can still use ERREXIT (! masks the exit code).\nA oneliner that skips the early exit would be\nwhile read -r pid; do wait \"$pid\"; done < <(jobs -p)\n\nAs to your concerns:\n\njobs only lists background processes under the current process.\nwait cannot wait on PIDs that aren't owned by the current process.\n\n", "\nGive this a try. It works without having to memoize the backgrounded PIDs (by using jobs -p), preserves exit codes, and exits early if one task fails.\nwhile (($(jobs -p | wc -l) > 0)); do\n  if wait -n; then\n    :\n  else\n    ret=$?\n    jobs -p | xargs -n1 kill 2>/dev/null\n    wait\n    exit $ret\n  fi\ndone\n\nThe if wait -n; then : ensures that you can still use ERREXIT (! masks the exit code).\nA oneliner that skips the early exit would be\nwhile read -r pid; do wait \"$pid\"; done < <(jobs -p)\n\nAs to your concerns:\n\njobs only lists background processes under the current process.\nwait cannot wait on PIDs that aren't owned by the current process.\n\n", "\nGive this a try. It works without having to memoize the backgrounded PIDs (by using jobs -p), preserves exit codes, and exits early if one task fails.\nwhile (($(jobs -p | wc -l) > 0)); do\n  if wait -n; then\n    :\n  else\n    ret=$?\n    jobs -p | xargs -n1 kill 2>/dev/null\n    wait\n    exit $ret\n  fi\ndone\n\nThe if wait -n; then : ensures that you can still use ERREXIT (! masks the exit code).\nA oneliner that skips the early exit would be\nwhile read -r pid; do wait \"$pid\"; done < <(jobs -p)\n\nAs to your concerns:\n\njobs only lists background processes under the current process.\nwait cannot wait on PIDs that aren't owned by the current process.\n\n", "\nAs Jonathan Leffler said the problem was with the args, execvp() needs that the array off args has in the end NULL.\nand that fixed the problem.\nthe Right code :\n    char str1[LINELEN + 1];\n    char str2[LINELEN + 1];\n    int childReturns = 1;\n    if (argc != 2)\n        return -1;\n\n    char *prog = progName(argv[1]);\n    if (prog == NULL)\n        return -1;\n    char *args[4];\n    args[3] = NULL;\n    args[0] = prog;\n    while (1)\n    {\n        printf(\"Enter string:\");\n        if (mygets(str1, LINELEN) == NULL)\n            break;\n        printf(\"Enter  string:\");\n        if (mygets(str2, LINELEN) == NULL)\n            break;\n        args[1] = str1;\n        args[2] = str2;\n        int processId = fork();\n        if (processId == 0)\n        {\n            execvp(prog, args);\n        }\n        else\n        {\n            wait(&childReturns); // Wait for the child\n            printf(\"Child  code is %d\\n\", WEXITSTATUS(childReturns));\n        }\n    }\n    free(prog);\n    return 0;```\n\n", "\nAs Jonathan Leffler said the problem was with the args, execvp() needs that the array off args has in the end NULL.\nand that fixed the problem.\nthe Right code :\n    char str1[LINELEN + 1];\n    char str2[LINELEN + 1];\n    int childReturns = 1;\n    if (argc != 2)\n        return -1;\n\n    char *prog = progName(argv[1]);\n    if (prog == NULL)\n        return -1;\n    char *args[4];\n    args[3] = NULL;\n    args[0] = prog;\n    while (1)\n    {\n        printf(\"Enter string:\");\n        if (mygets(str1, LINELEN) == NULL)\n            break;\n        printf(\"Enter  string:\");\n        if (mygets(str2, LINELEN) == NULL)\n            break;\n        args[1] = str1;\n        args[2] = str2;\n        int processId = fork();\n        if (processId == 0)\n        {\n            execvp(prog, args);\n        }\n        else\n        {\n            wait(&childReturns); // Wait for the child\n            printf(\"Child  code is %d\\n\", WEXITSTATUS(childReturns));\n        }\n    }\n    free(prog);\n    return 0;```\n\n", "\nWait is for listening to state changes and obtaining information about the child. A state change is child termination, stopping or resuming by a signal. Wait allows the system to release the resources associated with the child. If a wait is not performed, then the terminated child remains in a \"zombie\" state. \n\nThe kernel maintains a minimal set of information about the zombie\n  process  (PID,  termination  status,\n         resource usage information) in order to allow the parent to later perform a wait to obtain information about the child.  As long\n  as a zombie is not removed from the system via a\n         wait, it will consume a slot in the kernel process table, and if this table fills, it will not be possible to create further\n  processes.  If a parent process terminates, then its\n         \"zombie\" children (if any) are adopted by init(1), which automatically performs a wait to remove the zombies.\n\n", "\nWait is for listening to state changes and obtaining information about the child. A state change is child termination, stopping or resuming by a signal. Wait allows the system to release the resources associated with the child. If a wait is not performed, then the terminated child remains in a \"zombie\" state. \n\nThe kernel maintains a minimal set of information about the zombie\n  process  (PID,  termination  status,\n         resource usage information) in order to allow the parent to later perform a wait to obtain information about the child.  As long\n  as a zombie is not removed from the system via a\n         wait, it will consume a slot in the kernel process table, and if this table fills, it will not be possible to create further\n  processes.  If a parent process terminates, then its\n         \"zombie\" children (if any) are adopted by init(1), which automatically performs a wait to remove the zombies.\n\n", "\npid2 = fork() is executed by the parent and the first child created from pid1 = fork(), which is not something you desire from the question description.\nYou might want to have something like this\n#include <stdio.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n\nint main(int argc, char *argv[]) {\n\n    pid_t pid1, pid2;\n    int status;\n    pid1 = fork();\n\n    if(pid1 == 0) {\n        //first child performing selection sort\n\n        exit(0);\n    }\n\n    if(pid1 > 0) {\n        pid2 = fork();\n\n        if(pid2 == 0) {\n            //second child performing bubble sort\n        \n            exit(0);\n        }\n\n        if(pid2 > 0) {\n            wait(&status);\n\n            if(WIFEXITED(status)) {\n                printf(\"Parent process executed %d\\n\",WEXITSTATUS(status));\n            }\n        }\n    }\n}\n\n", "\nNumber 255 is represented as 11111111 in binary and FF in hexadecimal. Bitwise anding with this number will leave only only 8 lowest bits. Higher bits would be zeroed.\nThis operation is likely unnecessary as manual for wait() tells:\nSYNOPSIS\n       void exit(int status);\nDESCRIPTION\n       The exit() function causes normal process termination and\n       the value of status & 0xFF is returned to the parent (see wait(2)).\n\n", "\nNumber 255 is represented as 11111111 in binary and FF in hexadecimal. Bitwise anding with this number will leave only only 8 lowest bits. Higher bits would be zeroed.\nThis operation is likely unnecessary as manual for wait() tells:\nSYNOPSIS\n       void exit(int status);\nDESCRIPTION\n       The exit() function causes normal process termination and\n       the value of status & 0xFF is returned to the parent (see wait(2)).\n\n", "\nBTW, I can see there are a lot of recommendations for my code, I will try to digest it :). Thanks all again!!\n", "\nBTW, I can see there are a lot of recommendations for my code, I will try to digest it :). Thanks all again!!\n", "\nUse:\nps -e -opid,ppid,pgid,stat,etime,cmd | grep defunct\n\nto see your zombies, also the ppid and pgid to see the parent ID and process group ID. The etime to see the elapsed (cpu) time your zombie has been alive. The parent ID is useful to send custom signals to the parent process.\nIf the parent process is right coded to catch and handle the SIGCHLD signal, and to what expected (i.e., wait/reap the zombies), then you can submit:\nkill -CHLD <parent_pid>\n\nto tell the parent to reap all their zombies.\n", "\nUse:\nps -e -opid,ppid,pgid,stat,etime,cmd | grep defunct\n\nto see your zombies, also the ppid and pgid to see the parent ID and process group ID. The etime to see the elapsed (cpu) time your zombie has been alive. The parent ID is useful to send custom signals to the parent process.\nIf the parent process is right coded to catch and handle the SIGCHLD signal, and to what expected (i.e., wait/reap the zombies), then you can submit:\nkill -CHLD <parent_pid>\n\nto tell the parent to reap all their zombies.\n", "\nUse:\nps -e -opid,ppid,pgid,stat,etime,cmd | grep defunct\n\nto see your zombies, also the ppid and pgid to see the parent ID and process group ID. The etime to see the elapsed (cpu) time your zombie has been alive. The parent ID is useful to send custom signals to the parent process.\nIf the parent process is right coded to catch and handle the SIGCHLD signal, and to what expected (i.e., wait/reap the zombies), then you can submit:\nkill -CHLD <parent_pid>\n\nto tell the parent to reap all their zombies.\n", "\nThank you to all that helped, here is what caused my dilemma for anyone google searching this. I determined from inserting \"python -c \"from time import sleep; sleep(30)\"\" into my code that the first two python scripts were waiting as expected, the final one was not (the timer would immediately trigger after that script ran), turns out that the third python script also called another small python script that had a \"&\" at the end of it that was ignoring any commands to wait on it. Simply removing this & allowed all the code to run sequentially. \u2013 Michael Bates\n"]}