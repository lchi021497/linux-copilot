{"prompt": ["I created a log file by running the iostat command to a text file, and ran the command in the background using nohup.#nohup iostat -xm 5 > /z/logfile.txt &\nLater on, I created a cronjob that runs every ten minutes doing the same as above, after I realized my process was being killed by a reboot.\nI've also setup log-rotation as below:/z/logfile.txt {\n        size 20M\n        rotate 0\n        create 0644 root root\n        missingok\n        notifempty\n\n} \nNow I have realized that the logfile.txt gets deleted but the iostat command keeps pointing at deleted files as shown by the lsof -n | grep deleted command. There the disk space is not freed.How can I make sure the files are rotated and thereafter iostat points to the newly created file, freeing up disk space?Any ideas how to set it up correctly?", "I created a log file by running the iostat command to a text file, and ran the command in the background using nohup.#nohup iostat -xm 5 > /z/logfile.txt &\nLater on, I created a cronjob that runs every ten minutes doing the same as above, after I realized my process was being killed by a reboot.\nI've also setup log-rotation as below:/z/logfile.txt {\n        size 20M\n        rotate 0\n        create 0644 root root\n        missingok\n        notifempty\n\n} \nNow I have realized that the logfile.txt gets deleted but the iostat command keeps pointing at deleted files as shown by the lsof -n | grep deleted command. There the disk space is not freed.How can I make sure the files are rotated and thereafter iostat points to the newly created file, freeing up disk space?Any ideas how to set it up correctly?", "I want to know disk read / write utilization\nespecially, only read or write utilization or write utilization \nI tried using iostat but it shows entire utilization,How to check only disk read or only write utilization (The progress is consist of read + write works) ", "In earlier versions of \"vmstat\", the device minor version was used to determine whether it was a partition or a disk (0 => disk and  >0 => partition)). Am I not correct?\nThen, from kernel version 2.6.x some metrics were measured only at the disk-level, and hence the parsing algorithm was based on the number of metrics associated with a device (11 metrics => disk and 4 metrics => partition).However, in kernel version 2.6.18 there are also 11 metrics for partitions, and RAM drives also have minor device numbers greater than 0. See below:   1    0 ram0 0 0 0 0 0 0 0 0 0 0 0\n   1    1 ram1 0 0 0 0 0 0 0 0 0 0 0\n   1    2 ram2 0 0 0 0 0 0 0 0 0 0 0\n   1    3 ram3 0 0 0 0 0 0 0 0 0 0 0\n   3    0 hda 364304 44416 9757168 9689046 18080864 19417076 299988386 1952073601 0 167032032 1961762954\n   3    1 hda1 170 1105 2566 2352 5 0 10 13 0 1854 2365\n   3    2 hda2 364112 43281 9754186 9686147 18080859 19417076 299988376 1952073588 0 167031121 1961760042\n 253    0 dm-0 405386 0 9738418 14371284 37409328 0 299274624 2479168190 0 167053870 2493542151\n 253    1 dm-1 1906 0 15248 70026 89219 0 713752 70030052 0 70247 70100078\n  22   64 hdd 0 0 0 0 0 0 0 0 0 0 0\n   2    0 fd0 0 0 0 0 0 0 0 0 0 0 0\n   9    0 md0 0 0 0 0 0 0 0 0 0 0 0\nHow do I go about separating partitions from disks in this case? My final object is to determine the overall I/O of the system.\nAny help in this regard will be highly appreciated."], "chosen": ["\nWould pointing your cronjob iostat command at a softlink not work?\nln -s /z/logfile.txt iostat_link.txt\nnohup iostat -xm 5 > /z/iostat_link.txt &\n\nI haven't used logrotate before, but I tested this by manually changing the file in the background while I had this running:\n#Make the files\ntouch afile1.txt\nln -s afile1.txt file.txt\n\n#Kick off loop\nfor i in {1..1000};do echo \"running still $i\" >> file.txt;sleep 3;done &\n\n[localhost (2017-05-15 20:30:55) IP: 26.176 ~]# cat afile1.txt\nrunning still 7\nrunning still 8\nrunning still 9\n\n#Change the file out from under the loop\nmv afile1.txt afile1.txt.backup;touch afile1.txt\n\n[localhost (2017-05-15 20:31:21) IP: 26.176 ~]# cat afile1.txt\nrunning still 15\nrunning still 16\nrunning still 17\n\n", "\nOne solution would be to write a program that will read from iostat, write to the output file, and accept a signal to reopen the file.  For example, if you did: iostat -xm 5 | log-daemon /z/logfile.txt where log-daemon is a simple script like:\n#!/bin/bash\necho $$ > /var/run/log-daemon\nexec > $1\ntrap 'exec > $1' SIGHUP\nread line\nwhile test $? -le 0; do \n        echo $line\n        read line\ndone\n\nThen add a postrotate clause in the logrotate config to send a HUP to the log-daemon:\npostrotate\n               /usr/bin/kill -HUP $(cat /var/run/log-daemon)\n\n", "\nIf you wish to get the result in a graphical format then go with munin monitoring tool  http://munin-monitoring.org/    It provide graphical information about Disk IO per device, Disk latency per device, Disk utilization and Disk throughput. \n", "\nHmmm... Well of course that's the first place I looked. I wasn't quite satisfied, though, with the results. But, here's what I discovered:\n-- Run iostat -dkx and you'll get KBytes/sec read and written to and from every disk in the system. iostat uses quite a complex formula to do it.\n-- Take the values of the counters for blocks in and blocks out (pgpgin and pgpgout) in any 2.6.x kernel and multiply it by 1024, and you get the exact same answer!\n"], "rejected": ["\nCheck if file system where log is  recording is full. If you have such a case find and kill process or reboot server in worst case.\n", "\nCheck if file system where log is  recording is full. If you have such a case find and kill process or reboot server in worst case.\n", "\nPerhaps iotop is the right tool for you.\nOn the left you can see which process causes how much load and the hdparm test I ran in the session on the right is clearly shown there.\n\n", "\nMaybe have a look at what existing programs do?  dstat is a good one, written in python.  iostat is the old traditional one, and it's -x output only includes disks (and device-mapper devices), not partitions.\n"]}