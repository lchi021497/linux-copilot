{"prompt": ["I use startx to start X which will evaluate my .xinitrc. In my .xinitrc I start my window manager using /usr/bin/mywm. Now, if I kill my WM (in order to f.e. test some other WM), X will terminate too because the .xinitrc script reached EOF.\nSo I added this at the end of my .xinitrc:while true; do sleep 10000; done\nThis way X won't terminate if I kill my WM. Now my question: how can I do an infinite sleep instead of looping sleep? Is there a command which will kinda like freeze the script?", "I use startx to start X which will evaluate my .xinitrc. In my .xinitrc I start my window manager using /usr/bin/mywm. Now, if I kill my WM (in order to f.e. test some other WM), X will terminate too because the .xinitrc script reached EOF.\nSo I added this at the end of my .xinitrc:while true; do sleep 10000; done\nThis way X won't terminate if I kill my WM. Now my question: how can I do an infinite sleep instead of looping sleep? Is there a command which will kinda like freeze the script?", "I use startx to start X which will evaluate my .xinitrc. In my .xinitrc I start my window manager using /usr/bin/mywm. Now, if I kill my WM (in order to f.e. test some other WM), X will terminate too because the .xinitrc script reached EOF.\nSo I added this at the end of my .xinitrc:while true; do sleep 10000; done\nThis way X won't terminate if I kill my WM. Now my question: how can I do an infinite sleep instead of looping sleep? Is there a command which will kinda like freeze the script?", "I use startx to start X which will evaluate my .xinitrc. In my .xinitrc I start my window manager using /usr/bin/mywm. Now, if I kill my WM (in order to f.e. test some other WM), X will terminate too because the .xinitrc script reached EOF.\nSo I added this at the end of my .xinitrc:while true; do sleep 10000; done\nThis way X won't terminate if I kill my WM. Now my question: how can I do an infinite sleep instead of looping sleep? Is there a command which will kinda like freeze the script?", "I use startx to start X which will evaluate my .xinitrc. In my .xinitrc I start my window manager using /usr/bin/mywm. Now, if I kill my WM (in order to f.e. test some other WM), X will terminate too because the .xinitrc script reached EOF.\nSo I added this at the end of my .xinitrc:while true; do sleep 10000; done\nThis way X won't terminate if I kill my WM. Now my question: how can I do an infinite sleep instead of looping sleep? Is there a command which will kinda like freeze the script?", "I use startx to start X which will evaluate my .xinitrc. In my .xinitrc I start my window manager using /usr/bin/mywm. Now, if I kill my WM (in order to f.e. test some other WM), X will terminate too because the .xinitrc script reached EOF.\nSo I added this at the end of my .xinitrc:while true; do sleep 10000; done\nThis way X won't terminate if I kill my WM. Now my question: how can I do an infinite sleep instead of looping sleep? Is there a command which will kinda like freeze the script?", "I use startx to start X which will evaluate my .xinitrc. In my .xinitrc I start my window manager using /usr/bin/mywm. Now, if I kill my WM (in order to f.e. test some other WM), X will terminate too because the .xinitrc script reached EOF.\nSo I added this at the end of my .xinitrc:while true; do sleep 10000; done\nThis way X won't terminate if I kill my WM. Now my question: how can I do an infinite sleep instead of looping sleep? Is there a command which will kinda like freeze the script?", "I use startx to start X which will evaluate my .xinitrc. In my .xinitrc I start my window manager using /usr/bin/mywm. Now, if I kill my WM (in order to f.e. test some other WM), X will terminate too because the .xinitrc script reached EOF.\nSo I added this at the end of my .xinitrc:while true; do sleep 10000; done\nThis way X won't terminate if I kill my WM. Now my question: how can I do an infinite sleep instead of looping sleep? Is there a command which will kinda like freeze the script?", "I use startx to start X which will evaluate my .xinitrc. In my .xinitrc I start my window manager using /usr/bin/mywm. Now, if I kill my WM (in order to f.e. test some other WM), X will terminate too because the .xinitrc script reached EOF.\nSo I added this at the end of my .xinitrc:while true; do sleep 10000; done\nThis way X won't terminate if I kill my WM. Now my question: how can I do an infinite sleep instead of looping sleep? Is there a command which will kinda like freeze the script?", "I use startx to start X which will evaluate my .xinitrc. In my .xinitrc I start my window manager using /usr/bin/mywm. Now, if I kill my WM (in order to f.e. test some other WM), X will terminate too because the .xinitrc script reached EOF.\nSo I added this at the end of my .xinitrc:while true; do sleep 10000; done\nThis way X won't terminate if I kill my WM. Now my question: how can I do an infinite sleep instead of looping sleep? Is there a command which will kinda like freeze the script?", "I use startx to start X which will evaluate my .xinitrc. In my .xinitrc I start my window manager using /usr/bin/mywm. Now, if I kill my WM (in order to f.e. test some other WM), X will terminate too because the .xinitrc script reached EOF.\nSo I added this at the end of my .xinitrc:while true; do sleep 10000; done\nThis way X won't terminate if I kill my WM. Now my question: how can I do an infinite sleep instead of looping sleep? Is there a command which will kinda like freeze the script?", "I know the POSIX sleep(x) function makes the program sleep for x seconds. Is there a function to make the program sleep for x milliseconds in C++?", "I know the POSIX sleep(x) function makes the program sleep for x seconds. Is there a function to make the program sleep for x milliseconds in C++?", "I know the POSIX sleep(x) function makes the program sleep for x seconds. Is there a function to make the program sleep for x milliseconds in C++?", "I know the POSIX sleep(x) function makes the program sleep for x seconds. Is there a function to make the program sleep for x milliseconds in C++?", "I know the POSIX sleep(x) function makes the program sleep for x seconds. Is there a function to make the program sleep for x milliseconds in C++?", "I know the POSIX sleep(x) function makes the program sleep for x seconds. Is there a function to make the program sleep for x milliseconds in C++?", "I know the POSIX sleep(x) function makes the program sleep for x seconds. Is there a function to make the program sleep for x milliseconds in C++?", "I know the POSIX sleep(x) function makes the program sleep for x seconds. Is there a function to make the program sleep for x milliseconds in C++?", "I know the POSIX sleep(x) function makes the program sleep for x seconds. Is there a function to make the program sleep for x milliseconds in C++?", "I know the POSIX sleep(x) function makes the program sleep for x seconds. Is there a function to make the program sleep for x milliseconds in C++?", "I know the POSIX sleep(x) function makes the program sleep for x seconds. Is there a function to make the program sleep for x milliseconds in C++?", "I know the POSIX sleep(x) function makes the program sleep for x seconds. Is there a function to make the program sleep for x milliseconds in C++?", "I know the POSIX sleep(x) function makes the program sleep for x seconds. Is there a function to make the program sleep for x milliseconds in C++?", "I know the POSIX sleep(x) function makes the program sleep for x seconds. Is there a function to make the program sleep for x milliseconds in C++?", "I know the POSIX sleep(x) function makes the program sleep for x seconds. Is there a function to make the program sleep for x milliseconds in C++?", "I know the POSIX sleep(x) function makes the program sleep for x seconds. Is there a function to make the program sleep for x milliseconds in C++?", "I know the POSIX sleep(x) function makes the program sleep for x seconds. Is there a function to make the program sleep for x milliseconds in C++?", "I would like to know if there is a way to know how many seconds are left for a sleeping process (in 'S' status) to \"wake up\" in LINUX.For example, a python process I put to sleep using the sleep method.from time import sleep\nsleep(60)\nThanks!", "Hi a Java newbie here.I am currently building a Java application that executes multiple linux commands with Java Process builder.I am planning to execute a shell scipt, and since it this shell script is an external program that takes about a second to fully execute, let the process sleep for a second and write the result into a txt file.This is an external program and it must take in \"q\" to exit the program, so I finally need to type in q in the terminal.I have gotten help on this community before and the code I constructed with that help is as follows.public static void Linux(String fileName){\n\ntry {\n  File dir = new File(\"/usr/local/bin\");\n  ProcessBuilder pb = new ProcessBuilder(new String[]{\"/bin/bash\", \"-c\", \"./test_elanprv2.2.sh > \\\"$1\\\"; sleep 1; q\", \"_\", fileName + \".txt\"});\n  System.out.println(\"wrote text\");\n  pb.directory(dir);\n  Process start = pb.start();\n  start.destroy();\n}catch (Exception e){\n  e.printStackTrace();\n  System.out.println(\"failed to write text\");\n}\nThe process builder does create a txt file but it seems to be empty, and no matter how long I set the sleep to, the programs seems to instanly return the print statement.It would really be appreciated if anyone could tell me what I am doing wrong.Thank you in advance!!", "I have a C program that forks a child process at some point in a loop. The child process waits for the parent process to finish its job (some numerical calculations). If things go wrong, the parent process aborts and the child process should continue from the state when it was forked and retry the calculation with some modifications. Otherwise, the parents keeps running, and the child process should be killed.The communication between the parent and child process is through a memory mapped file, which only has 1 byte as a character that indicates the status of the parent process.The memory map is done like this    char child_flag[]=\"W\";\n    \n    fp1 = fopen( \"child_interface.dat\",\"wb\");\n    // the interface file has two bytes, but only one is meaningful to the program\n    fwrite(child_flag, 1, sizeof(child_flag), fp1); \n    fclose(fp1);\n    printf(\"child_interface.dat created\\n\");\n    \n    if(mmap_child_flag() ==0) {\n        printf(\"memory map of parent-child interface successful.\\n\");\n        fflush(stdout);\n    }\nThe wait loop in the child process is like thischild_pid = fork();                     \nif (child_pid ==0) { /* child process, wait for parent process to finish*/\n\n    mmap_child_flag();\n\n    while(child_file[0]=='W' ){  //Child waits\n        usleep(100000);\n    }\n    if(child_file[0]=='R'){ // run child process (as a new parent process)\n        child_file[0]='W';\n        goto label2;\n    }\n    if(child_file[0]=='K'){ //Kill child process\n        exit(0);\n    }\n}\n\nThe problem is that the child process seems to get stuck in the sleep while loop, even when the parent process has set the status to 'K' (checked in the file that is memory mapped). This code has been run on several linux based super computers, and the behavior seems very inconsistent. On some platforms, it can run smoothly, but on some others, it constantly get stuck in the while loop. Sometimes, if I add some statements inside the while loop after the usleep call, it can then run just fine.However, I'm not sure if the sleep while loop is the root cause of this problem. My guess is that because the process has almost nothing to do except to check a byte in the memory, the system let it sleep all the time and somehow \"forget\" to let it check the memory. Can such thing happen in the Linux system?This the function that does the actual mapping/* Memory map for parent-child processes interface */\nint mmap_child_flag()\n{\n    int fd_child;    \n    struct stat st_child; \n    \n    // open files\n    if ((fd_child = open(\"child_interface.dat\", O_RDWR)) == -1){\n        perror(\"open child_interface.dat\");\n        exit(1);\n    }\n    // stat\n    if (stat(\"child_interface.dat\", &st_child) == -1){\n        perror(\"stat of child_interface.dat\");\n        exit(1);\n    }\n    // map, child_file is global char array\n    child_file = mmap(0, st_child.st_size, PROT_WRITE, MAP_SHARED, fd_child, 0);\n    if (child_file == (char *)(-1)) {\n        perror(\"mmap child_interface.dat\");\n        exit(1);\n    }\n    return 0;\n}\n", "TL;DR: On Linux, how to disable mouse for a second using POSIX shell, without waiting for the second and do some job immediately?OS: Linux Mint 18.3 64-bit Cinnamon with LightDM display manager and Mutter (Muffin) window manager, X11 windowing system.Script environment: dash.I need to:\nDo something (does not matter what exactly for purposes of this question, but you can read the full script on Core Review).\nDisable mouse for a second. But the script must continue. This is very important.\nRun an application (Lightshot in general print screen mode) immediately.\nRationale: Because of Lightshot probably contains a bug, the mouse can't be moving just before the print screen, or else it usually results in something like this:"], "chosen": ["\ntail does not block\nAs always:  For everything there is an answer which is short, easy to understand, easy to follow and completely wrong.  Here tail -f /dev/null falls into this category ;)\nIf you look at it with strace tail -f /dev/null, you will notice that this solution is far from blocking!  It's probably even worse than the sleep solution in the question, as it uses (under Linux) precious resources like the inotify system.  Also other processes which write to /dev/null make tail loop.  (On my Ubuntu64 16.10 this adds several 10 syscalls per second on an already busy system.)\nThe question was for a blocking command\nUnfortunately, there is no such thing...\nRead: I do not know any way to achieve this with the shell directly.\nEverything (even sleep infinity) can be interrupted by some signal.  So if you want to be really sure it does not exceptionally return, it must run in a loop, like you already did for your sleep.  Please note, that (on Linux) /bin/sleep apparently is capped at 24 days (have a look at strace sleep infinity), hence the best you can do is probably:\nwhile :; do sleep 2073600; done\n\n(Note that I believe sleep loops internally for higher values than 24 days, but this means:  It is not blocking, it is very slowly looping.  So why not move this loop to the outside?)\n...but you can come quite near with an unnamed fifo\nYou can create something which really blocks as long as there are no signals sent to the process.  Following uses bash 4, 2 PIDs and 1 fifo:\nbash -c 'coproc { exec >&-; read; }; eval exec \"${COPROC[0]}<&-\"; wait'\n\nYou can check that this really blocks with strace if you like:\nstrace -ff bash -c '..see above..'\n\nHow this was constructed\nread blocks if there is no input data (see some other answers).  However, the tty (aka. stdin) usually is not a good source, as it is closed when the user logs out.  Also it might steal some input from the tty.  Not nice.\nTo make read block, we need to wait for something like a fifo which will never return anything.  In bash 4 there is a command which can provide us with exactly such a fifo: coproc.  If we also wait the blocking read (which is our coproc), we are done.  Sadly this needs to keep open two PIDs and a fifo.\nVariant with a named fifo\nIf you do not bother using a named fifo, you can do this as follows:\nmkfifo \"$HOME/.pause.fifo\" 2>/dev/null; read <\"$HOME/.pause.fifo\"\n\nNot using a loop on the read is a bit sloppy, but you can reuse this fifo as often as you like and make the reads terminate using touch \"$HOME/.pause.fifo\" (if there is more than a single read waiting, all are terminated at once).\nOr use the Linux pause() syscall\nFor the infinite blocking, there is a Linux system call named pause() which does what we want:  Wait forever (until a signal arrives).  However there is no userspace program for this (yet).\nC\nCreating such a program is easy.  Here is a snippet to create a very small Linux program called pause which pauses indefinitely (needs a C compiler such as gcc, and uses diet etc. to produce a small binary):\nprintf '#include <unistd.h>\\nint main(){for(;;)pause();}' > pause.c;\ndiet -Os cc pause.c -o pause;\nstrip -s pause;\nls -al pause\n\npython\nIf you do not want to compile something yourself, but you have python installed, you can use this under Linux:\npython -c 'while 1: import ctypes; ctypes.CDLL(None).pause()'\n\n(Note: Use exec python -c ... to replace the current shell, this frees one PID.  The solution can be improved with some IO redirection as well, freeing unused FDs.  This is up to you.)\nHow this works: ctypes.CDLL(None) loads the \"main program\" (including the C library) and runs the pause() function from it, all within a loop.  Less efficient than the C version, but works.\nMy recommendation for you:\nStay at the looping sleep.  It's easy to understand, very portable, and blocks for most of the time.\n", "\nsleep infinity, if implemented, will either sleep forever or sleep for the maximum sleep length, depending on the implementation.  (see other answers and comments for this question that mention some of the variations)\n", "\nMaybe this seems ugly, but why not just run cat and let it wait for input forever?\n", "\nTL;DR: since GNU coreutils version 9, sleep infinity does the right thing on Linux systems. Previously (and in other systems) the implementation was to actually sleep the maximum time allowed, which is finite.\n\nWondering why this is not documented anywhere, I bothered to read the sources from GNU coreutils and I found it executes roughly what follows:\n\nUse strtod from C stdlib on the first argument to convert 'infinity' to a double precision value. So, assuming IEEE 754 double precision the 64-bit positive infinity value is stored in the seconds variable.\nInvoke xnanosleep(seconds) (found in gnulib), this in turn invokes dtotimespec(seconds) (also in gnulib)  to convert from double to struct timespec.\nstruct timespec is just a pair of numbers: integer part (in seconds) and fractional part (in nanoseconds).\nNa\u00efvely converting positive infinity to integer would result in undefined behaviour (see \u00a76.3.1.4 from C standard), so instead it truncates to TYPE_MAXIMUM(time_t).\nThe actual value of TYPE_MAXIMUM(time_t) is not set in the standard (even sizeof(time_t) isn't); so, for the sake of example let's pick x86-64 from a recent Linux kernel.\n\nThis is TIME_T_MAX in the Linux kernel, which is defined (time.h) as:\n(time_t)((1UL << ((sizeof(time_t) << 3) - 1)) - 1)\n\nNote that time_t is __kernel_time_t and time_t is long; the LP64 data model is used, so sizeof(long) is 8 (64 bits).\nWhich results in: TIME_T_MAX = 9223372036854775807.\nThat is: sleep infinite results in an actual sleep time of 9223372036854775807 seconds (10^11 years). And for 32-bit linux systems (sizeof(long) is 4 (32 bits)): 2147483647 seconds (68 years; see also year 2038 problem).\n\nEdit: apparently the nanoseconds function called is not directly the syscall, but an OS-dependent wrapper (also defined in gnulib).\nThere's an extra step as a result: for some systems where HAVE_BUG_BIG_NANOSLEEP is true the sleep is truncated to 24 days and then called in a loop. This is the case for some (or all?) Linux distros. Note that this wrapper may be not used if a configure-time test succeeds (source).\nIn particular, that would be 24 * 24 * 60 * 60 = 2073600 seconds (plus 999999999 nanoseconds); but this is called in a loop in order to respect the specified total sleep time. Therefore the previous conclusions remain valid.\n\nIn conclusion, the resulting sleep time is not infinite but high enough for all practical purposes, even if the resulting actual time lapse is not portable; that depends on the OS and architecture.\nTo answer the original question, this is obviously good enough but if for some reason (a very resource-constrained system) you really want to avoid an useless extra countdown timer, I guess the most correct alternative is to use the cat method described in other answers.\nEdit: recent GNU coreutils versions will try to use the pause syscall (if available) instead of looping. The previous argument is no longer valid when targeting these newer versions in Linux (and possibly BSD).\n\nPortability\nThis is an important and valid concern:\n\nsleep infinity is a GNU coreutils extension not contemplated in POSIX. GNU's implementation also supports a \"fancy\" syntax for time durations, like sleep 1h 5.2s while POSIX only allows a positive integer (e.g. sleep 0.5 is not allowed).\nSome compatible implementations: GNU coreutils, FreeBSD (at least from version 8.2?), Busybox (requires to be compiled with options FANCY_SLEEP and FLOAT_DURATION).\nThe strtod behaviour is C and POSIX compatible (i.e. strtod(\"infinity\", 0) is always valid in C99-conformant implementations, see \u00a77.20.1.3).\n\n\n", "\nsleep infinity looks most elegant, but sometimes it doesn't work for some reason. In that case, you can try other blocking commands such as cat, read, tail -f /dev/null, grep a etc.\n", "\nLet me explain why sleep infinity works though it is not documented. jp48's answer is also useful.\nThe most important thing: By specifying inf or infinity (both case-insensitive), you can sleep for the longest time your implementation permits (i.e. the smaller value of HUGE_VAL and TYPE_MAXIMUM(time_t)).\nNow let's dig into the details. The source code of sleep command can be read from coreutils/src/sleep.c. Essentially, the function does this:\ndouble s; //seconds\nxstrtod (argv[i], &p, &s, cl_strtod); //`p` is not essential (just used for error check).\nxnanosleep (s);\n\nUnderstanding xstrtod (argv[i], &p, &s, cl_strtod)\nxstrtod()\nAccording to gnulib/lib/xstrtod.c, the call of xstrtod() converts string argv[i] to a floating point value and stores it to *s, using a converting function cl_strtod().\ncl_strtod()\nAs can be seen from coreutils/lib/cl-strtod.c, cl_strtod() converts a string to a floating point value, using strtod().\nstrtod()\nAccording to man 3 strtod, strtod() converts a string to a value of type double. The manpage says\n\nThe  expected  form  of the (initial portion of the) string is ... or (iii) an infinity, or ...\n\nand an infinity is defined as \n\nAn infinity is either \"INF\" or \"INFINITY\", disregarding case.\n\nAlthough the document tells\n\nIf the correct value would cause overflow, plus or minus HUGE_VAL (HUGE_VALF, HUGE_VALL) is returned\n\n, it is not clear how an infinity is treated. So let's see the source code gnulib/lib/strtod.c. What we want to read is\nelse if (c_tolower (*s) == 'i'\n         && c_tolower (s[1]) == 'n'\n         && c_tolower (s[2]) == 'f')\n  {\n    s += 3;\n    if (c_tolower (*s) == 'i'\n        && c_tolower (s[1]) == 'n'\n        && c_tolower (s[2]) == 'i'\n        && c_tolower (s[3]) == 't'\n        && c_tolower (s[4]) == 'y')\n      s += 5;\n    num = HUGE_VAL;\n    errno = saved_errno;\n  }\n\nThus, INF and INFINITY (both case-insensitive) are regarded as HUGE_VAL.\nHUGE_VAL family\nLet's use N1570 as the C standard. HUGE_VAL, HUGE_VALF and HUGE_VALL macros are defined in \u00a77.12-3\n\nThe macro\n  \u00a0\u00a0\u00a0\u00a0HUGE_VAL\n  expands to a positive double constant expression, not necessarily representable as a float. The macros\n  \u00a0\u00a0\u00a0\u00a0HUGE_VALF\n  \u00a0\u00a0\u00a0\u00a0HUGE_VALL\n  are respectively float and long double analogs of HUGE_VAL.\n\nHUGE_VAL, HUGE_VALF, and HUGE_VALL can be positive infinities in an implementation that supports infinities.\n\nand in \u00a77.12.1-5\n\nIf a floating result overflows and default rounding is in effect, then the function returns the value of the macro HUGE_VAL, HUGE_VALF, or HUGE_VALL according to the return type\n\nUnderstanding xnanosleep (s)\nNow we understand all essence of xstrtod(). From the explanations above, it is crystal-clear that xnanosleep(s) we've seen first actually means xnanosleep(HUGE_VALL).\nxnanosleep()\nAccording to the source code gnulib/lib/xnanosleep.c, xnanosleep(s) essentially does this:\nstruct timespec ts_sleep = dtotimespec (s);\nnanosleep (&ts_sleep, NULL);\n\ndtotimespec()\nThis function converts an argument of type double to an object of type struct timespec. Since it is very simple, let me cite the source code gnulib/lib/dtotimespec.c. All of the comments are added by me.\nstruct timespec\ndtotimespec (double sec)\n{\n  if (! (TYPE_MINIMUM (time_t) < sec)) //underflow case\n    return make_timespec (TYPE_MINIMUM (time_t), 0);\n  else if (! (sec < 1.0 + TYPE_MAXIMUM (time_t))) //overflow case\n    return make_timespec (TYPE_MAXIMUM (time_t), TIMESPEC_HZ - 1);\n  else //normal case (looks complex but does nothing technical)\n    {\n      time_t s = sec;\n      double frac = TIMESPEC_HZ * (sec - s);\n      long ns = frac;\n      ns += ns < frac;\n      s += ns / TIMESPEC_HZ;\n      ns %= TIMESPEC_HZ;\n\n      if (ns < 0)\n        {\n          s--;\n          ns += TIMESPEC_HZ;\n        }\n\n      return make_timespec (s, ns);\n    }\n}\n\nSince time_t is defined as an integral type (see \u00a77.27.1-3), it is natural we assume the maximum value of type time_t is smaller than HUGE_VAL (of type double), which means we enter the overflow case. (Actually this assumption is not needed since, in all cases, the procedure is essentially the same.)\nmake_timespec()\nThe last wall we have to climb up is make_timespec(). Very fortunately, it is so simple that citing the source code gnulib/lib/timespec.h is enough.\n_GL_TIMESPEC_INLINE struct timespec\nmake_timespec (time_t s, long int ns)\n{\n  struct timespec r;\n  r.tv_sec = s;\n  r.tv_nsec = ns;\n  return r;\n}\n\n", "\nWhat about sending a SIGSTOP to itself?\nThis should pause the process until SIGCONT is received. Which is in your case: never.\nkill -STOP \"$$\";\n# grace time for signal delivery\nsleep 60;\n\n", "\nI recently had a need to do this. I came up with the following function that will allow bash to sleep forever without calling any external program:\nsnore()\n{\n    local IFS\n    [[ -n \"${_snore_fd:-}\" ]] || { exec {_snore_fd}<> <(:); } 2>/dev/null ||\n    {\n        # workaround for MacOS and similar systems\n        local fifo\n        fifo=$(mktemp -u)\n        mkfifo -m 700 \"$fifo\"\n        exec {_snore_fd}<>\"$fifo\"\n        rm \"$fifo\"\n    }\n    read ${1:+-t \"$1\"} -u $_snore_fd || :\n}\n\nNOTE: I previously posted a version of this that would open and close the file descriptor each time, but I found that on some systems doing this hundreds of times a second would eventually lock up. Thus the new solution keeps the file descriptor between calls to the function. Bash will clean it up on exit anyway.\nThis can be called just like /bin/sleep, and it will sleep for the requested time. Called without parameters, it will hang forever.\nsnore 0.1  # sleeps for 0.1 seconds\nsnore 10   # sleeps for 10 seconds\nsnore      # sleeps forever\n\nThere's a writeup with excessive details on my blog here\n", "\nThis approach will not consume any resources for keeping process alive.\nwhile :; do :; done & kill -STOP $! && wait\n\nBreakdown\n\nwhile :; do :; done & Creates a dummy process in background\nkill -STOP $! Stops the background process\nwait Wait for the background process, this will be blocking forever, cause background process was stopped before\n\nNotes\n\nworks only from within a script file.\n\n", "\nInstead of killing the window manager, try running the new one with --replace or -replace if available.\n", "\nsleep inf can save you some typing, it's the same as sleep infinity\n", "\nNote that there is no standard C API for milliseconds, so (on Unix) you will have to settle for usleep, which accepts microseconds:\n#include <unistd.h>\n\nunsigned int microseconds;\n...\nusleep(microseconds);\n\n", "\nIn C++11, you can do this with standard library facilities:\n#include <chrono>\n#include <thread>\n\nstd::this_thread::sleep_for(std::chrono::milliseconds(x));\n\nClear and readable, no more need to guess at what units the sleep() function takes.\n", "\nTo stay portable you could use Boost::Thread for sleeping:\n#include <boost/thread/thread.hpp>\n\nint main()\n{\n    //waits 2 seconds\n    boost::this_thread::sleep( boost::posix_time::seconds(1) );\n    boost::this_thread::sleep( boost::posix_time::milliseconds(1000) );\n\n    return 0;\n}\n\nThis answer is a duplicate and has been posted in this question before. Perhaps you could find some usable answers there too.\n", "\nIn Unix you can use usleep.\nIn Windows there is Sleep.\n", "\nFrom C++14 using std and also its numeric literals:\n#include <chrono>\n#include <thread>\n\nusing namespace std::chrono_literals;\n\nstd::this_thread::sleep_for(123ms);\n\n", "\nDepending on your platform you may have usleep or nanosleep available. usleep is deprecated and has been deleted from the most recent POSIX standard; nanosleep is preferred.\n", "\nWhy don't use time.h library? Runs on Windows and POSIX systems (don't use this code in production!):\nCPU stays in IDLE state:\n#include <iostream>\n#ifdef _WIN32\n    #include <windows.h>\n#else\n    #include <unistd.h>\n#endif // _WIN32\n\nusing namespace std;\n\nvoid sleepcp(int milliseconds);\n\nvoid sleepcp(int milliseconds) // Cross-platform sleep function\n{\n    #ifdef _WIN32\n        Sleep(milliseconds);\n    #else\n        usleep(milliseconds * 1000);\n    #endif // _WIN32\n}\nint main()\n{\n    cout << \"Hi! At the count to 3, I'll die! :)\" << endl;\n    sleepcp(3000);\n    cout << \"urrrrggghhhh!\" << endl;\n}\n\n", "\nnanosleep is a better choice than usleep - it is more resilient against interrupts.\n", "\n#include <windows.h>\n\nSyntax: \nSleep (  __in DWORD dwMilliseconds   );\n\nUsage: \nSleep (1000); //Sleeps for 1000 ms or 1 sec\n\n", "\nIf using MS Visual C++ 10.0, you can do this with standard library facilities:\nConcurrency::wait(milliseconds);\n\nyou will need:\n#include <concrt.h>\n\n", "\nOn platforms with the select function (POSIX, Linux, and Windows) you could do:\nvoid sleep(unsigned long msec) {\n    timeval delay = {msec / 1000, msec % 1000 * 1000};\n    int rc = ::select(0, NULL, NULL, NULL, &delay);\n    if(-1 == rc) {\n        // Handle signals by continuing to sleep or return immediately.\n    }\n}\n\nHowever, there are better alternatives available nowadays.\n", "\nSelect call is a way of having more precision (sleep time can be specified in nanoseconds).\n", "\nThe way to sleep your program in C++ is the Sleep(int) method. The header file for it is #include \"windows.h.\"\nFor example:\n#include \"stdafx.h\"\n#include \"windows.h\"\n#include \"iostream\"\nusing namespace std;\n\nint main()\n{\n    int x = 6000;\n    Sleep(x);\n    cout << \"6 seconds have passed\" << endl;\n    return 0;\n}\n\nThe time it sleeps is measured in milliseconds and has no limit.\nSecond = 1000 milliseconds\nMinute = 60000 milliseconds\nHour = 3600000 milliseconds\n\n", "\nUse Boost asynchronous input/output threads, sleep for x milliseconds;\n#include <boost/thread.hpp>\n#include <boost/asio.hpp>\n\nboost::thread::sleep(boost::get_system_time() + boost::posix_time::millisec(1000));\n\n", "\nElegant solution from the one answer, bit modified.. One can easilly add select() usage if there's no better functionality available. Just make function that uses select() etc. ..\nCode:\n\n#include <iostream>\n\n/*\n Prepare defines for millisecond sleep function that is cross-platform\n*/\n#ifdef _WIN32\n#  include <Windows.h>\n#  define sleep_function_name           Sleep\n#  define sleep_time_multiplier_for_ms      1\n#else\n#  include <unistd.h>\n#  define sleep_function_name           usleep\n#  define sleep_time_multiplier_for_ms      1000\n#endif\n\n/* Cross platform millisecond sleep */\nvoid cross_platform_sleep_ms(unsigned long int time_to_sleep_in_ms)\n{\n   sleep_function_name ( sleep_time_multiplier_for_ms * time_to_sleep_in_ms );\n}\n\n\n", "\nAs a Win32 replacement for POSIX systems:\nvoid Sleep(unsigned int milliseconds) {\n    usleep(milliseconds * 1000);\n}\n\nwhile (1) {\n    printf(\".\");\n    Sleep((unsigned int)(1000.0f/20.0f)); // 20 fps\n}\n\n", "\nThe question is old, but I managed to figure out a simple way to have this in my app. You can create a C/C++ macro as shown below use it:\n#ifndef MACROS_H\n#define MACROS_H\n\n#include <unistd.h>\n\n#define msleep(X) usleep(X * 1000)\n\n#endif // MACROS_H\n\n", "\nA process will sleep until an interrupt is sent. This may be from a software signal or some hardware via the o/s.\n", "\nAs mentioned by @VGR, try using redirectOutput\npublic static void Linux(String fileName){\n\ntry {\n   File dir = new File(\"/usr/local/bin\");\n   ProcessBuilder pb = new ProcessBuilder(new String[]{\"/bin/bash\", \"-c\", \"./test_elanprv2.2.sh\");\n   File output = new File(\"_\", fileName + \".txt\");\n   pb.redirectOutput(output);\n   System.out.println(\"wrote text\");\n   pb.directory(dir);\n   Process start = pb.start();\n   start.destroy();\n} catch (Exception e) {\n   e.printStackTrace();\n   System.out.println(\"failed to write text\");\n}\n\n", "\nA shared memory region is good for sharing a lot of data, but it is a bad way to communicate between processes. The reason is that you can't get a notification that something has been changed, nor do you get a notification if the other user of the shared memory died.\nTo communicate between two processes, use pipe() if you need to create a one-way communication channel, or if you need bidirectional communication, use socketpair(). You can use poll() to wait for the other side to send some data. You will also get notified if the process on the other side terminated.\nYou were using a loop like this:\nwhile(child_file[0]=='W' ){  //Child waits\n    usleep(100000);\n}\n\nThis is bad, since you are wasting on average 50 ms of time that you could have spent doing something useful. Apart from that, there is also the problem that both the compiler and the CPU can sometimes change the order in which things are written to memory. If you have more data in child_file than just the flag at the start, then this might be an issue, unless you use atomics or explicit barriers.\n", "\nI added some signal handling to OP's answer, so here it is:\n#!/bin/sh\nmy_mouse_device_id=12\n\ndisable_mouse_for_a_second()\n{\n    if xinput --disable \"$1\" 2> /dev/null\n    then\n        (\n            # ensure the device will not be left disabled\n            id=$1\n            trap 'xinput --enable \"$id\"; trap - EXIT; exit' \\\n            EXIT TERM INT HUP\n            sleep 1s\n        ) &\n        return 0\n    else\n        return 1\n    fi\n}\n\n# example usage\nif disable_mouse_for_a_second \"$my_mouse_device_id\"\nthen\n    echo \"Success\"\nelse\n    echo \"Failure\"\nfi\n\nNote that { ... } seem to work as replacements of ( ... ) here, if you prefer, but there will be a sub-shell anyway.\nYou have to store $1 in a variable (here id) because otherwise at least Dash shell would not know it on EXIT.\nI refer to this answer on signal hadling.\n"], "rejected": ["\nwhile :; do read; done\n\nno waiting for child sleeping process.\n", "\nwhile :; do read; done\n\nno waiting for child sleeping process.\n", "\nwhile :; do read; done\n\nno waiting for child sleeping process.\n", "\nwhile :; do read; done\n\nno waiting for child sleeping process.\n", "\nwhile :; do read; done\n\nno waiting for child sleeping process.\n", "\nwhile :; do read; done\n\nno waiting for child sleeping process.\n", "\nwhile :; do read; done\n\nno waiting for child sleeping process.\n", "\nwhile :; do read; done\n\nno waiting for child sleeping process.\n", "\nwhile :; do read; done\n\nno waiting for child sleeping process.\n", "\nwhile :; do read; done\n\nno waiting for child sleeping process.\n", "\nwhile :; do read; done\n\nno waiting for child sleeping process.\n", "\nI use this:\n#include <thread>\n#define sleepms(val) std::this_thread::sleep_for(val##ms)\n\nexample:\nsleepms(200);\n\n", "\nI use this:\n#include <thread>\n#define sleepms(val) std::this_thread::sleep_for(val##ms)\n\nexample:\nsleepms(200);\n\n", "\nI use this:\n#include <thread>\n#define sleepms(val) std::this_thread::sleep_for(val##ms)\n\nexample:\nsleepms(200);\n\n", "\nI use this:\n#include <thread>\n#define sleepms(val) std::this_thread::sleep_for(val##ms)\n\nexample:\nsleepms(200);\n\n", "\nI use this:\n#include <thread>\n#define sleepms(val) std::this_thread::sleep_for(val##ms)\n\nexample:\nsleepms(200);\n\n", "\nI use this:\n#include <thread>\n#define sleepms(val) std::this_thread::sleep_for(val##ms)\n\nexample:\nsleepms(200);\n\n", "\nI use this:\n#include <thread>\n#define sleepms(val) std::this_thread::sleep_for(val##ms)\n\nexample:\nsleepms(200);\n\n", "\nI use this:\n#include <thread>\n#define sleepms(val) std::this_thread::sleep_for(val##ms)\n\nexample:\nsleepms(200);\n\n", "\nI use this:\n#include <thread>\n#define sleepms(val) std::this_thread::sleep_for(val##ms)\n\nexample:\nsleepms(200);\n\n", "\nI use this:\n#include <thread>\n#define sleepms(val) std::this_thread::sleep_for(val##ms)\n\nexample:\nsleepms(200);\n\n", "\nI use this:\n#include <thread>\n#define sleepms(val) std::this_thread::sleep_for(val##ms)\n\nexample:\nsleepms(200);\n\n", "\nI use this:\n#include <thread>\n#define sleepms(val) std::this_thread::sleep_for(val##ms)\n\nexample:\nsleepms(200);\n\n", "\nI use this:\n#include <thread>\n#define sleepms(val) std::this_thread::sleep_for(val##ms)\n\nexample:\nsleepms(200);\n\n", "\nI use this:\n#include <thread>\n#define sleepms(val) std::this_thread::sleep_for(val##ms)\n\nexample:\nsleepms(200);\n\n", "\nI use this:\n#include <thread>\n#define sleepms(val) std::this_thread::sleep_for(val##ms)\n\nexample:\nsleepms(200);\n\n", "\nI use this:\n#include <thread>\n#define sleepms(val) std::this_thread::sleep_for(val##ms)\n\nexample:\nsleepms(200);\n\n", "\nI use this:\n#include <thread>\n#define sleepms(val) std::this_thread::sleep_for(val##ms)\n\nexample:\nsleepms(200);\n\n", "\nDepending on what you are trying to achieve, looking at this from the operating level might be an overkill. Instead consider solving it within your code, by splitting your sleep in multiple sleep statements and giving a update that way.\n    from time import sleep\n\n    for i in range(0,60):\n        sleep(1)\n        # Give an update status via i\n        print(f\"I've slept {i} seconds\")\n\nReplace the print with something that gives an update to the OS, parses a value to a different programm etc, depending on your needs. This would be easier than trying to figure this out on an OS level.\n", "\nMost of your issues are due to a misunderstanding of how processes work.  These concepts are not Java concepts;  you would have the same issues in any other language.\nFirst, you are destroying your process before it runs, and possibly before it even gets started.  This is because pb.start() starts the process, and then you immediately destroy it without giving it a chance to complete.\nYou shouldn\u2019t need to destroy the process at all.  Just let it finish:\nProcess start = pb.start();\nstart.waitFor();\n\nAll processes have their own standard input and standard output.  Again, this is not a Java concept;  this has been a fundamental feature in Unix and Windows operating systems for a long time.\nNormally, when a process prints information by writing it to its standard output.  That is in fact what Java\u2019s System.out.println does.  In Unix shells (and in Windows), the > character redirects the standard output of a process to a file;  the program still writes to its standard output, without ever knowing that the operating system is sending that output to a destination other than the terminal.  Since it\u2019s a fundamental operating system function, Java can do it for you:\nProcessBuilder pb =\n    new ProcessBuilder(\"/bin/bash\", \"-c\", \"./test_elanprv2.2.sh\");\npb.redirectOutput(new File(fileName + \".txt\"));\n\nSimilarly, when a process wants to take input, it normally does so by reading from its standard input.  This is not the same as executing another command.  When you do this:\n./test_elanprv2.2.sh > \"$1\"; sleep 1; q\n\nYou are not sending q to the shell script.  The above commands wait for the shell script to finish, then execute a sleep, then try to execute a program named q (which probably doesn\u2019t exist).\nSince the test_elanprv2.2.sh shell script probably accepts commands by reading its standard input, you want to send the q command to the standard input of that process:\nProcessBuilder pb =\n    new ProcessBuilder(\"/bin/bash\", \"-c\", \"./test_elanprv2.2.sh\");\npb.redirectOutput(new File(fileName + \".txt\"));\n\nProcess start = pb.start();\nThread.sleep(1000);\n\ntry (Writer commands = new OutputStreamWriter(start.getOutputStream())) {\n    commands.write(\"q\\n\");\n}\n\n// Caution: Call this AFTER writing commands.  You don't want to write\n// to the standard input of a process that has already finished!\nstart.waitFor();\n\n", "\n\nThe problem is that the child process seems to get stuck in the sleep while loop, even when the parent process has set the status to 'K' (checked in the file that is memory mapped).\n\nThere are several odd things about your program, with one of them being that you are using shared memory for this task at all.  See below for a better approach.\nIssues with the current approach\nAs to the question as it stands, however, you have a synchronization problem.  The contents of the mapped memory are being changed outside the scope of the child process, but you've given it no reason to suspect that that might be the case.  The compiler can therefore assume that if the wait loop condition is satisfied when it is first evaluated, then it will be satisfied on every subsequent evaluation, too.\nFor a more complicated interaction, you might need to set up a process-shared mutex or similar to guard access to the shared memory, but for this, it would probably be sufficient to declare child_file as a pointer to volatile char.\nA better approach\nYou want the child to wait for a one- or maybe two-byte instruction from the parent.  You presently do this by polling the contents of a shared memory segment, but that's complex to set up and use, as you discovered.  It would be a lot easier to use a pipe to convey the needed information from parent to child:\n\nsetup: Declare an array. Call pipe().\nchild use: The child performs a blocking read() on the pipe.\nparent use: write() the message to the pipe when ready, then close it.  Or just close it.\n\nNote that the pipe itself then provides adequate synchronization, and that there is no need for a wait loop.  Note also that the child can detect the case that the parent dies without sending any message, which your shared memory approach does not support.\n", "\nTL;DR\nSuppose, that on my system, the mouse device ID equals 12. Then a function doing the trick would appear as follows in a POSIX shell script:\nmy_mouse_device_id=12\n\ndisable_mouse_for_a_second()\n{\n    if xinput --disable \"$1\" 2> /dev/null\n    then\n        (\n            sleep 1s\n            xinput --enable \"$1\"\n        ) &\n        return 0\n    else\n        return 1\n    fi\n}\n\n# example usage\nif disable_mouse_for_a_second \"$my_mouse_device_id\"\nthen\n    echo \"Success\"\nelse\n    echo \"Failure\"\nfi\n\n\nLong story\n\nYou need to find the mouse device ID using:\nxinput list --short\n\nThis thread helped me a lot, for instance in that the following is deprecated:\nxinput --set-int-prop \n\nWe need to run these two commands afterward:\n\nsleep 1s\nxinput --enable \"$my_mouse_device_id\"\n\n\nthe tricky part is that we need:\n\na subshell ( ... )\na background job &\n\nfor that to work properly.\nFrom the practical standpoint, all we need to do is to wrap it up in one nice function.\n\n"]}