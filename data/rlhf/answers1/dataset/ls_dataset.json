{"prompt": ["I am writing a shell script that takes file paths as input.For this reason, I need to generate recursive file listings with full paths. For example, the file bar has the path:/home/ken/foo/bar\nbut, as far as I can see, both ls and find only give relative path listings:./foo/bar   (from the folder ken)\nIt seems like an obvious requirement, but I can't see anything in the find or ls man pages.How can I generate a list of files in the shell including their absolute paths?", "I am writing a shell script that takes file paths as input.For this reason, I need to generate recursive file listings with full paths. For example, the file bar has the path:/home/ken/foo/bar\nbut, as far as I can see, both ls and find only give relative path listings:./foo/bar   (from the folder ken)\nIt seems like an obvious requirement, but I can't see anything in the find or ls man pages.How can I generate a list of files in the shell including their absolute paths?", "I am writing a shell script that takes file paths as input.For this reason, I need to generate recursive file listings with full paths. For example, the file bar has the path:/home/ken/foo/bar\nbut, as far as I can see, both ls and find only give relative path listings:./foo/bar   (from the folder ken)\nIt seems like an obvious requirement, but I can't see anything in the find or ls man pages.How can I generate a list of files in the shell including their absolute paths?", "I am writing a shell script that takes file paths as input.For this reason, I need to generate recursive file listings with full paths. For example, the file bar has the path:/home/ken/foo/bar\nbut, as far as I can see, both ls and find only give relative path listings:./foo/bar   (from the folder ken)\nIt seems like an obvious requirement, but I can't see anything in the find or ls man pages.How can I generate a list of files in the shell including their absolute paths?", "I am writing a shell script that takes file paths as input.For this reason, I need to generate recursive file listings with full paths. For example, the file bar has the path:/home/ken/foo/bar\nbut, as far as I can see, both ls and find only give relative path listings:./foo/bar   (from the folder ken)\nIt seems like an obvious requirement, but I can't see anything in the find or ls man pages.How can I generate a list of files in the shell including their absolute paths?", "I am writing a shell script that takes file paths as input.For this reason, I need to generate recursive file listings with full paths. For example, the file bar has the path:/home/ken/foo/bar\nbut, as far as I can see, both ls and find only give relative path listings:./foo/bar   (from the folder ken)\nIt seems like an obvious requirement, but I can't see anything in the find or ls man pages.How can I generate a list of files in the shell including their absolute paths?", "I am writing a shell script that takes file paths as input.For this reason, I need to generate recursive file listings with full paths. For example, the file bar has the path:/home/ken/foo/bar\nbut, as far as I can see, both ls and find only give relative path listings:./foo/bar   (from the folder ken)\nIt seems like an obvious requirement, but I can't see anything in the find or ls man pages.How can I generate a list of files in the shell including their absolute paths?", "I am writing a shell script that takes file paths as input.For this reason, I need to generate recursive file listings with full paths. For example, the file bar has the path:/home/ken/foo/bar\nbut, as far as I can see, both ls and find only give relative path listings:./foo/bar   (from the folder ken)\nIt seems like an obvious requirement, but I can't see anything in the find or ls man pages.How can I generate a list of files in the shell including their absolute paths?", "I am writing a shell script that takes file paths as input.For this reason, I need to generate recursive file listings with full paths. For example, the file bar has the path:/home/ken/foo/bar\nbut, as far as I can see, both ls and find only give relative path listings:./foo/bar   (from the folder ken)\nIt seems like an obvious requirement, but I can't see anything in the find or ls man pages.How can I generate a list of files in the shell including their absolute paths?", "I am writing a shell script that takes file paths as input.For this reason, I need to generate recursive file listings with full paths. For example, the file bar has the path:/home/ken/foo/bar\nbut, as far as I can see, both ls and find only give relative path listings:./foo/bar   (from the folder ken)\nIt seems like an obvious requirement, but I can't see anything in the find or ls man pages.How can I generate a list of files in the shell including their absolute paths?", "I am writing a shell script that takes file paths as input.For this reason, I need to generate recursive file listings with full paths. For example, the file bar has the path:/home/ken/foo/bar\nbut, as far as I can see, both ls and find only give relative path listings:./foo/bar   (from the folder ken)\nIt seems like an obvious requirement, but I can't see anything in the find or ls man pages.How can I generate a list of files in the shell including their absolute paths?", "I am writing a shell script that takes file paths as input.For this reason, I need to generate recursive file listings with full paths. For example, the file bar has the path:/home/ken/foo/bar\nbut, as far as I can see, both ls and find only give relative path listings:./foo/bar   (from the folder ken)\nIt seems like an obvious requirement, but I can't see anything in the find or ls man pages.How can I generate a list of files in the shell including their absolute paths?", "I am writing a shell script that takes file paths as input.For this reason, I need to generate recursive file listings with full paths. For example, the file bar has the path:/home/ken/foo/bar\nbut, as far as I can see, both ls and find only give relative path listings:./foo/bar   (from the folder ken)\nIt seems like an obvious requirement, but I can't see anything in the find or ls man pages.How can I generate a list of files in the shell including their absolute paths?", "I am writing a shell script that takes file paths as input.For this reason, I need to generate recursive file listings with full paths. For example, the file bar has the path:/home/ken/foo/bar\nbut, as far as I can see, both ls and find only give relative path listings:./foo/bar   (from the folder ken)\nIt seems like an obvious requirement, but I can't see anything in the find or ls man pages.How can I generate a list of files in the shell including their absolute paths?", "I am writing a shell script that takes file paths as input.For this reason, I need to generate recursive file listings with full paths. For example, the file bar has the path:/home/ken/foo/bar\nbut, as far as I can see, both ls and find only give relative path listings:./foo/bar   (from the folder ken)\nIt seems like an obvious requirement, but I can't see anything in the find or ls man pages.How can I generate a list of files in the shell including their absolute paths?", "I am writing a shell script that takes file paths as input.For this reason, I need to generate recursive file listings with full paths. For example, the file bar has the path:/home/ken/foo/bar\nbut, as far as I can see, both ls and find only give relative path listings:./foo/bar   (from the folder ken)\nIt seems like an obvious requirement, but I can't see anything in the find or ls man pages.How can I generate a list of files in the shell including their absolute paths?", "I am writing a shell script that takes file paths as input.For this reason, I need to generate recursive file listings with full paths. For example, the file bar has the path:/home/ken/foo/bar\nbut, as far as I can see, both ls and find only give relative path listings:./foo/bar   (from the folder ken)\nIt seems like an obvious requirement, but I can't see anything in the find or ls man pages.How can I generate a list of files in the shell including their absolute paths?", "I am writing a shell script that takes file paths as input.For this reason, I need to generate recursive file listings with full paths. For example, the file bar has the path:/home/ken/foo/bar\nbut, as far as I can see, both ls and find only give relative path listings:./foo/bar   (from the folder ken)\nIt seems like an obvious requirement, but I can't see anything in the find or ls man pages.How can I generate a list of files in the shell including their absolute paths?", "I am writing a shell script that takes file paths as input.For this reason, I need to generate recursive file listings with full paths. For example, the file bar has the path:/home/ken/foo/bar\nbut, as far as I can see, both ls and find only give relative path listings:./foo/bar   (from the folder ken)\nIt seems like an obvious requirement, but I can't see anything in the find or ls man pages.How can I generate a list of files in the shell including their absolute paths?", "I am writing a shell script that takes file paths as input.For this reason, I need to generate recursive file listings with full paths. For example, the file bar has the path:/home/ken/foo/bar\nbut, as far as I can see, both ls and find only give relative path listings:./foo/bar   (from the folder ken)\nIt seems like an obvious requirement, but I can't see anything in the find or ls man pages.How can I generate a list of files in the shell including their absolute paths?", "I am writing a shell script that takes file paths as input.For this reason, I need to generate recursive file listings with full paths. For example, the file bar has the path:/home/ken/foo/bar\nbut, as far as I can see, both ls and find only give relative path listings:./foo/bar   (from the folder ken)\nIt seems like an obvious requirement, but I can't see anything in the find or ls man pages.How can I generate a list of files in the shell including their absolute paths?", "I am writing a shell script that takes file paths as input.For this reason, I need to generate recursive file listings with full paths. For example, the file bar has the path:/home/ken/foo/bar\nbut, as far as I can see, both ls and find only give relative path listings:./foo/bar   (from the folder ken)\nIt seems like an obvious requirement, but I can't see anything in the find or ls man pages.How can I generate a list of files in the shell including their absolute paths?", "I am writing a shell script that takes file paths as input.For this reason, I need to generate recursive file listings with full paths. For example, the file bar has the path:/home/ken/foo/bar\nbut, as far as I can see, both ls and find only give relative path listings:./foo/bar   (from the folder ken)\nIt seems like an obvious requirement, but I can't see anything in the find or ls man pages.How can I generate a list of files in the shell including their absolute paths?", "I am writing a shell script that takes file paths as input.For this reason, I need to generate recursive file listings with full paths. For example, the file bar has the path:/home/ken/foo/bar\nbut, as far as I can see, both ls and find only give relative path listings:./foo/bar   (from the folder ken)\nIt seems like an obvious requirement, but I can't see anything in the find or ls man pages.How can I generate a list of files in the shell including their absolute paths?", "I am writing a shell script that takes file paths as input.For this reason, I need to generate recursive file listings with full paths. For example, the file bar has the path:/home/ken/foo/bar\nbut, as far as I can see, both ls and find only give relative path listings:./foo/bar   (from the folder ken)\nIt seems like an obvious requirement, but I can't see anything in the find or ls man pages.How can I generate a list of files in the shell including their absolute paths?", "I am writing a shell script that takes file paths as input.For this reason, I need to generate recursive file listings with full paths. For example, the file bar has the path:/home/ken/foo/bar\nbut, as far as I can see, both ls and find only give relative path listings:./foo/bar   (from the folder ken)\nIt seems like an obvious requirement, but I can't see anything in the find or ls man pages.How can I generate a list of files in the shell including their absolute paths?", "I am writing a shell script that takes file paths as input.For this reason, I need to generate recursive file listings with full paths. For example, the file bar has the path:/home/ken/foo/bar\nbut, as far as I can see, both ls and find only give relative path listings:./foo/bar   (from the folder ken)\nIt seems like an obvious requirement, but I can't see anything in the find or ls man pages.How can I generate a list of files in the shell including their absolute paths?", "I am writing a shell script that takes file paths as input.For this reason, I need to generate recursive file listings with full paths. For example, the file bar has the path:/home/ken/foo/bar\nbut, as far as I can see, both ls and find only give relative path listings:./foo/bar   (from the folder ken)\nIt seems like an obvious requirement, but I can't see anything in the find or ls man pages.How can I generate a list of files in the shell including their absolute paths?", "Using an ls \u2013a and grep, how would you list the name of all of the files in /usr starting with the letter p or the letter r or the letter s using a single grep command? would this be right?ls \u2013a | grep [prs] /usr\n", "Using an ls \u2013a and grep, how would you list the name of all of the files in /usr starting with the letter p or the letter r or the letter s using a single grep command? would this be right?ls \u2013a | grep [prs] /usr\n", "Using an ls \u2013a and grep, how would you list the name of all of the files in /usr starting with the letter p or the letter r or the letter s using a single grep command? would this be right?ls \u2013a | grep [prs] /usr\n", "Using an ls \u2013a and grep, how would you list the name of all of the files in /usr starting with the letter p or the letter r or the letter s using a single grep command? would this be right?ls \u2013a | grep [prs] /usr\n", "Using an ls \u2013a and grep, how would you list the name of all of the files in /usr starting with the letter p or the letter r or the letter s using a single grep command? would this be right?ls \u2013a | grep [prs] /usr\n", "I am new to linux. I have a directory in linux with approx 250,000 files\nI need to find count of number of files matching a pattern.I tried using following command :ls -1 20061101-20131101_kh5x7tte9n_2010_* | wc -l\nI got the following error message:-bash: /bin/ls: Argument list too long\n0\nPlease help. Thanks in advance", "I am new to linux. I have a directory in linux with approx 250,000 files\nI need to find count of number of files matching a pattern.I tried using following command :ls -1 20061101-20131101_kh5x7tte9n_2010_* | wc -l\nI got the following error message:-bash: /bin/ls: Argument list too long\n0\nPlease help. Thanks in advance", "I am new to linux. I have a directory in linux with approx 250,000 files\nI need to find count of number of files matching a pattern.I tried using following command :ls -1 20061101-20131101_kh5x7tte9n_2010_* | wc -l\nI got the following error message:-bash: /bin/ls: Argument list too long\n0\nPlease help. Thanks in advance", "I am new to linux. I have a directory in linux with approx 250,000 files\nI need to find count of number of files matching a pattern.I tried using following command :ls -1 20061101-20131101_kh5x7tte9n_2010_* | wc -l\nI got the following error message:-bash: /bin/ls: Argument list too long\n0\nPlease help. Thanks in advance", "I am new to linux. I have a directory in linux with approx 250,000 files\nI need to find count of number of files matching a pattern.I tried using following command :ls -1 20061101-20131101_kh5x7tte9n_2010_* | wc -l\nI got the following error message:-bash: /bin/ls: Argument list too long\n0\nPlease help. Thanks in advance", "I am new to linux. I have a directory in linux with approx 250,000 files\nI need to find count of number of files matching a pattern.I tried using following command :ls -1 20061101-20131101_kh5x7tte9n_2010_* | wc -l\nI got the following error message:-bash: /bin/ls: Argument list too long\n0\nPlease help. Thanks in advance", "I am new to linux. I have a directory in linux with approx 250,000 files\nI need to find count of number of files matching a pattern.I tried using following command :ls -1 20061101-20131101_kh5x7tte9n_2010_* | wc -l\nI got the following error message:-bash: /bin/ls: Argument list too long\n0\nPlease help. Thanks in advance", "Question: How do you delete all files in a directory except the newest 3?Finding the newest 3 files is simple:ls -t | head -3\nBut I need to find all files except the newest 3 files. How do I do that, and how do I delete these files in the same line without making an unnecessary for loop for that?I'm using Debian Wheezy and bash scripts for this.", "Question: How do you delete all files in a directory except the newest 3?Finding the newest 3 files is simple:ls -t | head -3\nBut I need to find all files except the newest 3 files. How do I do that, and how do I delete these files in the same line without making an unnecessary for loop for that?I'm using Debian Wheezy and bash scripts for this.", "Question: How do you delete all files in a directory except the newest 3?Finding the newest 3 files is simple:ls -t | head -3\nBut I need to find all files except the newest 3 files. How do I do that, and how do I delete these files in the same line without making an unnecessary for loop for that?I'm using Debian Wheezy and bash scripts for this.", "Question: How do you delete all files in a directory except the newest 3?Finding the newest 3 files is simple:ls -t | head -3\nBut I need to find all files except the newest 3 files. How do I do that, and how do I delete these files in the same line without making an unnecessary for loop for that?I'm using Debian Wheezy and bash scripts for this.", "Question: How do you delete all files in a directory except the newest 3?Finding the newest 3 files is simple:ls -t | head -3\nBut I need to find all files except the newest 3 files. How do I do that, and how do I delete these files in the same line without making an unnecessary for loop for that?I'm using Debian Wheezy and bash scripts for this.", "Question: How do you delete all files in a directory except the newest 3?Finding the newest 3 files is simple:ls -t | head -3\nBut I need to find all files except the newest 3 files. How do I do that, and how do I delete these files in the same line without making an unnecessary for loop for that?I'm using Debian Wheezy and bash scripts for this.", "Question: How do you delete all files in a directory except the newest 3?Finding the newest 3 files is simple:ls -t | head -3\nBut I need to find all files except the newest 3 files. How do I do that, and how do I delete these files in the same line without making an unnecessary for loop for that?I'm using Debian Wheezy and bash scripts for this.", "Question: How do you delete all files in a directory except the newest 3?Finding the newest 3 files is simple:ls -t | head -3\nBut I need to find all files except the newest 3 files. How do I do that, and how do I delete these files in the same line without making an unnecessary for loop for that?I'm using Debian Wheezy and bash scripts for this.", "Question: How do you delete all files in a directory except the newest 3?Finding the newest 3 files is simple:ls -t | head -3\nBut I need to find all files except the newest 3 files. How do I do that, and how do I delete these files in the same line without making an unnecessary for loop for that?I'm using Debian Wheezy and bash scripts for this.", "Question: How do you delete all files in a directory except the newest 3?Finding the newest 3 files is simple:ls -t | head -3\nBut I need to find all files except the newest 3 files. How do I do that, and how do I delete these files in the same line without making an unnecessary for loop for that?I'm using Debian Wheezy and bash scripts for this.", "this is a regular output an ll commanddrwxr-xr-x 2 something     root 4096 2008-11-04 16:58 something\nI would like to ask if this output is like this,crwxr-xr-x 2 something     root 4096 2008-11-04 16:58 something\nwhat does the \"c\" mean?", "When I am using wildcards with ls command, it works.$ ls '*.{mp3,ogg}'  # Showing only two formats in the command\ncannot access *.mp3: No such file or directory\n1.ogg 2.ogg 3.ogg\nbut using find command doesn't work$ find ~ -iname '*.{mp3,ogg}'\nWhat is the error in the line? ", "When I am using wildcards with ls command, it works.$ ls '*.{mp3,ogg}'  # Showing only two formats in the command\ncannot access *.mp3: No such file or directory\n1.ogg 2.ogg 3.ogg\nbut using find command doesn't work$ find ~ -iname '*.{mp3,ogg}'\nWhat is the error in the line? ", "When I am using wildcards with ls command, it works.$ ls '*.{mp3,ogg}'  # Showing only two formats in the command\ncannot access *.mp3: No such file or directory\n1.ogg 2.ogg 3.ogg\nbut using find command doesn't work$ find ~ -iname '*.{mp3,ogg}'\nWhat is the error in the line? ", "When I am using wildcards with ls command, it works.$ ls '*.{mp3,ogg}'  # Showing only two formats in the command\ncannot access *.mp3: No such file or directory\n1.ogg 2.ogg 3.ogg\nbut using find command doesn't work$ find ~ -iname '*.{mp3,ogg}'\nWhat is the error in the line? ", "When I am using wildcards with ls command, it works.$ ls '*.{mp3,ogg}'  # Showing only two formats in the command\ncannot access *.mp3: No such file or directory\n1.ogg 2.ogg 3.ogg\nbut using find command doesn't work$ find ~ -iname '*.{mp3,ogg}'\nWhat is the error in the line? ", "When I am using wildcards with ls command, it works.$ ls '*.{mp3,ogg}'  # Showing only two formats in the command\ncannot access *.mp3: No such file or directory\n1.ogg 2.ogg 3.ogg\nbut using find command doesn't work$ find ~ -iname '*.{mp3,ogg}'\nWhat is the error in the line? ", "i am currently trying to get wordpress running on Ubuntu Server 18.04 with apache. I managed to get everything to work, but for some reason i am not able to use ls -l properly anymore on the wordpress directories, in which i played around with permissions. The out-of-the-box permissions didn't allow me to update my themes from the wordpress webinterface.\nI can't find a solution to this problem, because the permissions are clearly stating, that i have at least read permission.Problem: ls -l shows question marks and sais permission denied.Infos: permissions are rwx for owner www-data, rw for group www-data and r for other. Output of groups includes www-data, so the user should be in the www-data group.Outputs:$ ls -l /usr/share/wordpress/\nls: cannot access '/usr/share/wordpress/readme.html': Permission denied\n...\nls: cannot access '/usr/share/wordpress/wp-comments-post.php': Permission denied\ntotal 0\n-????????? ? ? ? ?            ? index.php\n...\n-????????? ? ? ? ?            ? xmlrpc.php\n$ groups\n*censored user* adm cdrom sudo dip www-data plugdev lxd lpadmin\n$ sudo ls -l /usr/share/wordpress/\ntotal 172\n-rwxrw-r--  1 www-data www-data   418 Apr  6  2018 index.php\n-rwxrw-r--  1 www-data www-data  7440 Apr  8  2018 readme.html\n-rwxrw-r--  1 www-data www-data  5697 Apr  8  2018 wp-activate.php\ndrwxrw-r--  9 www-data www-data  4096 Jul 20 00:53 wp-admin\n...\n-rwxrw-r--  1 www-data www-data  3065 Apr  6  2018 xmlrpc.php\nP.S.: Any extra tips for wordpress security are useful.\nThanksedit forgot the permissions of the directory, still confusing.$ sudo ls -l -a /usr/share/wordpress/\ntotal 180\ndrwxrw-r--   5 www-data www-data  4096 Jul 20 17:13 .\ndrwxr-xr-x 162 root     root      4096 Jul 20 02:40 ..\n...\n", "I wanted to recursively search a directory for a particular file extension, and wanted the files to appear by timestamp (i.e. newest ones first). Ideally, I'd want something like:ls -R -lth *.txt\nbut this doesn't work, although parts of it work:ls -lth *.txt\nls -R -lth\nHow do I need to modify my 'ls' command?thanks!", "Can I use ls | grep -c /full/path/to/file to count the occurrences of a file, but while executing the command from a different directory than where the files I'm looking for are?Let's say I want to look how many .txt files I have in my \"results\" directory. Can I do something like ls | grep -c /full/path/to/results/*.txt while I'm in another directory?Although I have .txt files in that directory, I always get a zero when I run the command from another directory :( What's happening? Can I only use ls for the current directory?", "My objective is to find all files in a directory recursively and display only the file owner name so I'm able to use uniq to count the # of files a user owns in a directory. The command I am using is the following:command = \"find \" + subdirectory.directoryPath + \"/ -type f -exec ls -lh {} + | cut -f 3 -d' ' | sort | uniq -c | sort -n\"\nThis command successfully displays only the owner of the file of each line, and allows me to count of the # of times the owner names is repeated, hence getting the # of files they own in a subdirectory. Cut uses ' ' as a delimiter and only keeps the 3rd column in ls, which is the owner of the file.However, for my purpose there is this special edge case, where I'm not able to obtain the owner name if the following occurs.-rw-r-----  1             31122918 group 20169510233 Mar 17 06:02                                              \n-rw-r-----  1 user1                group 20165884490 Mar 25 11:11                                      \n-rw-r-----  1 user1                group 20201669165 Mar 31 04:17                                     \n-rwxr-x---  1 user3                group 20257297418 Jun  2 13:25             \n-rw-r-----  1 user2                group 20048291543 Mar  4 22:04                                          \n-rw-r-----  1             14235912 group 20398346003 Mar 10 04:47 \nThe special edge cases are the #s as the owner you see above. The current command Im using can detect user1,user2,and user3 perfectly, but because the numbers are placed all the way to the right, the command above doesn't detect the numbers, and simply displays nothing. Example output is shown here:1  \n1 user3\n1 user2\n1\n2 user1\nCan anyone help me parse the ls output so I'm able to detect these #'s when trying to only print the file owner column?", "My objective is to find all files in a directory recursively and display only the file owner name so I'm able to use uniq to count the # of files a user owns in a directory. The command I am using is the following:command = \"find \" + subdirectory.directoryPath + \"/ -type f -exec ls -lh {} + | cut -f 3 -d' ' | sort | uniq -c | sort -n\"\nThis command successfully displays only the owner of the file of each line, and allows me to count of the # of times the owner names is repeated, hence getting the # of files they own in a subdirectory. Cut uses ' ' as a delimiter and only keeps the 3rd column in ls, which is the owner of the file.However, for my purpose there is this special edge case, where I'm not able to obtain the owner name if the following occurs.-rw-r-----  1             31122918 group 20169510233 Mar 17 06:02                                              \n-rw-r-----  1 user1                group 20165884490 Mar 25 11:11                                      \n-rw-r-----  1 user1                group 20201669165 Mar 31 04:17                                     \n-rwxr-x---  1 user3                group 20257297418 Jun  2 13:25             \n-rw-r-----  1 user2                group 20048291543 Mar  4 22:04                                          \n-rw-r-----  1             14235912 group 20398346003 Mar 10 04:47 \nThe special edge cases are the #s as the owner you see above. The current command Im using can detect user1,user2,and user3 perfectly, but because the numbers are placed all the way to the right, the command above doesn't detect the numbers, and simply displays nothing. Example output is shown here:1  \n1 user3\n1 user2\n1\n2 user1\nCan anyone help me parse the ls output so I'm able to detect these #'s when trying to only print the file owner column?", "My objective is to find all files in a directory recursively and display only the file owner name so I'm able to use uniq to count the # of files a user owns in a directory. The command I am using is the following:command = \"find \" + subdirectory.directoryPath + \"/ -type f -exec ls -lh {} + | cut -f 3 -d' ' | sort | uniq -c | sort -n\"\nThis command successfully displays only the owner of the file of each line, and allows me to count of the # of times the owner names is repeated, hence getting the # of files they own in a subdirectory. Cut uses ' ' as a delimiter and only keeps the 3rd column in ls, which is the owner of the file.However, for my purpose there is this special edge case, where I'm not able to obtain the owner name if the following occurs.-rw-r-----  1             31122918 group 20169510233 Mar 17 06:02                                              \n-rw-r-----  1 user1                group 20165884490 Mar 25 11:11                                      \n-rw-r-----  1 user1                group 20201669165 Mar 31 04:17                                     \n-rwxr-x---  1 user3                group 20257297418 Jun  2 13:25             \n-rw-r-----  1 user2                group 20048291543 Mar  4 22:04                                          \n-rw-r-----  1             14235912 group 20398346003 Mar 10 04:47 \nThe special edge cases are the #s as the owner you see above. The current command Im using can detect user1,user2,and user3 perfectly, but because the numbers are placed all the way to the right, the command above doesn't detect the numbers, and simply displays nothing. Example output is shown here:1  \n1 user3\n1 user2\n1\n2 user1\nCan anyone help me parse the ls output so I'm able to detect these #'s when trying to only print the file owner column?", "I'm trying to implement the ls command in C with a few parameters like -a, -l... or -la, but I'm having issues with the parsing, when I use the input I get Segmentation Fault, this is an example of the -a parameter:int comparator(char *av) {\n    int i = 0;\n    if (my_strcmp((av[i]), \"-a\") == 0)\n        return 0;\n    else\n        return 1;\n}\n\nint my_ls_a(char *path) {\n    int comp = comparator(path);\n    DIR *pdirec = opendir(\".\");\n    struct dirent *direc;\n    direc = readdir(pdirec);\n    \n    while (direc != NULL || comp == 0) {\n        my_printf(\"%s  \", direc->d_name);\n        direc = readdir(pdirec);\n    }\n    if ((path = readdir(pdirec)) == NULL)\n        my_printf(\"\\n\");\n    if (pdirec == NULL)\n        return (84);\n    closedir(pdirec);\n    return (0);\n}\nAnd this is my main:int main(int ac, char *av[]) {  \n    if (ac == 1)\n        my_ls_a(av[0]);\n    return 0;\n}\nI already have all the #include in a .h by the way.When I only use the main function it works but not when I add the parameter -a.", "I wanted to know which system call is used in linux by the ls command to display the folder's (or file's name)? Especially the files/folders starting with \".\" (dot)I executed the strace ls -a command to look at the system calls.There is a lot of fstat calls which occur for the all the other attributes (inode to permisisons).  Which one actually gives it's name?execve(\"/bin/ls\", [\"ls\", \"-a\"], [/* 37 vars */]) = 0\nbrk(0)                                  = 0x1762000\naccess(\"/etc/ld.so.nohwcap\", F_OK)      = -1 ENOENT (No such file or directory)\nmmap(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f1c14025000\naccess(\"/etc/ld.so.preload\", R_OK)      = -1 ENOENT (No such file or directory)\nopen(\"/etc/ld.so.cache\", O_RDONLY|O_CLOEXEC) = 3\nfstat(3, {st_mode=S_IFREG|0644, st_size=109464, ...}) = 0\nmmap(NULL, 109464, PROT_READ, MAP_PRIVATE, 3, 0) = 0x7f1c1400a000\nclose(3)                                = 0\naccess(\"/etc/ld.so.nohwcap\", F_OK)      = -1 ENOENT (No such file or directory)\nopen(\"/lib/x86_64-linux-gnu/libselinux.so.1\", O_RDONLY|O_CLOEXEC) = 3\nread(3, \"\\177ELF\\2\\1\\1\\0\\0\\0\\0\\0\\0\\0\\0\\0\\3\\0>\\0\\1\\0\\0\\0\\20T\\0\\0\\0\\0\\0\\0\"..., 832) = 832\nfstat(3, {st_mode=S_IFREG|0644, st_size=121936, ...}) = 0\nmmap(NULL, 2221680, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x7f1c13be6000\nmprotect(0x7f1c13c03000, 2093056, PROT_NONE) = 0\nmmap(0x7f1c13e02000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x1c000) = 0x7f1c13e02000\nmmap(0x7f1c13e04000, 1648, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0x7f1c13e04000\nclose(3)                                = 0\naccess(\"/etc/ld.so.nohwcap\", F_OK)      = -1 ENOENT (No such file or directory)\nopen(\"/lib/x86_64-linux-gnu/librt.so.1\", O_RDONLY|O_CLOEXEC) = 3\nread(3, \"\\177ELF\\2\\1\\1\\0\\0\\0\\0\\0\\0\\0\\0\\0\\3\\0>\\0\\1\\0\\0\\0\\340!\\0\\0\\0\\0\\0\\0\"..., 832) = 832\nfstat(3, {st_mode=S_IFREG|0644, st_size=31752, ...}) = 0\nmmap(NULL, 2128984, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x7f1c139de000\nmprotect(0x7f1c139e5000, 2093056, PROT_NONE) = 0\nmmap(0x7f1c13be4000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x6000) = 0x7f1c13be4000\nclose(3)                                = 0\naccess(\"/etc/ld.so.nohwcap\", F_OK)      = -1 ENOENT (No such file or directory)\nopen(\"/lib/x86_64-linux-gnu/libacl.so.1\", O_RDONLY|O_CLOEXEC) = 3\nread(3, \"\\177ELF\\2\\1\\1\\0\\0\\0\\0\\0\\0\\0\\0\\0\\3\\0>\\0\\1\\0\\0\\0P\\33\\0\\0\\0\\0\\0\\0\"..., 832) = 832\nfstat(3, {st_mode=S_IFREG|0644, st_size=31096, ...}) = 0\nmmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f1c14009000\nmmap(NULL, 2126312, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x7f1c137d6000\nmprotect(0x7f1c137dd000, 2093056, PROT_NONE) = 0\nmmap(0x7f1c139dc000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x6000) = 0x7f1c139dc000\nclose(3)                                = 0\naccess(\"/etc/ld.so.nohwcap\", F_OK)      = -1 ENOENT (No such file or directory)\nopen(\"/lib/x86_64-linux-gnu/libc.so.6\", O_RDONLY|O_CLOEXEC) = 3\nread(3, \"\\177ELF\\2\\1\\1\\0\\0\\0\\0\\0\\0\\0\\0\\0\\3\\0>\\0\\1\\0\\0\\0\\200\\30\\2\\0\\0\\0\\0\\0\"..., 832) = 832\nfstat(3, {st_mode=S_IFREG|0755, st_size=1811128, ...}) = 0\nmmap(NULL, 3925208, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x7f1c13417000\nmprotect(0x7f1c135cc000, 2093056, PROT_NONE) = 0\nmmap(0x7f1c137cb000, 24576, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x1b4000) = 0x7f1c137cb000\nmmap(0x7f1c137d1000, 17624, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0x7f1c137d1000\nclose(3)                                = 0\naccess(\"/etc/ld.so.nohwcap\", F_OK)      = -1 ENOENT (No such file or directory)\nopen(\"/lib/x86_64-linux-gnu/libdl.so.2\", O_RDONLY|O_CLOEXEC) = 3\nread(3, \"\\177ELF\\2\\1\\1\\0\\0\\0\\0\\0\\0\\0\\0\\0\\3\\0>\\0\\1\\0\\0\\0\\340\\r\\0\\0\\0\\0\\0\\0\"..., 832) = 832\nfstat(3, {st_mode=S_IFREG|0644, st_size=14768, ...}) = 0\nmmap(NULL, 2109704, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x7f1c13213000\nmprotect(0x7f1c13215000, 2097152, PROT_NONE) = 0\nmmap(0x7f1c13415000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x2000) = 0x7f1c13415000\nclose(3)                                = 0\naccess(\"/etc/ld.so.nohwcap\", F_OK)      = -1 ENOENT (No such file or directory)\nopen(\"/lib/x86_64-linux-gnu/libpthread.so.0\", O_RDONLY|O_CLOEXEC) = 3\nread(3, \"\\177ELF\\2\\1\\1\\0\\0\\0\\0\\0\\0\\0\\0\\0\\3\\0>\\0\\1\\0\\0\\0\\200l\\0\\0\\0\\0\\0\\0\"..., 832) = 832\nfstat(3, {st_mode=S_IFREG|0755, st_size=135366, ...}) = 0\nmmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f1c14008000\nmmap(NULL, 2212904, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x7f1c12ff6000\nmprotect(0x7f1c1300e000, 2093056, PROT_NONE) = 0\nmmap(0x7f1c1320d000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x17000) = 0x7f1c1320d000\nmmap(0x7f1c1320f000, 13352, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0x7f1c1320f000\nclose(3)                                = 0\naccess(\"/etc/ld.so.nohwcap\", F_OK)      = -1 ENOENT (No such file or directory)\nopen(\"/lib/x86_64-linux-gnu/libattr.so.1\", O_RDONLY|O_CLOEXEC) = 3\nread(3, \"\\177ELF\\2\\1\\1\\0\\0\\0\\0\\0\\0\\0\\0\\0\\3\\0>\\0\\1\\0\\0\\0\\340\\17\\0\\0\\0\\0\\0\\0\"..., 832) = 832\nfstat(3, {st_mode=S_IFREG|0644, st_size=18552, ...}) = 0\nmmap(NULL, 2113736, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x7f1c12df1000\nmprotect(0x7f1c12df5000, 2093056, PROT_NONE) = 0\nmmap(0x7f1c12ff4000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x3000) = 0x7f1c12ff4000\nclose(3)                                = 0\nmmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f1c14007000\nmmap(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f1c14005000\narch_prctl(ARCH_SET_FS, 0x7f1c140057c0) = 0\nmprotect(0x7f1c137cb000, 16384, PROT_READ) = 0\nmprotect(0x7f1c12ff4000, 4096, PROT_READ) = 0\nmprotect(0x7f1c1320d000, 4096, PROT_READ) = 0\nmprotect(0x7f1c13415000, 4096, PROT_READ) = 0\nmprotect(0x7f1c139dc000, 4096, PROT_READ) = 0\nmprotect(0x7f1c13be4000, 4096, PROT_READ) = 0\nmprotect(0x7f1c13e02000, 4096, PROT_READ) = 0\nmprotect(0x618000, 4096, PROT_READ)     = 0\nmprotect(0x7f1c14027000, 4096, PROT_READ) = 0\nmunmap(0x7f1c1400a000, 109464)          = 0\nset_tid_address(0x7f1c14005a90)         = 4490\nset_robust_list(0x7f1c14005aa0, 0x18)   = 0\nfutex(0x7fff2e09d99c, FUTEX_WAIT_BITSET_PRIVATE|FUTEX_CLOCK_REALTIME, 1, NULL, 7f1c140057c0) = -1 EAGAIN (Resource temporarily unavailable)\nrt_sigaction(SIGRTMIN, {0x7f1c12ffc750, [], SA_RESTORER|SA_SIGINFO, 0x7f1c13005cb0}, NULL, 8) = 0\nrt_sigaction(SIGRT_1, {0x7f1c12ffc7e0, [], SA_RESTORER|SA_RESTART|SA_SIGINFO, 0x7f1c13005cb0}, NULL, 8) = 0\nrt_sigprocmask(SIG_UNBLOCK, [RTMIN RT_1], NULL, 8) = 0\ngetrlimit(RLIMIT_STACK, {rlim_cur=8192*1024, rlim_max=RLIM_INFINITY}) = 0\nstatfs(\"/selinux\", {f_type=\"EXT2_SUPER_MAGIC\", f_bsize=4096, f_blocks=238304997, f_bfree=232078639, f_bavail=219973436, f_files=60530688, f_ffree=60120220, f_fsid={-1173666966, -474985328}, f_namelen=255, f_frsize=4096}) = 0\nbrk(0)                                  = 0x1762000\nbrk(0x1783000)                          = 0x1783000\nopen(\"/proc/filesystems\", O_RDONLY)     = 3\nfstat(3, {st_mode=S_IFREG|0444, st_size=0, ...}) = 0\nmmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f1c14024000\nread(3, \"nodev\\tsysfs\\nnodev\\trootfs\\nnodev\\tb\"..., 1024) = 328\nread(3, \"\", 1024)                       = 0\nclose(3)                                = 0\nmunmap(0x7f1c14024000, 4096)            = 0\nopen(\"/usr/lib/locale/locale-archive\", O_RDONLY|O_CLOEXEC) = 3\nfstat(3, {st_mode=S_IFREG|0644, st_size=7220736, ...}) = 0\nmmap(NULL, 7220736, PROT_READ, MAP_PRIVATE, 3, 0) = 0x7f1c1270e000\nclose(3)                                = 0\nioctl(1, SNDCTL_TMR_TIMEBASE or TCGETS, {B38400 opost isig icanon echo ...}) = 0\nioctl(1, TIOCGWINSZ, {ws_row=41, ws_col=144, ws_xpixel=0, ws_ypixel=0}) = 0\nopenat(AT_FDCWD, \".\", O_RDONLY|O_NONBLOCK|O_DIRECTORY|O_CLOEXEC) = 3\ngetdents(3, /* 2 entries */, 32768)     = 48\ngetdents(3, /* 0 entries */, 32768)     = 0\nclose(3)                                = 0\nfstat(1, {st_mode=S_IFCHR|0620, st_rdev=makedev(136, 0), ...}) = 0\nmmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f1c14024000\nwrite(1, \".  ..\\n\", 6.  ..\n)                  = 6\nclose(1)                                = 0\nmunmap(0x7f1c14024000, 4096)            = 0\nclose(2)                                = 0\nexit_group(0)                           = ?\n", "I wanted to know which system call is used in linux by the ls command to display the folder's (or file's name)? Especially the files/folders starting with \".\" (dot)I executed the strace ls -a command to look at the system calls.There is a lot of fstat calls which occur for the all the other attributes (inode to permisisons).  Which one actually gives it's name?execve(\"/bin/ls\", [\"ls\", \"-a\"], [/* 37 vars */]) = 0\nbrk(0)                                  = 0x1762000\naccess(\"/etc/ld.so.nohwcap\", F_OK)      = -1 ENOENT (No such file or directory)\nmmap(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f1c14025000\naccess(\"/etc/ld.so.preload\", R_OK)      = -1 ENOENT (No such file or directory)\nopen(\"/etc/ld.so.cache\", O_RDONLY|O_CLOEXEC) = 3\nfstat(3, {st_mode=S_IFREG|0644, st_size=109464, ...}) = 0\nmmap(NULL, 109464, PROT_READ, MAP_PRIVATE, 3, 0) = 0x7f1c1400a000\nclose(3)                                = 0\naccess(\"/etc/ld.so.nohwcap\", F_OK)      = -1 ENOENT (No such file or directory)\nopen(\"/lib/x86_64-linux-gnu/libselinux.so.1\", O_RDONLY|O_CLOEXEC) = 3\nread(3, \"\\177ELF\\2\\1\\1\\0\\0\\0\\0\\0\\0\\0\\0\\0\\3\\0>\\0\\1\\0\\0\\0\\20T\\0\\0\\0\\0\\0\\0\"..., 832) = 832\nfstat(3, {st_mode=S_IFREG|0644, st_size=121936, ...}) = 0\nmmap(NULL, 2221680, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x7f1c13be6000\nmprotect(0x7f1c13c03000, 2093056, PROT_NONE) = 0\nmmap(0x7f1c13e02000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x1c000) = 0x7f1c13e02000\nmmap(0x7f1c13e04000, 1648, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0x7f1c13e04000\nclose(3)                                = 0\naccess(\"/etc/ld.so.nohwcap\", F_OK)      = -1 ENOENT (No such file or directory)\nopen(\"/lib/x86_64-linux-gnu/librt.so.1\", O_RDONLY|O_CLOEXEC) = 3\nread(3, \"\\177ELF\\2\\1\\1\\0\\0\\0\\0\\0\\0\\0\\0\\0\\3\\0>\\0\\1\\0\\0\\0\\340!\\0\\0\\0\\0\\0\\0\"..., 832) = 832\nfstat(3, {st_mode=S_IFREG|0644, st_size=31752, ...}) = 0\nmmap(NULL, 2128984, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x7f1c139de000\nmprotect(0x7f1c139e5000, 2093056, PROT_NONE) = 0\nmmap(0x7f1c13be4000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x6000) = 0x7f1c13be4000\nclose(3)                                = 0\naccess(\"/etc/ld.so.nohwcap\", F_OK)      = -1 ENOENT (No such file or directory)\nopen(\"/lib/x86_64-linux-gnu/libacl.so.1\", O_RDONLY|O_CLOEXEC) = 3\nread(3, \"\\177ELF\\2\\1\\1\\0\\0\\0\\0\\0\\0\\0\\0\\0\\3\\0>\\0\\1\\0\\0\\0P\\33\\0\\0\\0\\0\\0\\0\"..., 832) = 832\nfstat(3, {st_mode=S_IFREG|0644, st_size=31096, ...}) = 0\nmmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f1c14009000\nmmap(NULL, 2126312, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x7f1c137d6000\nmprotect(0x7f1c137dd000, 2093056, PROT_NONE) = 0\nmmap(0x7f1c139dc000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x6000) = 0x7f1c139dc000\nclose(3)                                = 0\naccess(\"/etc/ld.so.nohwcap\", F_OK)      = -1 ENOENT (No such file or directory)\nopen(\"/lib/x86_64-linux-gnu/libc.so.6\", O_RDONLY|O_CLOEXEC) = 3\nread(3, \"\\177ELF\\2\\1\\1\\0\\0\\0\\0\\0\\0\\0\\0\\0\\3\\0>\\0\\1\\0\\0\\0\\200\\30\\2\\0\\0\\0\\0\\0\"..., 832) = 832\nfstat(3, {st_mode=S_IFREG|0755, st_size=1811128, ...}) = 0\nmmap(NULL, 3925208, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x7f1c13417000\nmprotect(0x7f1c135cc000, 2093056, PROT_NONE) = 0\nmmap(0x7f1c137cb000, 24576, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x1b4000) = 0x7f1c137cb000\nmmap(0x7f1c137d1000, 17624, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0x7f1c137d1000\nclose(3)                                = 0\naccess(\"/etc/ld.so.nohwcap\", F_OK)      = -1 ENOENT (No such file or directory)\nopen(\"/lib/x86_64-linux-gnu/libdl.so.2\", O_RDONLY|O_CLOEXEC) = 3\nread(3, \"\\177ELF\\2\\1\\1\\0\\0\\0\\0\\0\\0\\0\\0\\0\\3\\0>\\0\\1\\0\\0\\0\\340\\r\\0\\0\\0\\0\\0\\0\"..., 832) = 832\nfstat(3, {st_mode=S_IFREG|0644, st_size=14768, ...}) = 0\nmmap(NULL, 2109704, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x7f1c13213000\nmprotect(0x7f1c13215000, 2097152, PROT_NONE) = 0\nmmap(0x7f1c13415000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x2000) = 0x7f1c13415000\nclose(3)                                = 0\naccess(\"/etc/ld.so.nohwcap\", F_OK)      = -1 ENOENT (No such file or directory)\nopen(\"/lib/x86_64-linux-gnu/libpthread.so.0\", O_RDONLY|O_CLOEXEC) = 3\nread(3, \"\\177ELF\\2\\1\\1\\0\\0\\0\\0\\0\\0\\0\\0\\0\\3\\0>\\0\\1\\0\\0\\0\\200l\\0\\0\\0\\0\\0\\0\"..., 832) = 832\nfstat(3, {st_mode=S_IFREG|0755, st_size=135366, ...}) = 0\nmmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f1c14008000\nmmap(NULL, 2212904, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x7f1c12ff6000\nmprotect(0x7f1c1300e000, 2093056, PROT_NONE) = 0\nmmap(0x7f1c1320d000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x17000) = 0x7f1c1320d000\nmmap(0x7f1c1320f000, 13352, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0x7f1c1320f000\nclose(3)                                = 0\naccess(\"/etc/ld.so.nohwcap\", F_OK)      = -1 ENOENT (No such file or directory)\nopen(\"/lib/x86_64-linux-gnu/libattr.so.1\", O_RDONLY|O_CLOEXEC) = 3\nread(3, \"\\177ELF\\2\\1\\1\\0\\0\\0\\0\\0\\0\\0\\0\\0\\3\\0>\\0\\1\\0\\0\\0\\340\\17\\0\\0\\0\\0\\0\\0\"..., 832) = 832\nfstat(3, {st_mode=S_IFREG|0644, st_size=18552, ...}) = 0\nmmap(NULL, 2113736, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x7f1c12df1000\nmprotect(0x7f1c12df5000, 2093056, PROT_NONE) = 0\nmmap(0x7f1c12ff4000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x3000) = 0x7f1c12ff4000\nclose(3)                                = 0\nmmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f1c14007000\nmmap(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f1c14005000\narch_prctl(ARCH_SET_FS, 0x7f1c140057c0) = 0\nmprotect(0x7f1c137cb000, 16384, PROT_READ) = 0\nmprotect(0x7f1c12ff4000, 4096, PROT_READ) = 0\nmprotect(0x7f1c1320d000, 4096, PROT_READ) = 0\nmprotect(0x7f1c13415000, 4096, PROT_READ) = 0\nmprotect(0x7f1c139dc000, 4096, PROT_READ) = 0\nmprotect(0x7f1c13be4000, 4096, PROT_READ) = 0\nmprotect(0x7f1c13e02000, 4096, PROT_READ) = 0\nmprotect(0x618000, 4096, PROT_READ)     = 0\nmprotect(0x7f1c14027000, 4096, PROT_READ) = 0\nmunmap(0x7f1c1400a000, 109464)          = 0\nset_tid_address(0x7f1c14005a90)         = 4490\nset_robust_list(0x7f1c14005aa0, 0x18)   = 0\nfutex(0x7fff2e09d99c, FUTEX_WAIT_BITSET_PRIVATE|FUTEX_CLOCK_REALTIME, 1, NULL, 7f1c140057c0) = -1 EAGAIN (Resource temporarily unavailable)\nrt_sigaction(SIGRTMIN, {0x7f1c12ffc750, [], SA_RESTORER|SA_SIGINFO, 0x7f1c13005cb0}, NULL, 8) = 0\nrt_sigaction(SIGRT_1, {0x7f1c12ffc7e0, [], SA_RESTORER|SA_RESTART|SA_SIGINFO, 0x7f1c13005cb0}, NULL, 8) = 0\nrt_sigprocmask(SIG_UNBLOCK, [RTMIN RT_1], NULL, 8) = 0\ngetrlimit(RLIMIT_STACK, {rlim_cur=8192*1024, rlim_max=RLIM_INFINITY}) = 0\nstatfs(\"/selinux\", {f_type=\"EXT2_SUPER_MAGIC\", f_bsize=4096, f_blocks=238304997, f_bfree=232078639, f_bavail=219973436, f_files=60530688, f_ffree=60120220, f_fsid={-1173666966, -474985328}, f_namelen=255, f_frsize=4096}) = 0\nbrk(0)                                  = 0x1762000\nbrk(0x1783000)                          = 0x1783000\nopen(\"/proc/filesystems\", O_RDONLY)     = 3\nfstat(3, {st_mode=S_IFREG|0444, st_size=0, ...}) = 0\nmmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f1c14024000\nread(3, \"nodev\\tsysfs\\nnodev\\trootfs\\nnodev\\tb\"..., 1024) = 328\nread(3, \"\", 1024)                       = 0\nclose(3)                                = 0\nmunmap(0x7f1c14024000, 4096)            = 0\nopen(\"/usr/lib/locale/locale-archive\", O_RDONLY|O_CLOEXEC) = 3\nfstat(3, {st_mode=S_IFREG|0644, st_size=7220736, ...}) = 0\nmmap(NULL, 7220736, PROT_READ, MAP_PRIVATE, 3, 0) = 0x7f1c1270e000\nclose(3)                                = 0\nioctl(1, SNDCTL_TMR_TIMEBASE or TCGETS, {B38400 opost isig icanon echo ...}) = 0\nioctl(1, TIOCGWINSZ, {ws_row=41, ws_col=144, ws_xpixel=0, ws_ypixel=0}) = 0\nopenat(AT_FDCWD, \".\", O_RDONLY|O_NONBLOCK|O_DIRECTORY|O_CLOEXEC) = 3\ngetdents(3, /* 2 entries */, 32768)     = 48\ngetdents(3, /* 0 entries */, 32768)     = 0\nclose(3)                                = 0\nfstat(1, {st_mode=S_IFCHR|0620, st_rdev=makedev(136, 0), ...}) = 0\nmmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f1c14024000\nwrite(1, \".  ..\\n\", 6.  ..\n)                  = 6\nclose(1)                                = 0\nmunmap(0x7f1c14024000, 4096)            = 0\nclose(2)                                = 0\nexit_group(0)                           = ?\n"], "chosen": ["\nIf you give find an absolute path to start with, it will print absolute paths. For instance, to find all .htaccess files in the current directory:\nfind \"$(pwd)\" -name .htaccess\n\nor if your shell expands $PWD to the current directory:\nfind \"$PWD\" -name .htaccess\n\nfind simply prepends the path it was given to a relative path to the file from that path.\nGreg Hewgill also suggested using pwd -P if you want to resolve symlinks in your current directory.\n", "\nreadlink -f filename \n\ngives the full absolute path. But if the file is a symlink, you'll get the final resolved name.\n", "\nUse this for dirs (the / after ** is needed in bash to limit it to directories):\nls -d -1 \"$PWD/\"**/\n\nthis for files and directories directly under the current directory, whose names contain a .:\nls -d -1 \"$PWD/\"*.*\n\nthis for everything:\nls -d -1 \"$PWD/\"**/*\n\nTaken from here\n  http://www.zsh.org/mla/users/2002/msg00033.html\nIn bash, ** is recursive if you enable shopt -s globstar.\n", "\nYou can use \nfind $PWD \n\nin bash\n", "\nls -d \"$PWD/\"*\n\nThis looks only in the current directory.  It quotes \"$PWD\" in case it contains spaces.\n", "\nCommand: ls -1 -d \"$PWD/\"*\nThis will give the absolute paths of the file like below.\n[root@kubenode1 ssl]# ls -1 -d \"$PWD/\"*\n/etc/kubernetes/folder/file-test-config.txt\n/etc/kubernetes/folder/file-test.txt\n/etc/kubernetes/folder/file-client.txt\n\n", "\nYou can do\nls -1 | xargs realpath\n\nIf you need to specify an absolute path or relative path, you can do that as well\nls -1 $FILEPATH | xargs realpath\n\n", "\nTry this:\nfind \"$PWD\"/\n\nYou get list of absolute paths in working directory.\n", "\nThe $PWD is a good option by Matthew above. If you want find to only print files then you can also add the  -type f option to search only normal files. Other options are \"d\" for directories  only etc. So in your case it would be (if i want to search only for files with .c ext):\nfind $PWD -type f -name \"*.c\" \n\nor if you want all files:\nfind $PWD -type f\n\nNote: You can't make an alias for the above command, because $PWD gets auto-completed to your home directory when the alias is being set by bash. \n", "\nIf you give the find command an absolute path, it will spit the results out with an absolute path.  So, from the Ken directory if you were to type:\nfind /home/ken/foo/ -name bar -print    \n\n(instead of the relative path find . -name bar -print)\nYou should get:\n/home/ken/foo/bar\n\nTherefore, if you want an ls -l and have it return the absolute path, you can just tell the find command to execute an ls -l on whatever it finds.\nfind /home/ken/foo -name bar -exec ls -l {} ;\\ \n\nNOTE: There is a space between {} and ;\nYou'll get something like this:\n-rw-r--r--   1 ken admin       181 Jan 27 15:49 /home/ken/foo/bar\n\nIf you aren't sure where the file is, you can always change the search location.  As long as the search path starts with \"/\", you will get an absolute path in return.  If you are searching a location (like /) where you are going to get a lot of permission denied errors, then I would recommend redirecting standard error so you can actually see the find results:\nfind / -name bar -exec ls -l {} ;\\ 2> /dev/null\n\n(2> is the syntax for the Borne and Bash shells, but will not work with the C shell.  It may work in other shells too, but I only know for sure that it works in Bourne and Bash).\n", "\nJust an alternative to  \nls -d \"$PWD/\"* \n\nto pinpoint that * is shell expansion, so \necho \"$PWD/\"*\n\nwould do the same (the drawback you cannot use -1 to separate by new lines, not spaces).\n", "\nfd\nUsing fd (alternative to find), use the following syntax:\nfd . foo -a\n\nWhere . is the search pattern and foo is the root directory.\nE.g. to list all files in etc recursively, run: fd . /etc -a.\n\n-a, --absolute-path     Show absolute instead of relative paths\n\n", "\nIf you need list of all files in current as well as sub-directories\nfind $PWD -type f\n\nIf you need list of all files only in current directory\nfind $PWD -maxdepth 1 -type f\n\n", "\nYou might want to try this.\nfor name in /home/ken/foo/bar/*\ndo\n    echo $name\ndone\n\nYou can get abs path using for loop and echo simply without find.\n", "\nfind jar file recursely and print absolute path\n`ls -R |grep \"\\.jar$\" | xargs readlink -f`                                                                                                                                                                                                                                                               \n\n/opt/tool/dev/maven_repo/com/oracle/ojdbc/ojdbc8-19.3.0.0.jar\n/opt/tool/dev/maven_repo/com/oracle/ojdbc/ons-19.3.0.0.jar\n/opt/tool/dev/maven_repo/com/oracle/ojdbc/oraclepki-19.3.0.0.jar\n/opt/tool/dev/maven_repo/com/oracle/ojdbc/osdt_cert-19.3.0.0.jar\n/opt/tool/dev/maven_repo/com/oracle/ojdbc/osdt_core-19.3.0.0.jar\n/opt/tool/dev/maven_repo/com/oracle/ojdbc/simplefan-19.3.0.0.jar\n/opt/tool/dev/maven_repo/com/oracle/ojdbc/ucp-19.3.0.0.jar\n\n\n", "\nThis works best if you want a dynamic solution that works well in a function\nlfp ()\n{\n  ls -1 $1 | xargs -I{} echo $(realpath $1)/{}\n}\n\n\n", "\nlspwd() { for i in $@; do ls -d -1 $PWD/$i; done }\n\n", "\nHere's an example that prints out a list without an extra period and that also demonstrates how to search for a file match.  Hope this helps:\nfind . -type f -name \"extr*\" -exec echo `pwd`/{} \\; | sed \"s|\\./||\"\n\n", "\nThis worked for me. But it didn't list in alphabetical order.\nfind \"$(pwd)\" -maxdepth 1\n\nThis command lists alphabetically as well as lists hidden files too.\nls -d -1 \"$PWD/\".*; ls -d -1 \"$PWD/\"*;\n\n", "\nstat\nAbsolute path of a single file:\nstat -c %n \"$PWD\"/foo/bar\n\n", "\nThis will give the canonical path (will resolve symlinks): realpath FILENAME\nIf you want canonical path to the symlink itself, then: realpath -s FILENAME\n", "\nMost if not all of the suggested methods result in paths that cannot be used directly in some other terminal command if the path contains spaces. Ideally the results will have slashes prepended.\nThis works for me on macOS:\nfind / -iname \"*SEARCH TERM spaces are okay*\" -print 2>&1  | grep -v denied |grep -v permitted |sed -E 's/\\ /\\\\ /g'\n\n", "\nfor p in <either relative of absolute path of the directory>/*; do\n    echo $(realpath -s $p)\ndone\n\n", "\nRecursive files can be listed by many ways in Linux. Here I am sharing one liner script to clear all logs of files(only files) from /var/log/ directory and second check recently which logs file has made an entry.\nFirst:\nfind /var/log/ -type f  #listing file recursively \n\nSecond:\nfor i in $(find $PWD -type f) ; do cat /dev/null > \"$i\" ; done #empty files recursively \n\nThird use:\nls -ltr $(find /var/log/ -type f ) # listing file used in recent\n\nNote: for directory location you can also pass $PWD instead of /var/log.\n", "\nIf you don't have symbolic links, you could try\ntree -iFL 1 [DIR]\n\n-i makes tree print filenames in each line, without the tree structure.\n-f makes tree print the full path of each file.\n-L 1 avoids tree from recursion.\n", "\nWrite one small function\nlsf() {\nls `pwd`/$1\n}\n\nThen you can use like\nlsf test.sh \n\nit gives full path like\n/home/testuser/Downloads/test.sh\n\n", "\nI used the following to list absolute path of files in a directory in a txt file:\nfind \"$PWD\" -wholename '*.JPG' >test.txt\n\n", "\nHere is a shorter, more convenient solution:\nfind ~+\n\n\n~+ means \"$PWD\", except it's quoted automatically, and requires less reaching around the keyboard for symbols\nAdd -name .htaccess or -maxdepth 1 if necessary\n\nUnlike what another answer says, you CAN make an alias for this command:\nalias fa='find ~+'\n\n\nPut this in ~/.bashrc and you only have to type as little as 2 letters\nAlternatively you can add -name at the end of the alias and use it like fa .htaccess\nThe single quotes prevent premature expansion\nfa means Find Absolute path\n\n", "\n ls -a /usr | grep '^[prs]'\n\nWould select from the output of ls -a /usr (which is the list of files in /usr delimited by newline characters) the lines that start by either of the p, r or s characters.\nThat's probably what your teacher is expecting but it's wrong or at least not reliable.\nFile names can be made of many lines since the newline character is as valid a character as any in a file name on Linux or any unix. So that command doesn't return the files whose name starts with p, q or s, but the lines of the filenames that start with p, q or s. Generally, you can't post-process the output of ls reliably.\n-a is to include hidden files, that is files whose name starts with .. Since you only want those that start with p, q or s, that's redundant.\nNote that:\nls /usr | grep ^[pqs]\n\nwould be even more wrong. First ^ is a special character in a few shells like the Bourne shell, rc, es or zsh -o extendedglob (though OK in bash or other POSIX shells).\nThen, in most shells (fish being a notable exception), [pqs] is a globbing operator. That means that ^[qps] is meant to be expanded by the shell to the list of files that match that pattern (relative to the current directory).\nSo in those shells like bash that don't treat ^ specially, if there is a file called ^p in the current directory, that will become\nls /usr | grep ^p\n\nIf there's no matching file, in csh, tcsh, zsh or bash -O failglob, you'll get an error message and the command will be cancelled. In zsh -o extendedglob where ^ is a globbing operator, ^[pqs] would mean any file but p, q or s.\n", "\nIf you're trying to find files, don't use ls.  Use the find command.\nfind /usr -name '[prs]*'\n\nIf you don't want to search the entire tree under /usr, do this:\nfind /usr -maxdepth 1 -name '[prs]*'\n\n", "\nThe comment of @twalberg is perfect for the options you asked.\nThe echo ignores hidden files, but those will be filtered when you only want files starting with [prs].\nWhen you want hidden files for other filters, a similar solution would be ls -ad /usr/[prs]*, where the -d option suppresses the listing of subdirs.\nThat solution will also show the full path, this can be suppressed when you go to the dir first. When you want to stay in your current directory, use a subshell for it.  I use && for skipping the ls when the /usr dir doesn't exist.\n(cd /usr && ls -ad [prs]*)\n\n", "\nI'd ls the directory and only then apply the grep. Also, you're missing the ^ character to filter out only the files that start with those letters:\n$ ls -a /usr | grep ^[prs]\n\n", "\nWhy not just\n find /usr -type f -name '[prs]*'\n\n", "\nyou got \"argument too long\" because shell expands your pattern to the list of files. \ntry:\nfind  -maxdepth 1 -name '20061101-20131101_kh5x7tte9n_2010_*' |wc -l\n\nplease pay attention - pattern is enclosed in quotes to prevent shell expansion\n", "\nIt might be better to use find for this:\nfind . -name \"pattern_*\" -printf '.' | wc -m\n\nIn your specific case:\nfind . -maxdepth 1 -name \"20061101-20131101_kh5x7tte9n_2010_*\" -printf '.' | wc -m\n\nfind will return a list of files matching the criteria. -maxdepth 1 will make the search to be done just in the path, no subdirectories (thanks Petesh!). -printf '.' will print a dot for every match, so that names with new lines won't make wc -m break.\nThen wc -m will indicate the number of characters which will match the number of files.\n\nPerformance comparation of two possible options:\nLet's create 10 000 files with this pattern:\n$ for i in {1..10000}; do touch 20061101-20131101_kh5x7tte9n_201_$i; done\n\nAnd then compare the time it takes to get the result with ls -1 ... or find ...:\n$ time find . -maxdepth 1 -name \"20061101-20131101_kh5x7tte9n_201_*\" | wc -m\n10000\n\nreal    0m0.034s\nuser    0m0.017s\nsys     0m0.021s\n\n$ time ls -1 | grep 20061101-20131101_kh5x7tte9n_201 | wc -m\n10000\n\nreal    0m0.254s\nuser    0m0.245s\nsys     0m0.020s\n\nfind is x5 times faster! But if we use ls -1f (thanks Petesh again!), then ls is even faster than find:\n$ time ls -1f | grep 20061101-20131101_kh5x7tte9n_201 | wc -m\n10000\n\nreal    0m0.023s\nuser    0m0.020s\nsys     0m0.012s\n\n", "\nJust do:\nfind . -name \"pattern_*\" |wc -l\n\n", "\nThe MacOS / OS X command line solution\nIf you are attempting to do this in the command line on a Mac you will soon find out that find does not support the -printf option.\nTo accomplish the same result as the solution proposed by fedorqui-supports-monica try this:\nfind . -name \"pattern_*\" -exec stat -f \".\" {} \\; | wc -l\n\nThis will find all files matching the pattern you entered, print a . for each of them in a newline, then finally count the number of lines and output that number.\n\nTo limit your search depth to the current directory, add -maxdepth 1 to the command like so:\nfind . -maxdepth 1 -name \"196288.*\" -exec stat -f \".\" {} \\; | wc -l\n\n", "\nTry this:\nls -1 | grep 20061101-20131101_kh5x7tte9n_2010_ | wc -l\n\n", "\nYou should generally avoid ls in scripts and in fact, performing the calculation in a shell function will avoid the \"argument list too long\" error because there is no exec boundary and so the ARGV_MAX limit doesn't come into play.\nnumber_of_files () {\n    if [ -e \"$1\" ]; then\n        echo \"$#\"\n    else\n        echo 0\n    fi\n}\n\nThe conditional guards against the glob not being expanded at all (which is the default out of the box; in Bash, you can shopt -s nullglob to make wildcards which don't match any files get expanded into the empty string).\nTry it:\nnumber_of_files 20061101-20131101_kh5x7tte9n_2010_*\n\n", "\nFirst of all it is better not to use ls according to this article !!!\nand this problem can be solved in many ways. I will list some of the most elegant ones that come to my mind.\ncount=$(printf '%s\\n' *pattern* | wc -l) \n#or\ncount=$(shopt -s nullglob; files=(*pattern*); echo ${#files[@]})\n#or\ncount=$(file *pattern* | wc -l)\n#or\ncount=$(stat -c \"%n\" *pattern* | wc -l)\n#or\ncount=$(du -a *pattern* | wc -l)\n#or\ncount=$(echo *pattern* | wc -w)\n\nbut last one gives the wrong number when the file names contain whitespace.\n", "\nSolution without problems with \"ls\" (strange named files)\nThis is a combination of ceving's and anubhava's answer.\nBoth solutions are not working for me. Because I was looking for a script that should run every day for backing up files in an archive, I wanted to avoid problems with ls (someone could have saved some funny named file in my backup folder). So I modified the mentioned solutions to fit my needs.\nMy solution deletes all files, except the three newest files.\nfind . -type f -printf '%T@\\t%p\\n' |\nsort -t $'\\t' -g | \nhead -n -3 | \ncut -d $'\\t' -f 2- |\nxargs -r rm\n\nSome explanation:\nfind lists all files (not directories) in current folder. They are printed out with timestamps.\nsort sorts the lines based on timestamp (oldest on top).\nhead prints out the top lines, up to the last 3 lines.\ncut removes the timestamps.\nxargs runs rm for every selected file, while -r lets it not fail when no files are found\nFor you to verify my solution:\n(\ntouch -d \"6 days ago\" test_6_days_old\ntouch -d \"7 days ago\" test_7_days_old\ntouch -d \"8 days ago\" test_8_days_old\ntouch -d \"9 days ago\" test_9_days_old\ntouch -d \"10 days ago\" test_10_days_old\n)\n\nThis creates 5 files with different timestamps in the current folder. Run this script first and then the code for deleting old files.\n", "\nThis will list all files except the newest three:\nls -t | tail -n +4\n\nThis will delete those files:\nls -t | tail -n +4 | xargs rm --\n\nthis does not delete dotfiles. if you also want to delete dotfiles then change ls -t to ls -At.\nthe double dash (--) after rm is a safeguard against filenames starting with dash. see here for more info: https://unix.stackexchange.com/questions/1519/how-do-i-delete-a-file-whose-name-begins-with-hyphen-a-k-a-dash-or-minus\nthis command can fail horribly if the filenames contain spaces or newlines or other funny characters. if your filenames can contain space, or if you plan to use this in a script then you should read these articles:  http://mywiki.wooledge.org/ParsingLs and http://mywiki.wooledge.org/BashFAQ/003\n", "\nThe following looks a bit complicated, but is very cautious to be correct, even with unusual or intentionally malicious filenames. Unfortunately, it requires GNU tools:\ncount=0\nwhile IFS= read -r -d ' ' && IFS= read -r -d '' filename; do\n  (( ++count > 3 )) && printf '%s\\0' \"$filename\"\ndone < <(find . -maxdepth 1 -type f -printf '%T@ %P\\0' | sort -g -z) \\\n     | xargs -0 rm -f --\n\n\nExplaining how this works:\n\nFind emits <mtime> <filename><NUL> for each file in the current directory.\nsort -g -z does a general (floating-point, as opposed to integer) numeric sort based on the first column (times) with the lines separated by NULs.\nThe first read in the while loop strips off the mtime (no longer needed after sort is done).\nThe second read in the while loop reads the filename (running until the NUL).\nThe loop increments, and then checks, a counter; if the counter's state indicates that we're past the initial skipping, then we print the filename, delimited by a NUL.\nxargs -0 then appends that filename into the argv list it's collecting to invoke rm with.\n\n", "\nls -t | tail -n +4 | xargs -I {} rm {}\n\nIf you want a 1 liner\n", "\nDon't use ls -t as it is unsafe for filenames that may contain whitespaces or special glob characters.\nYou can do this using all gnu based utilities to delete all but 3 newest files in the current directory:\nfind . -maxdepth 1 -type f -printf '%T@\\t%p\\0' |\nsort -z -nrk1 |\ntail -z -n +4 |\ncut -z -f2- |\nxargs -0 rm -f --\n\n", "\nIn zsh:\nrm /files/to/delete/*(Om[1,-4])\n\nIf you want to include dotfiles, replace the parenthesized part with (Om[1,-4]D).\nI think this works correctly with arbitrary chars in the filenames (just checked with newline).\nExplanation: The parentheses contain Glob Qualifiers. O means \"order by, descending\", m means mtime (See man zshexpn for other sorting keys - large manpage; search for \"be sorted\"). [1,-4] returns only the matches at one-based index 1 to (last + 1 - 4) (note the -4 for deleting all but 3).\n", "\nls -t | tail -n +4 | xargs -I {} rm {}\n\nMichael Ballent's answer works best as \nls -t | tail -n +4 | xargs rm --\n\nthrow me error if I have less than 3 file\n", "\nRecursive script with arbitrary num of files to keep per-directory\nAlso handles files/dirs with spaces, newlines and other odd characters\n#!/bin/bash\nif (( $# != 2 )); then\n  echo \"Usage: $0 </path/to/top-level/dir> <num files to keep per dir>\"\n  exit\nfi\n\nwhile IFS= read -r -d $'\\0' dir; do\n  # Find the nth oldest file\n  nthOldest=$(find \"$dir\" -maxdepth 1 -type f -printf '%T@\\0%p\\n' | sort -t '\\0' -rg \\\n    | awk -F '\\0' -v num=\"$2\" 'NR==num+1{print $2}')\n\n  if [[ -f \"$nthOldest\" ]]; then\n    find \"$dir\" -maxdepth 1 -type f ! -newer \"$nthOldest\" -exec rm {} +\n  fi\ndone < <(find \"$1\" -type d -print0)\n\nProof of concept\n$ tree test/\ntest/\n\u251c\u2500\u2500 sub1\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 sub1_0_days_old.txt\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 sub1_1_days_old.txt\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 sub1_2_days_old.txt\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 sub1_3_days_old.txt\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 sub1\\ 4\\ days\\ old\\ with\\ spaces.txt\n\u251c\u2500\u2500 sub2\\ with\\ spaces\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 sub2_0_days_old.txt\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 sub2_1_days_old.txt\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 sub2_2_days_old.txt\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 sub2\\ 3\\ days\\ old\\ with\\ spaces.txt\n\u2514\u2500\u2500 tld_0_days_old.txt\n\n2 directories, 10 files\n$ ./keepNewest.sh test/ 2\n$ tree test/\ntest/\n\u251c\u2500\u2500 sub1\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 sub1_0_days_old.txt\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 sub1_1_days_old.txt\n\u251c\u2500\u2500 sub2\\ with\\ spaces\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 sub2_0_days_old.txt\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 sub2_1_days_old.txt\n\u2514\u2500\u2500 tld_0_days_old.txt\n\n2 directories, 5 files\n\n", "\nAs an extension to the answer by flohall. If you want to remove all folders except the newest three folders use the following:\nfind . -maxdepth 1 -mindepth 1 -type d -printf '%T@\\t%p\\n' |\n sort -t $'\\t' -g | \n head -n -3 | \n cut -d $'\\t' -f 2- |\n xargs rm -rf\n\nThe -mindepth 1 will ignore the parent folder and -maxdepth 1 subfolders.\n", "\nThis uses find instead of ls with a Schwartzian transform. \nfind . -type f -printf '%T@\\t%p\\n' |\nsort -t $'\\t' -g |\ntail -3 |\ncut -d $'\\t' -f 2-\n\nfind searches the files and decorates them with a time stamp and uses the tabulator to separate the two values. sort splits the input by the tabulator and performs a general numeric sort, which sorts floating point numbers correctly. tail should be obvious and cut undecorates.\nThe problem with decorations in general is to find a suitable delimiter, which is not part of the input, the file names. This answer uses the NULL character.\n", "\nThe c stands for character device. This is a special type of device, which, instead of operating on blocks, operates on characters (technically blocks of size 1).\nSadly, the ls man page on Linux does not say much about that. However, the FreeBSD man page for ls does.\nNevertheless, this should have been asked on the super user stack exchange.\n", "\nIf you enable extglob (shopt -s extglob), you can use *.@(ogg|mp3).\nshopt -s extglob\nprintf '%s\\n' *.@(mp3|ogg)\n\nIf you need recursion too, enable globstar (requires bash 4.0 or newer)\nshopt -s extglob globstar\nprintf '%s\\n' **/*.@(mp3|ogg)\n\nWhen you use ls *.{mp3,ogg}, you are combining brace expansion and pathname expansion. What happens is:\nls *.{mp3,ogg}  \nls *.mp3 *.ogg  # after brace expansion\nls '*.mp3' 1.ogg 2.ogg 3.ogg # after pathname expansion\n\nIf there's no matching files for a glob, the glob will just be passed on unchanged. And ls will treat it as a literal filename; it doesn't know about globs/wildcards.\nThe find ~ -iname '*.{mp3,ogg}'  doesn't work because find doesn't do brace expansion, that's a bash feature.\n", "\nI think this should work for you\n   find ~ -name \"*.mp3\" -o -name \"*.ogg\"\n\n-o is equivalent to boolean or\n", "\nThis one provides you with even those files which do not have mp3 or audio extension.\nfind -print0 | xargs -0 file -F '//' | awk -F '//' 'tolower($2) ~ /audio/ { print $1 }'\n\n\nwhich interprets to:\nfind . -print0 \nFind (list) every file and output with a null terminator\nxargs -0 file -F '//' Run file(1) with the stdin (or piped input),  delimited by null character,   as the first argument.\nfile -F '//' Delimit file name and its type by // as it neither appears in a UNIX filename nor as a file type.\nawk -F '//' '...'  Use the // delimiter as field separator. The awk script case-insensitively matches the occurrence of audio in the second field (ie the file type as reported by file(1)) and for every match, prints the file path.\n", "\nHere is one I just did . . .\nfor .ogg and .mp3\n         find Music | grep '/*.ogg\\|/*.mp3' | sort -u\n\n", "\nfind does not support the full shell wildcard syntax (specifically, not the curly braces). You'll need to use something like this:\nfind ~ -iname '*.mp3' -o -iname '*.ogg'\n\n", "\nwhat about?\nfile * | grep audio\n\n", "\nset execute bit permissions for group you belong to.\n", "\nI prefer this, because it also works with a large number of files\nfind . -name '*.txt' -printf '%T@ %t %p\\n' | sort -k 1 -n\n\n", "\n\ngrep accepts regular expressions, not glob. /foo/bar/*.txt is a glob. Try /foo/bar/.*\\.txt\nalso ls lists files and directories under your current directory. It will not list the full path. Do some tests, and you will see it easily.\nls may output results in a single line, and this could make your grep -c give an incorrect result. Because grep does line-based matching.\n\n", "\ncut -d' ' won't capture the third field when it contains leading spaces -- each space is treated as the separator of another field.\nAlternatives:\n\ncut -c\n 123456789X123456789X123456789X123456789X123456789L0123456789X0123\n -rw-r-----  1             31122918 group 20169510233 Mar 17 06:02\n -rw-r-----  1 user1                group 20165884490 Mar 25 11:11\n\n\n\nThe data you seek is between characters 15 and 34 on each line, so you can say\n    cut -c14-39\n\n\nperl/awk: other tools are adept at extracting data out of a line. Try one of\n perl -lane 'print $F[2]'\n awk '{print $3}'\n\n\n\n", "\nDon't try to parse the output of ls. Use the stat command.\nfind dirname  ! -user root -type f -exec stat --format=%U {} + | sort | uniq -c | sort -n\n\n%U prints the owner username.\n", "\nMerging multiple spaces\ntr -s ' '\nGet file users\n\nls -hl | tr -s ' ' | cut -f 3 -d' '\nls -hl | awk '{print $3}'\n\nsudo find ./ ! -user root -type f -exec ls -lh {} + | tr -s ' ' | cut -f 3 -d' ' | sort | uniq -c | sort -n\n", "\nYou have undefined behavior in the function comparator in my_strcmp((av[i]), \"-a\") because av is defined as a char * so you are passing a character where my_strcmp probably expects a pointer.\nYou should compile with -Wall -Werror to avoid such silly mistakes.\nIt is unclear why you pass only a single argument to my_ls_a. You should pass both ac and the argument array av and iterate on the arguments to parse the options.\n", "\nit is the stat(2) syscall which query the status of some file (perhaps a directory); if you have a file descriptor (after an open(2) syscall) you can use fstat(2) \nTo read a directory, you'll better use the readdir(3) function which calls the getdents(2) syscall.\n", "\nMost of the system calls there are noise from loading shared libraries at startup.  The interesting things happen here:\nopenat(AT_FDCWD, \".\", O_RDONLY|O_NONBLOCK|O_DIRECTORY|O_CLOEXEC) = 3\ngetdents(3, /* 2 entries */, 32768)     = 48\ngetdents(3, /* 0 entries */, 32768)     = 0\nclose(3)  \n\nThe openat(2) system call is used to open the current directory (\".\") relative to the current working directory (the AT_FDCWD flag).  The O_DIRECTORY flag indicates that it wants to open the directory and read the directory's contents.\nThe actual directory data is read using the getdents(2) system call.  In this case, it called it twice, since until it returns 0, it's not sure if there's more data or not.  Finally, the file descriptor is closed after it's done.\nIf you were to write your own program, however, you wouldn't call these directly -- instead you'd use opendir(3), readdir(3), and closedir(3) to read a directory.  They're portable (POSIX-compliant), and they insulate you from the details of the underlying system calls.  They're also easier to use, IMO.\n"], "rejected": ["\nls -1 | awk  -vpath=$PWD/ '{print path$1}'\n\n", "\nls -1 | awk  -vpath=$PWD/ '{print path$1}'\n\n", "\nls -1 | awk  -vpath=$PWD/ '{print path$1}'\n\n", "\nls -1 | awk  -vpath=$PWD/ '{print path$1}'\n\n", "\nls -1 | awk  -vpath=$PWD/ '{print path$1}'\n\n", "\nls -1 | awk  -vpath=$PWD/ '{print path$1}'\n\n", "\nls -1 | awk  -vpath=$PWD/ '{print path$1}'\n\n", "\nls -1 | awk  -vpath=$PWD/ '{print path$1}'\n\n", "\nls -1 | awk  -vpath=$PWD/ '{print path$1}'\n\n", "\nls -1 | awk  -vpath=$PWD/ '{print path$1}'\n\n", "\nls -1 | awk  -vpath=$PWD/ '{print path$1}'\n\n", "\nls -1 | awk  -vpath=$PWD/ '{print path$1}'\n\n", "\nls -1 | awk  -vpath=$PWD/ '{print path$1}'\n\n", "\nls -1 | awk  -vpath=$PWD/ '{print path$1}'\n\n", "\nls -1 | awk  -vpath=$PWD/ '{print path$1}'\n\n", "\nls -1 | awk  -vpath=$PWD/ '{print path$1}'\n\n", "\nls -1 | awk  -vpath=$PWD/ '{print path$1}'\n\n", "\nls -1 | awk  -vpath=$PWD/ '{print path$1}'\n\n", "\nls -1 | awk  -vpath=$PWD/ '{print path$1}'\n\n", "\nls -1 | awk  -vpath=$PWD/ '{print path$1}'\n\n", "\nls -1 | awk  -vpath=$PWD/ '{print path$1}'\n\n", "\nls -1 | awk  -vpath=$PWD/ '{print path$1}'\n\n", "\nls -1 | awk  -vpath=$PWD/ '{print path$1}'\n\n", "\nls -1 | awk  -vpath=$PWD/ '{print path$1}'\n\n", "\nls -1 | awk  -vpath=$PWD/ '{print path$1}'\n\n", "\nls -1 | awk  -vpath=$PWD/ '{print path$1}'\n\n", "\nls -1 | awk  -vpath=$PWD/ '{print path$1}'\n\n", "\nls -1 | awk  -vpath=$PWD/ '{print path$1}'\n\n", "\nI used for my csv, I hope it should help you too.\n\n$ bash\nbash-4.4$ ls *.csv | grep '^[Kk][Ss]*'\noutput: list of files\nLet's say, you want the count also of files and not just list them\nbash-4.4$ ls *.csv | grep '^[Kk][Ss]*'|wc -l\noutput: 42\nLet's say you want size of files\nbash-4.4$ ls -ls\n\n", "\nI used for my csv, I hope it should help you too.\n\n$ bash\nbash-4.4$ ls *.csv | grep '^[Kk][Ss]*'\noutput: list of files\nLet's say, you want the count also of files and not just list them\nbash-4.4$ ls *.csv | grep '^[Kk][Ss]*'|wc -l\noutput: 42\nLet's say you want size of files\nbash-4.4$ ls -ls\n\n", "\nI used for my csv, I hope it should help you too.\n\n$ bash\nbash-4.4$ ls *.csv | grep '^[Kk][Ss]*'\noutput: list of files\nLet's say, you want the count also of files and not just list them\nbash-4.4$ ls *.csv | grep '^[Kk][Ss]*'|wc -l\noutput: 42\nLet's say you want size of files\nbash-4.4$ ls -ls\n\n", "\nI used for my csv, I hope it should help you too.\n\n$ bash\nbash-4.4$ ls *.csv | grep '^[Kk][Ss]*'\noutput: list of files\nLet's say, you want the count also of files and not just list them\nbash-4.4$ ls *.csv | grep '^[Kk][Ss]*'|wc -l\noutput: 42\nLet's say you want size of files\nbash-4.4$ ls -ls\n\n", "\nI used for my csv, I hope it should help you too.\n\n$ bash\nbash-4.4$ ls *.csv | grep '^[Kk][Ss]*'\noutput: list of files\nLet's say, you want the count also of files and not just list them\nbash-4.4$ ls *.csv | grep '^[Kk][Ss]*'|wc -l\noutput: 42\nLet's say you want size of files\nbash-4.4$ ls -ls\n\n", "\nls -1 | grep '20061101-20131101_kh5x7tte9n_2010_*' | wc -l\n\nPrevious answer did not included quotes around search criteria neither * wildcard.\n", "\nls -1 | grep '20061101-20131101_kh5x7tte9n_2010_*' | wc -l\n\nPrevious answer did not included quotes around search criteria neither * wildcard.\n", "\nls -1 | grep '20061101-20131101_kh5x7tte9n_2010_*' | wc -l\n\nPrevious answer did not included quotes around search criteria neither * wildcard.\n", "\nls -1 | grep '20061101-20131101_kh5x7tte9n_2010_*' | wc -l\n\nPrevious answer did not included quotes around search criteria neither * wildcard.\n", "\nls -1 | grep '20061101-20131101_kh5x7tte9n_2010_*' | wc -l\n\nPrevious answer did not included quotes around search criteria neither * wildcard.\n", "\nls -1 | grep '20061101-20131101_kh5x7tte9n_2010_*' | wc -l\n\nPrevious answer did not included quotes around search criteria neither * wildcard.\n", "\nls -1 | grep '20061101-20131101_kh5x7tte9n_2010_*' | wc -l\n\nPrevious answer did not included quotes around search criteria neither * wildcard.\n", "\nBelow worked for me:\nrm -rf $(ll -t | tail -n +5 | awk '{ print $9}')\n", "\nBelow worked for me:\nrm -rf $(ll -t | tail -n +5 | awk '{ print $9}')\n", "\nBelow worked for me:\nrm -rf $(ll -t | tail -n +5 | awk '{ print $9}')\n", "\nBelow worked for me:\nrm -rf $(ll -t | tail -n +5 | awk '{ print $9}')\n", "\nBelow worked for me:\nrm -rf $(ll -t | tail -n +5 | awk '{ print $9}')\n", "\nBelow worked for me:\nrm -rf $(ll -t | tail -n +5 | awk '{ print $9}')\n", "\nBelow worked for me:\nrm -rf $(ll -t | tail -n +5 | awk '{ print $9}')\n", "\nBelow worked for me:\nrm -rf $(ll -t | tail -n +5 | awk '{ print $9}')\n", "\nBelow worked for me:\nrm -rf $(ll -t | tail -n +5 | awk '{ print $9}')\n", "\nBelow worked for me:\nrm -rf $(ll -t | tail -n +5 | awk '{ print $9}')\n", "\nQuoted from OS X ls man page :\n       b     Block special file.\n       c     Character special file.\n       d     Directory.\n       l     Symbolic link.\n       s     Socket link.\n       p     FIFO.\n       -     Regular file.\n\n", "\nfind . -exec file {} --mime-type \\; | grep \"audio\\|video\"\n\nmight do the trick. The mime type of my m4a files is video/mp4, so I need to grep for that as well.\n", "\nfind . -exec file {} --mime-type \\; | grep \"audio\\|video\"\n\nmight do the trick. The mime type of my m4a files is video/mp4, so I need to grep for that as well.\n", "\nfind . -exec file {} --mime-type \\; | grep \"audio\\|video\"\n\nmight do the trick. The mime type of my m4a files is video/mp4, so I need to grep for that as well.\n", "\nfind . -exec file {} --mime-type \\; | grep \"audio\\|video\"\n\nmight do the trick. The mime type of my m4a files is video/mp4, so I need to grep for that as well.\n", "\nfind . -exec file {} --mime-type \\; | grep \"audio\\|video\"\n\nmight do the trick. The mime type of my m4a files is video/mp4, so I need to grep for that as well.\n", "\nfind . -exec file {} --mime-type \\; | grep \"audio\\|video\"\n\nmight do the trick. The mime type of my m4a files is video/mp4, so I need to grep for that as well.\n", "\nTo list a directory's content, you have to have \"execute\" permission for that folder. And you don't have it for /usr/share/wordpress/ - only \"www-data\" user (not the group) does.\nYou don't have to make the file executable, just the directory. The following will help you:\n$sudo chmod -c 774 /usr/share/wordpress/\n\n", "\nIf you're using bash, you could enable the globstar shell option and use **/ to match zero or more subdirectories:\nshopt -s globstar # enable globstar\nls -lth **/*.txt\nshopt -u globstar # disable globstar\n\n", "\nYou have to use ls <dirname>. Plain ls defaults only to the current directory.\nWhat you are trying to do can be accomplished by find <dir> -name \"*.txt\" | grep -c txt or find <dir> -name \"*.txt\" | wc -l\nBut you can do ls * | grep \\.txt$ as well. Please read the manual to find the differences.\n", "\nYou can use the below command to display only the owner of a directory or a file.\nstat -c \"%U\" /path/of/the/file/or/directory\n\nIf you also want to print the group of a file or directory you can use %G as well.\nstat -c \"%U %G\" /path/of/the/file/or/directory\n\n", "\nYou can use the below command to display only the owner of a directory or a file.\nstat -c \"%U\" /path/of/the/file/or/directory\n\nIf you also want to print the group of a file or directory you can use %G as well.\nstat -c \"%U %G\" /path/of/the/file/or/directory\n\n", "\nYou can use the below command to display only the owner of a directory or a file.\nstat -c \"%U\" /path/of/the/file/or/directory\n\nIf you also want to print the group of a file or directory you can use %G as well.\nstat -c \"%U %G\" /path/of/the/file/or/directory\n\n", "\nIt's probably better to use getopt() for parameter parsing instead of writing your own parser.\n", "\nMore verbose strace dump\nPrevent strace from abbreviating arguments? teaches us how:\nstrace -v -s 99999 ls\n\nIf we create some distinctly named test files on an empty directory:\ntouch aaaaaaaaaaaaaaaaaaaa\ntouch bbbbbbbbbbbbbbbbbbbb\ntouch cccccccccccccccccccc\n\nand now search for aaaaaaaaaaaaaaaaaaaa on the output we see the following two hits (getdents64 manually indented by me):\ngetdents64(3, [\n    {d_ino=8328002, d_off=1, d_reclen=24, d_type=DT_DIR, d_name=\".\"},\n    {d_ino=1536544, d_off=2, d_reclen=24, d_type=DT_DIR, d_name=\"..\"},\n    {d_ino=8329332, d_off=358524250, d_reclen=40, d_type=DT_REG, d_name=\"cccccccccccccccccccc\"},\n    {d_ino=8329330, d_off=496322106, d_reclen=40, d_type=DT_REG, d_name=\"aaaaaaaaaaaaaaaaaaaa\"},\n    {d_ino=8329756, d_off=497914259, d_reclen=40, d_type=DT_REG, d_name=\"bbbbbbbbbbbbbbbbbbbb\"}\n], 131072) = 168\n\nwrite(1, \"aaaaaaaaaaaaaaaaaaaa  bbbbbbbbbbbbbbbbbbbb  cccccccccccccccccccc\\n\", 65aaaaaaaaaaaaaaaaaaaa  bbbbbbbbbbbbbbbbbbbb  cccccccccccccccccccc\n\nWe know that he write of course writes it to stdout, so it seems very likely that getdents64 is the one getting the names. Besides the three files we created, we also see that the special . and .. are also always present at the syscall level. Cool stuff.\nman getdents64 then confirms our suspicion. That page notably has a minimal sample code that heps quench any doubts.\nThe first argument of getdents64 was 3, which is a common number for the first file opened by a program (since 0, 1 and 2 are taken by stdin, stdout and stderr by default).\nBy searching above the getdents64 for the number 3 we see:\nclose(3)                                = 0\nopenat(AT_FDCWD, \".\", O_RDONLY|O_NONBLOCK|O_CLOEXEC|O_DIRECTORY) = 3\nnewfstatat(3, \"\", {st_dev=makedev(0, 0x27), st_ino=8328002, st_mode=S_IFDIR|0775, st_nlink=2, st_uid=1000, st_gid=1000, st_blksize=131072, st_blocks=18, st_size=5, st_atime=1665092404 /* 2022-10-06T22:40:04.155914251+0100 */, st_atime_nsec=155914251, st_mtime=1665092401 /* 2022-10-06T22:40:01.415910918+0100 */, st_mtime_nsec=415910918, st_ctime=1665092401 /* 2022-10-06T22:40:01.415910918+0100 */, st_ctime_nsec=415910918}, AT_EMPTY_PATH) = 0\ngetdents64(3,\n\nso we understand that:\n\nsomething else had 3 open, but then closed it\nopenat returned our 3 with input argument \".\", since we implicitly listed the current working directory with ls\nnewfstatat was used to get some metadata from it\ngetdents64 then used that descriptor\n\nStatic source code analysis\nLet's have some fun to hopefully confirm the stuff other answers said, i.e.:\n\ngetdents is the base syscall, or more precisely, getdents64 on an x86_64 system like mine\nopendir and readdir are convenience helpers\n\nGNU Coreutils is the most popular desktop implementation of ls, and the one I have on my Ubuntu 22.04 computer right now. We can find this with:\napt-file search '/usr/bin/ls'\n\nand we know that it is at version 8.32 according to dpkg -l | grep coreutils.\nHere's the file that implements it on a GitHub mirror: https://github.com/coreutils/coreutils/blob/v8.32/src/ls.c#L2972 slightly summarized:\nDIR *dirp;\nstruct dirent *next;\ndirp = opendir (name);\nwhile (1) {\n    next = readdir (dirp);\n    total_blocks += gobble_file (next->d_name, type,\n                                RELIABLE_D_INO (next),\n                                false, name);\n\nman readdir tells us that next->d_name is the basename of the entry.\ngobble_file then goes on to keep a list of entries, which is then printed at the end. This presumably has to be done because readdir does not return a deterministic order, and ls wants to print an ordered file list.\nThe functions opendir and readdir are implemented in most desktop systems in the glibc, which on my Ubuntu 22.04 is at version 2.35 according to dpkg -l | grep libc6.\nreadir is implemented at: https://github.com/bminor/glibc/blob/glibc-2.35/sysdeps/unix/sysv/linux/readdir.c#L42\nstruct dirent *\n__readdir_unlocked (DIR *dirp) {\n      bytes = __getdents (dirp->fd, dirp->data, maxread);\n}\nweak_alias (__readdir, readdir)\n\n__getdents is likely implemented at https://github.com/bminor/glibc/blob/glibc-2.35/sysdeps/unix/sysv/linux/getdents64.c\nssize_t\n__getdents64 (int fd, void *buf, size_t nbytes)\n{\n  /* The system call takes an unsigned int argument, and some length\n     checks in the kernel use an int type.  */\n  if (nbytes > INT_MAX)\n    nbytes = INT_MAX;\n  return INLINE_SYSCALL_CALL (getdents64, fd, buf, nbytes);\n}\nlibc_hidden_def (__getdents64)\nweak_alias (__getdents64, getdents64)\n\nINLINE_SYSCALL_CALL is defined at https://github.com/bminor/glibc/blob/glibc-2.35/sysdeps/unix/sysdep.h and likely (it is an infinitely deep sea of macros) ends up calling the x86_64 assembly syscall helper at https://github.com/bminor/glibc/blob/glibc-2.35/sysdeps/unix/sysv/linux/x86_64/syscall.S#L29 which places syscall arguments one by one on the correct registers.\nENTRY (syscall)\n    movq %rdi, %rax     /* Syscall number -> rax.  */\n    movq %rsi, %rdi     /* shift arg1 - arg5.  */\n    movq %rdx, %rsi\n    movq %rcx, %rdx\n    movq %r8, %r10\n    movq %r9, %r8\n    movq 8(%rsp),%r9    /* arg6 is on the stack.  */\n    syscall         /* Do the system call.  */\n    cmpq $-4095, %rax   /* Check %rax for error.  */\n    jae SYSCALL_ERROR_LABEL /* Jump to error handler if error.  */\n    ret         /* Return to caller.  */\n\nsome more comments: What are the calling conventions for UNIX & Linux system calls (and user-space functions) on i386 and x86-64\nAnd the syscall number itself appears to come from https://github.com/bminor/glibc/blob/glibc-2.35/sysdeps/unix/sysv/linux/x86_64/64/arch-syscall.h#L90\n#define __NR_getdents64 217\n\nFinally on the Linux kernel syscall table at https://github.com/torvalds/linux/blob/v5.15/arch/x86/entry/syscalls/syscall_64.tbl#L228 we can confirm that the syscall 217 is the one for getdents64:\n217 common  getdents64      sys_getdents64\n\nStep debug ls with debug symbols\nOn Ubuntu 22.04 as per https://askubuntu.com/questions/487222/how-to-install-debug-symbols-for-installed-packages\n# Get debug symbols.\nprintf \"deb http://ddebs.ubuntu.com %s main restricted universe multiverse\\n\" $(lsb_release -cs){,-updates,-security,-proposed} | \\\n sudo tee -a /etc/apt/sources.list.d/ddebs.list\nsudo apt install ubuntu-dbgsym-keyring\nsudo apt update\nsudo apt install coreutils-dbgsym\n\n# Get source.\napt source coreutils\n\n# Alternative less precise way to get sources.\n# git clone --depth 1 --branch v8.32 https://github.com/coreutils/coreutils\n\n# Run ls pointing to the downloaded source.\ngdb -ex 'set substitute-path . /home/ciro/git/coreutils/coreutils-8.32/' ls\n\nUpon starting on main:\nstart\n\nwe are at src/ls.c as expected.\nWe try:\nbreak readdir\ncontinue\n\nbut only to notice that we don't have glibc sources!\n../sysdeps/unix/sysv/linux/readdir64.c: No such file or directory.\n\nSo we get them:\napt source libc6\n\nand then on GDB:\nset substitute-path .. /home/ciro/git/coreutils/glibc-2.35\n\nWe use .. here to match the weird ../sysdeps/unix/sysv/linux/readdir64.c with which symbols were compiled.\nOK, so now we are at sysdeps/unix/sysv/linux/readdir64.c:\nstruct dirent64 *\n__readdir64 (DIR *dirp)\n\nAnd so on.\n", "\nMore verbose strace dump\nPrevent strace from abbreviating arguments? teaches us how:\nstrace -v -s 99999 ls\n\nIf we create some distinctly named test files on an empty directory:\ntouch aaaaaaaaaaaaaaaaaaaa\ntouch bbbbbbbbbbbbbbbbbbbb\ntouch cccccccccccccccccccc\n\nand now search for aaaaaaaaaaaaaaaaaaaa on the output we see the following two hits (getdents64 manually indented by me):\ngetdents64(3, [\n    {d_ino=8328002, d_off=1, d_reclen=24, d_type=DT_DIR, d_name=\".\"},\n    {d_ino=1536544, d_off=2, d_reclen=24, d_type=DT_DIR, d_name=\"..\"},\n    {d_ino=8329332, d_off=358524250, d_reclen=40, d_type=DT_REG, d_name=\"cccccccccccccccccccc\"},\n    {d_ino=8329330, d_off=496322106, d_reclen=40, d_type=DT_REG, d_name=\"aaaaaaaaaaaaaaaaaaaa\"},\n    {d_ino=8329756, d_off=497914259, d_reclen=40, d_type=DT_REG, d_name=\"bbbbbbbbbbbbbbbbbbbb\"}\n], 131072) = 168\n\nwrite(1, \"aaaaaaaaaaaaaaaaaaaa  bbbbbbbbbbbbbbbbbbbb  cccccccccccccccccccc\\n\", 65aaaaaaaaaaaaaaaaaaaa  bbbbbbbbbbbbbbbbbbbb  cccccccccccccccccccc\n\nWe know that he write of course writes it to stdout, so it seems very likely that getdents64 is the one getting the names. Besides the three files we created, we also see that the special . and .. are also always present at the syscall level. Cool stuff.\nman getdents64 then confirms our suspicion. That page notably has a minimal sample code that heps quench any doubts.\nThe first argument of getdents64 was 3, which is a common number for the first file opened by a program (since 0, 1 and 2 are taken by stdin, stdout and stderr by default).\nBy searching above the getdents64 for the number 3 we see:\nclose(3)                                = 0\nopenat(AT_FDCWD, \".\", O_RDONLY|O_NONBLOCK|O_CLOEXEC|O_DIRECTORY) = 3\nnewfstatat(3, \"\", {st_dev=makedev(0, 0x27), st_ino=8328002, st_mode=S_IFDIR|0775, st_nlink=2, st_uid=1000, st_gid=1000, st_blksize=131072, st_blocks=18, st_size=5, st_atime=1665092404 /* 2022-10-06T22:40:04.155914251+0100 */, st_atime_nsec=155914251, st_mtime=1665092401 /* 2022-10-06T22:40:01.415910918+0100 */, st_mtime_nsec=415910918, st_ctime=1665092401 /* 2022-10-06T22:40:01.415910918+0100 */, st_ctime_nsec=415910918}, AT_EMPTY_PATH) = 0\ngetdents64(3,\n\nso we understand that:\n\nsomething else had 3 open, but then closed it\nopenat returned our 3 with input argument \".\", since we implicitly listed the current working directory with ls\nnewfstatat was used to get some metadata from it\ngetdents64 then used that descriptor\n\nStatic source code analysis\nLet's have some fun to hopefully confirm the stuff other answers said, i.e.:\n\ngetdents is the base syscall, or more precisely, getdents64 on an x86_64 system like mine\nopendir and readdir are convenience helpers\n\nGNU Coreutils is the most popular desktop implementation of ls, and the one I have on my Ubuntu 22.04 computer right now. We can find this with:\napt-file search '/usr/bin/ls'\n\nand we know that it is at version 8.32 according to dpkg -l | grep coreutils.\nHere's the file that implements it on a GitHub mirror: https://github.com/coreutils/coreutils/blob/v8.32/src/ls.c#L2972 slightly summarized:\nDIR *dirp;\nstruct dirent *next;\ndirp = opendir (name);\nwhile (1) {\n    next = readdir (dirp);\n    total_blocks += gobble_file (next->d_name, type,\n                                RELIABLE_D_INO (next),\n                                false, name);\n\nman readdir tells us that next->d_name is the basename of the entry.\ngobble_file then goes on to keep a list of entries, which is then printed at the end. This presumably has to be done because readdir does not return a deterministic order, and ls wants to print an ordered file list.\nThe functions opendir and readdir are implemented in most desktop systems in the glibc, which on my Ubuntu 22.04 is at version 2.35 according to dpkg -l | grep libc6.\nreadir is implemented at: https://github.com/bminor/glibc/blob/glibc-2.35/sysdeps/unix/sysv/linux/readdir.c#L42\nstruct dirent *\n__readdir_unlocked (DIR *dirp) {\n      bytes = __getdents (dirp->fd, dirp->data, maxread);\n}\nweak_alias (__readdir, readdir)\n\n__getdents is likely implemented at https://github.com/bminor/glibc/blob/glibc-2.35/sysdeps/unix/sysv/linux/getdents64.c\nssize_t\n__getdents64 (int fd, void *buf, size_t nbytes)\n{\n  /* The system call takes an unsigned int argument, and some length\n     checks in the kernel use an int type.  */\n  if (nbytes > INT_MAX)\n    nbytes = INT_MAX;\n  return INLINE_SYSCALL_CALL (getdents64, fd, buf, nbytes);\n}\nlibc_hidden_def (__getdents64)\nweak_alias (__getdents64, getdents64)\n\nINLINE_SYSCALL_CALL is defined at https://github.com/bminor/glibc/blob/glibc-2.35/sysdeps/unix/sysdep.h and likely (it is an infinitely deep sea of macros) ends up calling the x86_64 assembly syscall helper at https://github.com/bminor/glibc/blob/glibc-2.35/sysdeps/unix/sysv/linux/x86_64/syscall.S#L29 which places syscall arguments one by one on the correct registers.\nENTRY (syscall)\n    movq %rdi, %rax     /* Syscall number -> rax.  */\n    movq %rsi, %rdi     /* shift arg1 - arg5.  */\n    movq %rdx, %rsi\n    movq %rcx, %rdx\n    movq %r8, %r10\n    movq %r9, %r8\n    movq 8(%rsp),%r9    /* arg6 is on the stack.  */\n    syscall         /* Do the system call.  */\n    cmpq $-4095, %rax   /* Check %rax for error.  */\n    jae SYSCALL_ERROR_LABEL /* Jump to error handler if error.  */\n    ret         /* Return to caller.  */\n\nsome more comments: What are the calling conventions for UNIX & Linux system calls (and user-space functions) on i386 and x86-64\nAnd the syscall number itself appears to come from https://github.com/bminor/glibc/blob/glibc-2.35/sysdeps/unix/sysv/linux/x86_64/64/arch-syscall.h#L90\n#define __NR_getdents64 217\n\nFinally on the Linux kernel syscall table at https://github.com/torvalds/linux/blob/v5.15/arch/x86/entry/syscalls/syscall_64.tbl#L228 we can confirm that the syscall 217 is the one for getdents64:\n217 common  getdents64      sys_getdents64\n\nStep debug ls with debug symbols\nOn Ubuntu 22.04 as per https://askubuntu.com/questions/487222/how-to-install-debug-symbols-for-installed-packages\n# Get debug symbols.\nprintf \"deb http://ddebs.ubuntu.com %s main restricted universe multiverse\\n\" $(lsb_release -cs){,-updates,-security,-proposed} | \\\n sudo tee -a /etc/apt/sources.list.d/ddebs.list\nsudo apt install ubuntu-dbgsym-keyring\nsudo apt update\nsudo apt install coreutils-dbgsym\n\n# Get source.\napt source coreutils\n\n# Alternative less precise way to get sources.\n# git clone --depth 1 --branch v8.32 https://github.com/coreutils/coreutils\n\n# Run ls pointing to the downloaded source.\ngdb -ex 'set substitute-path . /home/ciro/git/coreutils/coreutils-8.32/' ls\n\nUpon starting on main:\nstart\n\nwe are at src/ls.c as expected.\nWe try:\nbreak readdir\ncontinue\n\nbut only to notice that we don't have glibc sources!\n../sysdeps/unix/sysv/linux/readdir64.c: No such file or directory.\n\nSo we get them:\napt source libc6\n\nand then on GDB:\nset substitute-path .. /home/ciro/git/coreutils/glibc-2.35\n\nWe use .. here to match the weird ../sysdeps/unix/sysv/linux/readdir64.c with which symbols were compiled.\nOK, so now we are at sysdeps/unix/sysv/linux/readdir64.c:\nstruct dirent64 *\n__readdir64 (DIR *dirp)\n\nAnd so on.\n"]}