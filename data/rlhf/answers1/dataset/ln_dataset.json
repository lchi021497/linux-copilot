{"prompt": ["I'm trying to do my own command (test.sh script). The script works perfect and I created a soft link (i.e., ln -s /home/test.sh ~/bin/test).And when I call from anywhere inside RHEL, it also works perfectly.But my problem is the next one: When from the command line I'm writing the name of the command (test), and I press the Tab key, the system shows me the full path and name of my script, i.e., $ /home/bin/test, and I want that it only shows me the name of the command ($ test).Is that possible? How can I do it?", "I just created a symlink to a directory using:ln -s /path/to/real/ link\n1 - If I then cd into link/ will any changes I make in there be reflected in the original directory?2 - Additionally, the source directory is a git repo, so can I do the git commands from the symlink'ed directory?3 - These answers and any general explanation about the differences between sym/hard links (or ln in general) would rock. Thank you!  ", "Where my question originated:\nWhen running cp source/files.all destination/, all the files within source will now also exist in destination\nQuestion:\nWhat if I didn't want to duplicate the data from source into destination, but simply link them (with absolute path). Usually, I would run something like:\nfor f in $(ls source/); do ln -s $(pwd)/${f} $(pwd)/destination; done\nIs there a simple command/tool that I can use (e.g. ln -a source/files.all destination/) which would create a softlink to all files in a directory, while automatically adding the absolute path as prefix. ln -r is close to what I need, but the absolute path, not the relative one?\n"], "chosen": ["\nWhat you need is an alias. In RHEL/CENTOS systems, perform the below steps\n\nvi ~/.bashrc \nadd this line alias test='/home/test.sh'\nsource ~/.bashrc (optional step, unless you want your current session to have the updated bashrc, else a restart/logout/login should not require this step!)\n\n", "\nWhen you do cd link/, your current directory becomes /path/to/real and any changes you make in the directory are in 'the real directory'.\nBeware of cd -L vs cd -P \u2014 see POSIX on cd \u2014 and similarly with pwd.\n", "\nSo I eventually sort of found a simple way to do this:\nSimply run ln -s $(pwd -P)/source/* destination/\n"], "rejected": ["\nIf you want to make your own commands and have them tab-complete without browsing to their directory you would begin by looking at your $PATH variable\necho $PATH\nThis should return a list of variables in your current path\nif you want to edit your path click here\nI may suggest a common place location for your link in /usr/bin\nCertain distributions will often include ~/bin in their $PATH, using this location may or may not explain why your tab-complete is completing the full and not just the command\nln -s /home/test.sh /usr/bin/test\nAlso, you may want to consider as a personal preference utilizing the /opt directory to keep things organised, for example\nln -s /opt/scripts/test.sh /usr/bin/test\n", "\nSymbolic links work just like another name for the original directory. They are different from hard links because if you replace the original file with a new one of the same name, the symbolic link points to the new file. A hard link would still be linked to the original file, no matter what name it had.\nA symbolic link can \"dangle\" which means that it's target is no longer there. A hard link cannot.\nA directory cannot be hard-linked. In the past that was allowed but it creates the possibility of directory loops, and this is a bad thing.\nYes if you cd symlink you can do anything that you want, just as if you were in the actual directory, because you are in the actual directory. Your shell, depending on its configuration settings, will allow you to think you're in the symlink named directory, but all of the operating system functions will return the actual directory names.\n", "\nI would use find \"$PWD/source\" -exec ln -s {} destination \\;. The absolute path used as the first argument to find will cause {} to be replaced by an absolute path to the source file for each command.\nGNU ln supports the -t option to specify the destination directory, allowing you to use a more efficient invocation of find:\nfind \"$PWD/source\" -exec ln -s -t destination {} +\n\nThe -exec ... + form requires {} to be the last argument in the command; -t lets you move the destination argument up to accommodate that requirement.\n"]}