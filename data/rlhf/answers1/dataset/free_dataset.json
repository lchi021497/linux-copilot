{"prompt": ["I'm currently building an assembler as a project and I'm on the verge of finishing it. I created  different linked-lists to implement different functions in the assembler, and now I'm trying to build 'free()' functions for each and every linked-list I created. Here is the node structure:typedef struct symbol_node_t\n{\n    struct symbol_node_t* next; /* the next node in the linked-list */\n    char            name[32]; /* name of the node */\n    int             value; /* address (either Instruction counter or Data counter) */\n    enum symbol_attributes attr; /* CODE/DATA/ENTRY/EXTERNAL */\n\n} symbol_node_t;\nnow, I created global heads:struct symbol_node_t* symbol_head = NULL; /* this is the head of one linked-list */\nstruct symbol_node_t* external_head = NULL; /* this is the head of a different linked-list */\nthen, implemented them throughout the whole project. I wrote free() function for the first linked-list ('symbol_head' linked-list) which works well, here it is:void free_symbols()\n{\n  while(symbol_head != NULL)\n   {\n    free(symbol_head);\n    symbol_head = symbol_head->next;\n   }\n}\nbut for a very odd reason, the same function for 'external_head' doesn't work:void free_externals()\n{\n    while(external_head != NULL)\n    {\n        free(external_head);\n        external_head = external_head->next;\n    }\n}\nwhenever it gets there - it writes the following error message:[SYMBOL TABLE]\nname[END]        value[148]      sym_attributes[CODE] has_next[1]\nname[K]          value[161]      sym_attributes[DATA, ENTRY] has_next[1]\nname[val1]       value[0]        sym_attributes[EXTERNAL] has_next[1]\nname[LIST]       value[157]      sym_attributes[DATA] has_next[1]\nname[Next]       value[116]      sym_attributes[CODE, ENTRY] has_next[1]\nname[LOOP]       value[104]      sym_attributes[CODE] has_next[1]\nname[MAIN]       value[100]      sym_attributes[CODE] has_next[1]\nname[STR]        value[152]      sym_attributes[DATA] has_next[1]\nname[wNumber]    value[0]        sym_attributes[EXTERNAL] has_next[0]\nsymbols size: 9\n*** Error in `./asm': munmap_chunk(): invalid pointer: 0x0000000000b31c60 ***\n======= Backtrace: =========\n/lib/x86_64-linux-gnu/libc.so.6(+0x777f5)[0x7f8c7aaa77f5]\n/lib/x86_64-linux-gnu/libc.so.6(cfree+0x1a8)[0x7f8c7aab46e8]\n./asm[0x403183]\n./asm[0x400e72]\n/lib/x86_64-linux-gnu/libc.so.6(__libc_start_main+0xf0)[0x7f8c7aa50840]\n./asm[0x400a59]\n======= Memory map: ========\n00400000-00404000 r-xp 00000000 00:00 396017                     /home/chad/asm/asm\n00404000-00405000 r-xp 00004000 00:00 396017                     /home/chad/asm/asm\n00604000-00605000 r--p 00004000 00:00 396017                     /home/chad/asm/asm\n00605000-00606000 rw-p 00005000 00:00 396017                     /home/chad/asm/asm\n00b30000-00b51000 rw-p 00000000 00:00 0                          [heap]\n7f8c7a810000-7f8c7a826000 r-xp 00000000 00:00 159188             /lib/x86_64-linux-gnu/libgcc_s.so.1\n7f8c7a826000-7f8c7aa25000 ---p 00016000 00:00 159188             /lib/x86_64-linux-gnu/libgcc_s.so.1\n7f8c7aa25000-7f8c7aa26000 rw-p 00015000 00:00 159188             /lib/x86_64-linux-gnu/libgcc_s.so.1\n7f8c7aa30000-7f8c7abf0000 r-xp 00000000 00:00 204371             /lib/x86_64-linux-gnu/libc-2.23.so\n7f8c7abf0000-7f8c7abf9000 ---p 001c0000 00:00 204371             /lib/x86_64-linux-gnu/libc-2.23.so\nFrom what I understand, the issue is with the pointer, but it is weird that 2 of these heads are implemented in the same way, yet in symbol_head, it works perfectly fine and in external_head, it just gives this error. Can you help me out finding what could be the issue here please? I thank you all in advance!", "Often in projects, complex structures are used, e.g., like the one below:struct opts {\n    char* server;\n    char* port;\n    int protocol;\n    void* protocol_data;\n};\nAnd to free such structures, till today I adopted the routines as below:void free_proto1(struct opts* opt);\nvoid free_proto2(struct opts* opt);\n\nvoid free_opts(struct opts** opt) {\n\n    free((*opt)->server);\n    free((*opt)->port);\n\n    if ((*opt)->protocol == PROTOCOL1) {\n        free_proto1(*opt);\n    }\n    else if ((*opt)->protocol == PROTOCOL2) {\n        free_proto2(*opt);\n    }\n    else\n        free((*opt)->protocol_data);\n\n    free(*opt);\n    *opt = NULL;\n}\nBut If I have another struct opts pointer like struct opts* opts2 = opts1, another call to free_opts(&opt2) after calling free_opts(&opt1) would definitely result in a program crash. I know a good habit of coding is to avoid such calls. But is there by any chance, I could detect that the memory is already freed? I am interested in even looking into Process Control Block (That is where I think all the program information resides). Can I scrutinize the PCB structures, before performing a free()'ing operations, so that I can avoid free()'ing the memory twice? ", "Often in projects, complex structures are used, e.g., like the one below:struct opts {\n    char* server;\n    char* port;\n    int protocol;\n    void* protocol_data;\n};\nAnd to free such structures, till today I adopted the routines as below:void free_proto1(struct opts* opt);\nvoid free_proto2(struct opts* opt);\n\nvoid free_opts(struct opts** opt) {\n\n    free((*opt)->server);\n    free((*opt)->port);\n\n    if ((*opt)->protocol == PROTOCOL1) {\n        free_proto1(*opt);\n    }\n    else if ((*opt)->protocol == PROTOCOL2) {\n        free_proto2(*opt);\n    }\n    else\n        free((*opt)->protocol_data);\n\n    free(*opt);\n    *opt = NULL;\n}\nBut If I have another struct opts pointer like struct opts* opts2 = opts1, another call to free_opts(&opt2) after calling free_opts(&opt1) would definitely result in a program crash. I know a good habit of coding is to avoid such calls. But is there by any chance, I could detect that the memory is already freed? I am interested in even looking into Process Control Block (That is where I think all the program information resides). Can I scrutinize the PCB structures, before performing a free()'ing operations, so that I can avoid free()'ing the memory twice? ", "Often in projects, complex structures are used, e.g., like the one below:struct opts {\n    char* server;\n    char* port;\n    int protocol;\n    void* protocol_data;\n};\nAnd to free such structures, till today I adopted the routines as below:void free_proto1(struct opts* opt);\nvoid free_proto2(struct opts* opt);\n\nvoid free_opts(struct opts** opt) {\n\n    free((*opt)->server);\n    free((*opt)->port);\n\n    if ((*opt)->protocol == PROTOCOL1) {\n        free_proto1(*opt);\n    }\n    else if ((*opt)->protocol == PROTOCOL2) {\n        free_proto2(*opt);\n    }\n    else\n        free((*opt)->protocol_data);\n\n    free(*opt);\n    *opt = NULL;\n}\nBut If I have another struct opts pointer like struct opts* opts2 = opts1, another call to free_opts(&opt2) after calling free_opts(&opt1) would definitely result in a program crash. I know a good habit of coding is to avoid such calls. But is there by any chance, I could detect that the memory is already freed? I am interested in even looking into Process Control Block (That is where I think all the program information resides). Can I scrutinize the PCB structures, before performing a free()'ing operations, so that I can avoid free()'ing the memory twice? ", "I just want to add a timestamp to a script output file, and also continue to add output to the same file.This is the script im using and want to add a timestamp in the output file and want to be able to add entries to the same file over and over again. I would also need to see the timestamp for each entry. free | grep mem | awk '{print $4/$2 * 100.0}' > free.txt\n\nfree | grep mem | awk '{print $4/$2 * 100.0}' > free.txt\nThe results of the script currently is that i can save the output of a single query but it doesnt have a timestamp, and I dont know how to make it recurring output to the same file for a specific amount of time. Ideally i would make the script run in 5 minute intervals for a week, and then start a new file. I'm not sure if this is even possible. The end result would show a list of free memory percentages over the entire week, so I could see the trends in memory usage and monitor for oversubscription of memory.", "In my application I allocated memory for my variable (unsigned char*) using malloc(), when try to deallocate that memory in destructor I use this condition to avoid double corruption.unsigned char *wsqData;\nwsqData= (unsigned  char *)malloc( 10000*sizeof( unsigned char));\nin my destructor  if(wsqData!=NULL)\n  {\n      free(wsqData);\n      wsqData=NULL;\n  } \nnow the problem is when I freed the memory before my destructor,this \"if condition \" could not working properly ,it once again try to free that variable it cause double corruption error. What is the problem in this scenario?", "In my application I allocated memory for my variable (unsigned char*) using malloc(), when try to deallocate that memory in destructor I use this condition to avoid double corruption.unsigned char *wsqData;\nwsqData= (unsigned  char *)malloc( 10000*sizeof( unsigned char));\nin my destructor  if(wsqData!=NULL)\n  {\n      free(wsqData);\n      wsqData=NULL;\n  } \nnow the problem is when I freed the memory before my destructor,this \"if condition \" could not working properly ,it once again try to free that variable it cause double corruption error. What is the problem in this scenario?", "In my application I allocated memory for my variable (unsigned char*) using malloc(), when try to deallocate that memory in destructor I use this condition to avoid double corruption.unsigned char *wsqData;\nwsqData= (unsigned  char *)malloc( 10000*sizeof( unsigned char));\nin my destructor  if(wsqData!=NULL)\n  {\n      free(wsqData);\n      wsqData=NULL;\n  } \nnow the problem is when I freed the memory before my destructor,this \"if condition \" could not working properly ,it once again try to free that variable it cause double corruption error. What is the problem in this scenario?", "I would like to implement a main function such as in order to execute system commands. The following code is currently used :  int main(int argc, char *argv[])\n{\n   size_t cmd_length;\n   char *cmd_buffer = NULL; \n   char *file = NULL;\n   char *ip = NULL;\n   int size;\n\n   if(argc == 3)\n   {\n       size = strlen(argv[1]);\n       file = (char*)malloc((size + 1)*sizeof(char));\n       strcpy(file, argv[1]);       \n       size = strlen(argv[2]);\n       ip = (char*)malloc((size + 1)*sizeof(char));     \n       strcpy(ip, argv[2]);     \n   }\n\n   cmd_length = snprintf(NULL, 0, \"tftp -g -r %s %s\", file, ip);\n   cmd_buffer = malloc(cmd_length + 1);\n   if (cmd_buffer == NULL) \n   {\n       return -1; \n   }\n   snprintf(cmd_buffer, cmd_length + 1, \"tftp -g -r %s %s\", file, ip);\n   if(system(cmd_buffer) == 0) \n   {\n      then ...\n   }\n   {\n      return -1;\n   }\n\n   free(cmd_buffer);\n   cmd_buffer = NULL;\n\n   cmd_length = snprintf(NULL, 0, \"tftp -g -r %s %s\", DFT_FILE, DFT_IP);\n   cmd_buffer = malloc(cmd_length + 1);\n   if (cmd_buffer == NULL) \n   {\n       return -1; \n   }\n   snprintf(cmd_buffer, cmd_length + 1, \"tftp -g -r %s %s\", DFT_FILE, DFT_IP);\n   if(system(cmd_buffer) == 0) \n   {\n      then ...\n   }\n   {\n      return -1;\n   }\n\n   free(cmd_buffer);\n   free(file);\n   free(ip);\n   cmd_buffer = NULL;\n   file = NULL;\n   ip = NULL;\n   return 0;\n}\nBecause I need to enter other commands, I am currently using the same cmd_buffer by using free() before reallocating memory. Is it the right way to do ? Some other commands might be required in the future."], "chosen": ["\nBoth of your free functions are subject to undefined behavior, because they attempt to access fields of structures after those structures have been freed.  For example, free_symbols looks like this:\nvoid free_symbols()\n{\n  while(symbol_head != NULL)\n   {\n    free(symbol_head);\n    symbol_head = symbol_head->next;\n   }\n}\n\nAfter the call to free, symbol_head points to freed memory whose contents are undefined, so the reference symbol_head->next is subject to undefined behavior.\nTo fix it, save the next field before freeing the structure:\nvoid free_symbols(void)\n{\n  while(symbol_head != NULL)\n   {\n    struct symbol_node_t *next = symbol_head->next;\n    free(symbol_head);\n    symbol_head = next;\n   }\n}\n\nThe same change is needed in free_externals:\nvoid free_externals(void)\n{\n    while(external_head != NULL)\n    {\n        struct symbol_node_t *next = external_head->next;\n        free(external_head);\n        external_head = next;\n    }\n}\n\n", "\nYou could use a reference counted API, ie: adding a size_t refs field to your struct, and then add a \nstruct opts* ref_opts(struct opts* opt)\n\nAPI that will increase ref counter and return opt; finally, renaming free_opts to unref_opts() and only actually free your structure when refs field is 0.  \nThis will expose a known API to take a structure reference and to free it, in a very homogeneous way; it will be users' fault if they do not use it.\n", "\nWhen freeing set the pointer to the known invalid value - usually NULL.\nThen even if you free more than one time - free ignores NULL pointers.\n", "\nUnfortunately, C has no support for smart pointers like f.e. C++ has.\nIn C, you always have to be careful to not cause memory leaks. \n\nAnyway, You can f.e. provide another parameter in the manner of reference counting. This has the downside that you need to pass the amount of reference pointers to the allocated memory as argument everytime you call free_opts and the amount have to be fixed, but it is an approach to help you out.\nThe memory is only freed, if all references have been \"pseudo-freed\". \nAll passed reference pointers, except the last one, are just made a null pointer and the pointed memory is in fact not freed until the last reference pointer has been past.\nint free_opts (struct opts** opt, int ref) {\n\n    static int cnt = 0; \n    cnt++;\n\n    if ( cnt != ref ) {        \n        *opt = NULL;\n        return 0;\n    }\n\n    free((*opt)->server);\n    free((*opt)->port);\n\n    if ((*opt)->protocol == PROTOCOL1) {\n        free_proto1(*opt);\n    }\n    else if ((*opt)->protocol == PROTOCOL2) {\n        free_proto2(*opt);\n    }\n    else\n        free((*opt)->protocol_data);\n\n    free(*opt);\n    return 1;\n}\n\nWhether the memory is actually freed or not, is indicated by the return value.\n", "\nYou could conceivably use a loop with a sleep-timer, but I'd recommend using a cron job for this.  Put the following in a shell script, and run that via cron every 5 minutes.\n( echo -ne \"$( date -Iseconds)\\t\"; free | awk '/Mem/{print $4/$2 * 100.0}' ) >> free.tx\n\n", "\nYou would need to set wsqData to NULL at the point when you free the memory outside of destructor. But in C++ you should use new and delete. And try to avoid freeing memory anywhere except in the destructor.\n", "\nAs others denoted, you also need to set to NULL each time you free it. Make it a function - free the var then set it to NULL, and call it from both the destructor and any place in the program. \n", "\nCalling free on the memory doesn't automatically set your pointer to NULL, so your condition is pointless. You need to set wsqData to NULL wherever you free it.\nOf course the condition is pointless anyway, since calling free on a NULL pointer is guaranteed to be safe.\n", "\nYour program can be be greatly simplified if you use a common function to execute the system call.  It doesn't even need to use malloc at all.  Here's a partial implementation [Please pardon the gratuitous style cleanup]:\n#include <stdarg.h>\n\nint\nexecute_command(const char *fmt,...)\n{\n    char cmd_buffer[5000];\n    int cmd_length;\n    va_list ap;\n\n    // NOTE: much simpler to used a fixed size buffer that is larger than\n    // needed\n\n    va_start(ap,fmt);\n    cmd_length = vsnprintf(cmd_buffer,sizeof(cmd_buffer),fmt,ap);\n    va_end(ap);\n\n    if (system(cmd_buffer) != 0)\n        return -1;\n\n    return 0;\n}\n\nint\nmain(int argc, char *argv[])\n{\n    char *file = NULL;\n    char *ip = NULL;\n\n    // NOTE: I had to guess the intent if fewer arguments are passed (e.g. just\n    // skip as I did here, print message and abort?)\n    if (argc == 3) {\n        // NOTE: no need to malloc these, but if you did, see strdup(3)\n        file = argv[1];\n        ip = argv[2];\n\n        execute_command(\"tftp -g -r %s %s\", file, ip);\n    }\n\n    execute_command(\"tftp -g -r %s %s\", DFT_FILE, DFT_IP);\n\n    return 0;\n}\n\n"], "rejected": ["\nRight now free_symbols and free_externals first call free and then dereference the free'd object, making your program have undefined behavior. You need to first  get the next pointer, then free.\nExample:\nvoid symbol_node_free(symbol_node_t** head_ptr) {    \n    for(symbol_node_t* next; *head_ptr; *head_ptr = next) {\n        next = (*head_ptr)->next;\n        free(*head_ptr);\n    }\n}\n\nvoid free_symbols() { symbol_node_free(&symbol_head); }\nvoid free_externals() { symbol_node_free(&external_head); }\n\n", "\n@RobertSsupportsMonicaCellio and @Federico suggested some reliable methods of preventing the memory free'ing twice. But I feel like the suggestion made by @vll should not be lost in the comments, thus I am summarizing the poster suggestion as an answer. \nAnother reliable way of keeping track of the pointers is to maintain a list of the allocated addresses, and free them only when they are on the list. Below is the bare minimal implementation:\n#include \"list.h\"\n\nstatic struct list addr_list;\n\nstruct opts* create_opts(void) {\n\n    struct opts* opts = (struct opts*) calloc(1, sizeof(struct opts));\n\n    if (opts == NULL)\n        return NULL;\n\n    /* Initialize the opts{} */\n\n    list_append(&addr_list, opts);\n\n    return opts;\n}\n\nint free_opts(struct opts* opts) {\n\n    if (in_list(&addr_list, opts) == false)\n        return 0;\n\n    /* Free the opts{} */\n\n    list_remove(&addr_list, opts);\n\n    return 1;\n}\n\nOf course, the above implementation simply turns down the request of freeing the structs, which are not created using create_opts(). A partial solution to that can be using flags to enable force cleaning as such. But I hope, someone if at all it is possible will come with some concrete answer.\nThanks to everyone for all the valuable suggestions :) \n", "\n@RobertSsupportsMonicaCellio and @Federico suggested some reliable methods of preventing the memory free'ing twice. But I feel like the suggestion made by @vll should not be lost in the comments, thus I am summarizing the poster suggestion as an answer. \nAnother reliable way of keeping track of the pointers is to maintain a list of the allocated addresses, and free them only when they are on the list. Below is the bare minimal implementation:\n#include \"list.h\"\n\nstatic struct list addr_list;\n\nstruct opts* create_opts(void) {\n\n    struct opts* opts = (struct opts*) calloc(1, sizeof(struct opts));\n\n    if (opts == NULL)\n        return NULL;\n\n    /* Initialize the opts{} */\n\n    list_append(&addr_list, opts);\n\n    return opts;\n}\n\nint free_opts(struct opts* opts) {\n\n    if (in_list(&addr_list, opts) == false)\n        return 0;\n\n    /* Free the opts{} */\n\n    list_remove(&addr_list, opts);\n\n    return 1;\n}\n\nOf course, the above implementation simply turns down the request of freeing the structs, which are not created using create_opts(). A partial solution to that can be using flags to enable force cleaning as such. But I hope, someone if at all it is possible will come with some concrete answer.\nThanks to everyone for all the valuable suggestions :) \n", "\n@RobertSsupportsMonicaCellio and @Federico suggested some reliable methods of preventing the memory free'ing twice. But I feel like the suggestion made by @vll should not be lost in the comments, thus I am summarizing the poster suggestion as an answer. \nAnother reliable way of keeping track of the pointers is to maintain a list of the allocated addresses, and free them only when they are on the list. Below is the bare minimal implementation:\n#include \"list.h\"\n\nstatic struct list addr_list;\n\nstruct opts* create_opts(void) {\n\n    struct opts* opts = (struct opts*) calloc(1, sizeof(struct opts));\n\n    if (opts == NULL)\n        return NULL;\n\n    /* Initialize the opts{} */\n\n    list_append(&addr_list, opts);\n\n    return opts;\n}\n\nint free_opts(struct opts* opts) {\n\n    if (in_list(&addr_list, opts) == false)\n        return 0;\n\n    /* Free the opts{} */\n\n    list_remove(&addr_list, opts);\n\n    return 1;\n}\n\nOf course, the above implementation simply turns down the request of freeing the structs, which are not created using create_opts(). A partial solution to that can be using flags to enable force cleaning as such. But I hope, someone if at all it is possible will come with some concrete answer.\nThanks to everyone for all the valuable suggestions :) \n", "\n(date \"+%c\" | tr -d '\\n'; free | awk '/^Mem:/ {print \" \", ($4/$2 * 100.0}') > free.txt\n\nOr whatever. I hate tr, but it's the fatest way to strip newlinws. Other time formats can be found in date's manpages (not Mac, of course). In that case, google google.\nAlso you don't need grep here, and you're performing a case-sensitive search anyway, which is bad because the output of free usually creates /^Mem:.*$/\n", "\nFYI: This is a classic example of a dangling pointer. You would need to set wsqData to NULL as suggested.\n", "\nFYI: This is a classic example of a dangling pointer. You would need to set wsqData to NULL as suggested.\n", "\nFYI: This is a classic example of a dangling pointer. You would need to set wsqData to NULL as suggested.\n", "\nYes, you are essentially just re-using the pointer variable cmd_buffer which is fine. And for every malloc() there is a matching free(), which is good.\nYou should factor our common code into a function, for example runCommand(const char *command, ...) (using varargs).\n"]}