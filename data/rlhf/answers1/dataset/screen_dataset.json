{"prompt": ["I need to make situation like screen session as 'Dead'?However, i don't know how to make the session status as 'Dead'Could you give some advises to make this status??", "i have this makefile:SHELL=/bin/bash\n\nCOMPILER_VERSION = \"Intel 64 Compiler 16.0.0.109 Build 20150815\"\n\nSOURCES = \\\nron1.f    \\\nron2.f   \\\nron3.f \\\nron4.f\n\nOBJECTS = $(SOURCES:.f=.o)\n\nTARGET = mylib.a\n\nFC = gfortran\nFFLAGS = -O3\n\nlinux: $(TARGET)\n    @echo\n    @echo \"   \" \\\n    ar r $(TARGET) $(OBJECTS)\n    @echo\n    @echo \"   \" \\\n    ranlib $(TARGET)\n    @echo\n\n$(TARGET): $(OBJECTS)\n\n$(OBJECTS):$(SOURCES)\n\ncleanall:\n    @echo\n    rm -f $(OBJECTS) $(TARGET)\n    @echo\nclean:\n    @echo\n    rm -f $(OBJECTS)\n    @echo\n\n.f.o:\n    @echo \"   \" \\\n    $(FC) -c $(FFLAGS) $*.f\nIt results the below output:prompt> make cleanall\n\nrm -f ron1.o ron2.o ron3.o ron4.o mylib.a\n\nprompt> make \n    gfortran -c -O3 ron1.f\n    gfortran -c -O3 ron2.f\n    gfortran -c -O3 ron3.f\n    gfortran -c -O3 ron4.f\n\n    ar r mylib.a ron1.o ron2.o ron3.o ron4.o\n\n    ranlib mylib.a\n\nprompt>\nwhat i am looking to do is create a space between \"prompt> make\" and the first happening of gfortran.and ideally i would like the output on the screen to first print out the contents of my COMPILER_VERSION variable before the first gfortran happens, such that the output would look likeprompt> make\n\n    makefile written for: Intel 64 Compiler 16.0.0.109 Build 20150815\n\n    gfortran -c -O3 ron1.f\n    gfortran -c -O3 ron2.f\n    gfortran -c -O3 ron3.f\n    and so on...\nany help much appreciated.", "i have this makefile:SHELL=/bin/bash\n\nCOMPILER_VERSION = \"Intel 64 Compiler 16.0.0.109 Build 20150815\"\n\nSOURCES = \\\nron1.f    \\\nron2.f   \\\nron3.f \\\nron4.f\n\nOBJECTS = $(SOURCES:.f=.o)\n\nTARGET = mylib.a\n\nFC = gfortran\nFFLAGS = -O3\n\nlinux: $(TARGET)\n    @echo\n    @echo \"   \" \\\n    ar r $(TARGET) $(OBJECTS)\n    @echo\n    @echo \"   \" \\\n    ranlib $(TARGET)\n    @echo\n\n$(TARGET): $(OBJECTS)\n\n$(OBJECTS):$(SOURCES)\n\ncleanall:\n    @echo\n    rm -f $(OBJECTS) $(TARGET)\n    @echo\nclean:\n    @echo\n    rm -f $(OBJECTS)\n    @echo\n\n.f.o:\n    @echo \"   \" \\\n    $(FC) -c $(FFLAGS) $*.f\nIt results the below output:prompt> make cleanall\n\nrm -f ron1.o ron2.o ron3.o ron4.o mylib.a\n\nprompt> make \n    gfortran -c -O3 ron1.f\n    gfortran -c -O3 ron2.f\n    gfortran -c -O3 ron3.f\n    gfortran -c -O3 ron4.f\n\n    ar r mylib.a ron1.o ron2.o ron3.o ron4.o\n\n    ranlib mylib.a\n\nprompt>\nwhat i am looking to do is create a space between \"prompt> make\" and the first happening of gfortran.and ideally i would like the output on the screen to first print out the contents of my COMPILER_VERSION variable before the first gfortran happens, such that the output would look likeprompt> make\n\n    makefile written for: Intel 64 Compiler 16.0.0.109 Build 20150815\n\n    gfortran -c -O3 ron1.f\n    gfortran -c -O3 ron2.f\n    gfortran -c -O3 ron3.f\n    and so on...\nany help much appreciated.", "I want to create a stop.sh file for stopping screen session.$test = \"screen_name\";\nThis is the command:kill -15 $(screen -ls | grep '[0-9]*\\.$test' | sed -E 's/\\s+([0-9]+)\\..*/\\1/'`)\nAnd I want to create this file with php ssh2_exec like this:ssh2_exec($connection, \"echo 'kill -15 $(screen -ls | grep '[0-9]*\\.$test' | sed -E 's/\\s+([0-9]+)\\..*/\\1/')' > /home/test/stop.sh\");\nBut I get this:sh: 1: Syntax error: \"(\" unexpected\nI tried:kill -15 $(screen -ls | grep \\'[0-9]*\\.$test\\' | sed -E \\'s/\\s+([0-9]+)\\..*/\\1/\\')\nBut this is not working.", "My situation is :1) I have a remote server , Ubuntu LTS 14.042) It has Eclipse in it (of course with huge workspace)3) I am using Windows 7 as my local Machine4) I want to run Eclipse from \"Windows\" on \"Linux\" and use it for developing. [I can, how ? mentioned below]5) When I exit eclipse it should keep running on server [Linux]6) I can come back and open the same session of eclipse.What I have done so far ?1) Installed Xming2) Installed Putty and enabled X11 forwarding.3) Connect to remote 4) Open ./eclipse.sh Works fineBut if I close, it will destroy the session I also tried the following :Method 1 :1) Installed tmux on Linux2) Created new session3) BUT when I try to run eclipse in this session, Error says It cannot open DisplayMethod 2 :1) Installed xpra on Linux2) created a display3) BUT when I try to open eclipse in THIS session , again the same error.So ,Can some one please help me telling the step by step process to run Eclipse on Remote so that It keeps on running and I can use THE SAME ECLIPSE in my windows as and when required WITHOUT closing the eclipse in the remote machine?I dont want to use remote project/system explore feature of eclipse.Please help :(", "I know I can get the screen resolution from the command line on Linux using xdpyinfo but is it also possible to do this from within a C program? If so how?", "I am fresh new on linux and tring to connect on a TV \nhttp://www.cnet.com/products/samsung-ln-s325d/specs/ using DVI.\nProblem: The screen resolution isn't good :(\nI've tried many things with the xrandr command, but in the end, the new mode just doesn't work (black screen).Here is the terminal:frank@frank-Mint ~ $ cvt 1366 768\n# 1368x768 59.88 Hz (CVT) hsync: 47.79 kHz; pclk: 85.25 MHz\nModeline \"1368x768_60.00\"   85.25  1368 1440 1576 1784  768 771 781 798     -hsync +vsync\nfrank@frank-Mint ~ $ xrandr --newmode \"1368x768_60.00\"   85.25  1368 1440     1576 1784  768 771 781 798 -hsync +vsync\nfrank@frank-Mint ~ $ xrandr --addmode DVI-1 \"1368x768_60.00\"\nFrom there,frank@frank-Mint ~ $ xrandr --output DVI-1 --mode 1368x768_60.00\nor system settings > Display >1368x768 (16:9)just gives me a black screen saying the mode is not availableI have tried many other resolutions, but any custom resolutions do that.Anyone have an idea?\nthanks! :)EDIT:frank@frank-Mint ~ $ xrandr\nScreen 0: minimum 320 x 200, current 1280 x 720, maximum 16384 x 16384\nDisplayPort-0 disconnected (normal left inverted right x axis y axis)\nHDMI-0 disconnected (normal left inverted right x axis y axis)\nDVI-0 disconnected (normal left inverted right x axis y axis)\nDVI-1 connected primary 1280x720+0+0 (normal left inverted right x axis y     axis) 160mm x 90mm\n   1280x720       60.0*+   59.9  \n   1920x1080i     60.1     60.0  \n   720x480        60.0     59.9  \n   640x480        60.0     59.9  \n   1368x768_60.00   59.9  \n   1024x768_60.00   59.9\nThe last 2 are added", "I currently have a problem calibrating monitors on centos7. \nUsing gnome or kde, I cannot properly use the color settings to apply a newly created ICC profile. The devices tab has not display listed (only a printer installed).After some reading I found that colord uses xrandr to detect displays and they should appear with the following call:$ colormgr get-devices\nThis does not bring any display devices (only the printer mentioned earlier).\nWhen I use xrandr I properly get my list of displays:$ xrandr\nScreen 0: minimum 8 x 8, current 1920 x 1200, maximum 16384 x 16384\nDVI-I-0 disconnected (normal left inverted right x axis y axis)\nDVI-I-1 disconnected (normal left inverted right x axis y axis)\nDP-0 disconnected (normal left inverted right x axis y axis)\nDP-1 connected primary 1920x1200+0+0 (normal left inverted right x axis y axis) 518mm x 324mm\n   1920x1200     59.95*+\n   1920x1080     60.00  \n   1680x1050     59.95  \n   1600x1200     60.00  \n   1280x1024     60.02  \n   1280x960      60.00  \n   1024x768      60.00  \n   800x600       60.32  \n   640x480       59.94  \nDoes anyone knows why this problem occurs and how I could work around it ?", "In a C program under Linux and ncurses, I need to acquire characters from the keyboard (so, from the user) and to store them into a string, which is considered complete only when the user presses Enter. At the same time, however, I need to display a screen echo for the user, so that he can see what he is writing and he can correct some typos, if necessary.My bunch of code is working, but it can't handle the erase and arrow characters.In this question a solution is provided to correctly store the string, when Backspace or Del are pressed. But what solution could be choosen in order to display a correct screen echo, even considering the arrow keys?My code is essentially:while(1)\n{\nif (getch() =! ERR)\n// store the character into an array\nif (getch() == 10)\n// terminate the string and print it on screen\n}\nThe characters are acquired through a getch() one by one. Like in the linked question, if I don't use noecho() and I press Backspace, the sequence ^? is displayed instead of removing the previous character from the screen. If I use noecho(), the program should show real-time to the user what's happening. Should I re-print the string at every while cycle? It would be cumbersome.So, how can I correctly display to the user what's happening?", "In a C program under Linux and ncurses, I need to acquire characters from the keyboard (so, from the user) and to store them into a string, which is considered complete only when the user presses Enter. At the same time, however, I need to display a screen echo for the user, so that he can see what he is writing and he can correct some typos, if necessary.My bunch of code is working, but it can't handle the erase and arrow characters.In this question a solution is provided to correctly store the string, when Backspace or Del are pressed. But what solution could be choosen in order to display a correct screen echo, even considering the arrow keys?My code is essentially:while(1)\n{\nif (getch() =! ERR)\n// store the character into an array\nif (getch() == 10)\n// terminate the string and print it on screen\n}\nThe characters are acquired through a getch() one by one. Like in the linked question, if I don't use noecho() and I press Backspace, the sequence ^? is displayed instead of removing the previous character from the screen. If I use noecho(), the program should show real-time to the user what's happening. Should I re-print the string at every while cycle? It would be cumbersome.So, how can I correctly display to the user what's happening?"], "chosen": ["\nrespawn-pane -kt sth:0.0 true\nif you want to kill all panes in a window you can just do\nrespawn-window -kt sth:0 true\n", "\nYou should add to the  'linux' target some prerequisite like 'ECHO' here:\nlinux: ECHO $(TARGET)\n     ar r $(TARGET) $(OBJECTS)\n     @echo\n     @echo \"   \" \\\n     ranlib $(TARGET)\n     @echo\n\nECHO:\n     @echo \"\\n\\n\\n\\n Makefile written for the compiler version ${COMPILER_VERSION}\"\n\n", "\nthanks a bunch, that worked.\nyour\nlinux: ECHO $(TARGET)\n\nworked great, only thing i did different than what you typed was this syntax for ECHO:  which i placed at the bottom of the makefile.  It allowed me to space out the screen output exactly how i wanted it.\nECHO:\n    @echo\n    @echo \"Makefile written for compiler version ${COMPILER_VERSION}\"\n    @echo\n\n", "\nAs per the comment regarding parsing anything within double quotes that begins with a $ you could try an alternative to construct the command string by using sprintf and wrapping the whole command in single quotes but with double quotes within.\n$test='banana';\n\n$cmd=sprintf('kill -15 $(screen -ls | grep \"[0-9]*\\.%s\" | sed -E \"s/\\s+([0-9]+)\\..*/\\1/\") > /home/test/stop.sh', $test );\necho $cmd;\n\nWhich yields a finalised command string:\nkill -15 $(screen -ls | grep \"[0-9]*\\.banana\" | sed -E \"s/\\s+([0-9]+)\\..*/\\1/\") > /home/test/stop.sh\n\nwhich looks OK, so you could then do:\nssh2_exec( $connection, $cmd );\n\n", "\nTry using TightVNC. \nInstall VNC server on your Ubuntu. It might already be there as this is a common deamon on Linux. Start the session\nvncserver :1 -geometry 1600x1200\n\nstating your preferred resolution of the desktop.\nInstall VNC client on Windows machine. Start it and enter the adress of your Ubuntu:  ip.address:display. For instance\n192.168.1.1:1\n\n(:0 is display you used in vncserver call above). If everything works fine you should see XWindows on your Ubuntu. Start Eclipse there and you are all set. It will run there and survive disconnection of your VNC client until you kill the vncserver session with a command like:\nvncserver -kill :1\n\n", "\nIf xdpyinfo works for you, just use that.  Create some pipes, fork(), connect the pipes, and exec(xdpyinfo)  It's a gazillion times easier than figuring out libX11; someone's already done that work for you.  This isn't the idiom I'd use, but it gets the idea across:\nint filedes[2];\nif (pipe(filedes) == -1) {\n  perror(\"pipe\");\n  exit(1);\n}\n\npid_t pid = fork();\nif (pid == -1) {\n  perror(\"fork\");\n  exit(1);\n} else if (pid == 0) {\n  while ((dup2(filedes[1], STDOUT_FILENO) == -1) && (errno == EINTR)) {}\n  close(filedes[1]);\n  close(filedes[0]);\n  execl(cmdpath, cmdname, (char*)0);\n  perror(\"execl\");\n  _exit(1);\n}\nclose(filedes[1]);\n\nThe while(...EINTR)) loop is just about guarding against interrupts during the file descriptor close and duplication.\n", "\nGot it. Needed to upgrate graphic card driver lol\n", "\nI know this is an old post.. nonetheless:\nI get this kind of behaviour when I'm messing with colord, such as trying to restart the server.  The behaviour usually goes away with a reboot (whereby colord is restarted correctly.)\nIf this is happening with a fresh boot/login, then I would check to verify that colord is installed correctly.\n", "\nIf you want to read characters until the user presses Enter, you probably want to use the getnstr function instead of reading a character at a time. getnstr will interpret erase and kill characters, although it is far from a complete line-editing system.\nOtherwise, you are going to end up having to handle all the cursor movement characters yourself. That's obviously more flexible but it's also a lot more work. If you go down that route, I suggest turning echo off and manually echoing (non-control) characters because that will give you much better control over the cursor position.\n", "\nIf the OP's program used the keypad() function, then left-cursor (arrow) and the erase key would have the same effect.  getnstr does not support inline editing (moving the cursor within the line).  (Incidentally, other implementations of curses do nothing with cursor-keys).\nAs an example of a program which does support inline-editing, dialog is useful (it works with UTF-8).  On the other hand, because it stores the responses as a plain character string, it is more complicated, say, than something explicitly written to use wget_wch.\ncdk does not handle UTF-8.\nncurses does not provide a more interesting function because:\n\nthat functionality is already in the form library\nit does not qualify as an extension because one can readily develop various functions of this sort without knowing the library's internals.\n\nRecently there was a related question (for blocking I/O) in ncurses, print and contemporary acquire strings (again, dialog does that).\n"], "rejected": ["\nOpen the Linux terminal and execute the following command:\nscreen -X -S [session number] quit\nUse the following command to remove a screen session:\nscreen -X -S <screen_id> kill\n", "\nYou can use echo with flag -e\n@echo -e \"\\n\"\n\n", "\nYou can use echo with flag -e\n@echo -e \"\\n\"\n\n", "\nWhat about trying this:\n$text = 'echo \\'kill -15 $(screen -ls | grep \\'[0-9]*\\.'$test.'\\' | sed -E \\'s/\\s+([0-9]+)\\..*/\\1/\\')\\' > /home/test/stop.sh\\' ;\nssh2_exec($connection, $text);\n\n", "\nYou can change the value of the DISPLAY variable of your Ubuntu machine to your Windows machine and then run it from the Ubuntu machine. Let's say, IP address of your Windows machine is 1.2.3.4 then you can set the DISPLAY variable to 1.2.3.4:0.\nFrom windows machine, SSH to Ubuntu machine and set DISPLAY variable\nexport DISPLAY=1.2.3.4:0\n\nThen run eclipse from Ubuntu and it should show up on your Windows machine. You can also access your remote code (i.e. the code from Ubuntu machine) and modify and save it to the remote machine. Hope it helps!   \n", "\nFollowing @Pablo's advice (thanks Pablo!) I was able to hack xdpyinfo.c to get what I want. Demo code is:\n#ifdef WIN32\n#include <X11/Xwindows.h>\n#endif\n\n#include <X11/Xlib.h>\n#include <stdio.h>\n#include <stdlib.h>\n\nstatic void\nprint_screen_info(Display *dpy, int scr)\n{\n    /*\n     * there are 2.54 centimeters to an inch; so there are 25.4 millimeters.\n     *\n     *     dpi = N pixels / (M millimeters / (25.4 millimeters / 1 inch))\n     *         = N pixels / (M inch / 25.4)\n     *         = N * 25.4 pixels / M inch\n     */\n\n    double xres, yres;\n\n    xres = ((((double) DisplayWidth(dpy,scr)) * 25.4) /\n            ((double) DisplayWidthMM(dpy,scr)));\n    yres = ((((double) DisplayHeight(dpy,scr)) * 25.4) /\n            ((double) DisplayHeightMM(dpy,scr)));\n\n    printf (\"\\n\");\n    printf (\"screen #%d:\\n\", scr);\n    printf (\"  dimensions:    %dx%d pixels (%dx%d millimeters)\\n\",\n            XDisplayWidth (dpy, scr),  XDisplayHeight (dpy, scr),\n            XDisplayWidthMM(dpy, scr), XDisplayHeightMM (dpy, scr));\n    printf (\"  resolution:    %dx%d dots per inch\\n\",\n            (int) (xres + 0.5), (int) (yres + 0.5));\n}\n\n\nint\nmain(int argc, char *argv[])\n{\n    Display *dpy;                        /* X connection */\n    char *displayname = NULL;            /* server to contact */\n    int i;                      \n\n    dpy = XOpenDisplay (displayname);\n    if (!dpy) {\n        fprintf (stderr, \"unable to open display \\\"%s\\\".\\n\",\n                 XDisplayName (displayname));\n        exit (1);\n    }\n\n    printf (\"name of display:    %s\\n\", DisplayString (dpy));\n    printf (\"default screen number:    %d\\n\", DefaultScreen (dpy));\n    printf (\"number of screens:    %d\\n\", ScreenCount (dpy));\n\n    for (i = 0; i < ScreenCount (dpy); i++) {\n        print_screen_info (dpy, i);\n    }\n\n    XCloseDisplay (dpy);\n    exit (0);\n}\n\nCompile with:\ngcc test.c -lX11\n\nOutput looks like:\nerpsim1:~/linux_lib/test> ./a.out \nname of display:    localhost:15.0\ndefault screen number:    0\nnumber of screens:    1\n\nscreen #0:\n  dimensions:    4400x1400 pixels (1552x494 millimeters)\n  resolution:    72x72 dots per inch\n\n", "\nTry this:\nxrandr --output DVI-1 --mode \"1368x768_60.00\"\n\n", "\nWe've updated to cent7.4 recently and colorgr seems to bring the correct result now.\n", "\nThis is my solution, it's pretty easy and don't need noecho();\ngetyx( stdscr, y, x ); //get current cursor position\nx-= 3; //go three position back, one for the char to erase, the other two to erase the backspace char ^? \nmvprintw( y, x, \"   \" ); //erase chars\nmove( y, x ); //get in right position for new input\n\n", "\nThis is my solution, it's pretty easy and don't need noecho();\ngetyx( stdscr, y, x ); //get current cursor position\nx-= 3; //go three position back, one for the char to erase, the other two to erase the backspace char ^? \nmvprintw( y, x, \"   \" ); //erase chars\nmove( y, x ); //get in right position for new input\n\n"]}